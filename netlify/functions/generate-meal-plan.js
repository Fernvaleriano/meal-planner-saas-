// Netlify Function for secure Gemini API calls with Claude macro correction
const GEMINI_API_KEY = process.env.GEMINI_API_KEY;
const GEMINI_API_URL = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent';

// Import Anthropic SDK for macro correction
const AnthropicModule = require('@anthropic-ai/sdk');
const Anthropic = AnthropicModule.default || AnthropicModule;
const ANTHROPIC_API_KEY = process.env.ANTHROPIC_API_KEY;

// USDA-verified food database for Claude corrections
const FOOD_DATABASE = {
  // Proteins
  'chicken_breast': { per: '100g', cal: 165, protein: 31, carbs: 0, fat: 4 },
  'ground_turkey': { per: '100g', cal: 176, protein: 25, carbs: 0, fat: 10 },
  'ground_beef_90': { per: '100g', cal: 176, protein: 21, carbs: 0, fat: 10 },
  'salmon': { per: '100g', cal: 177, protein: 20, carbs: 0, fat: 11 },
  'tilapia': { per: '100g', cal: 128, protein: 26, carbs: 0, fat: 3 },
  'shrimp': { per: '100g', cal: 106, protein: 23, carbs: 1, fat: 1 },
  'egg_large': { per: '1 egg', cal: 70, protein: 6, carbs: 0, fat: 5 },
  'greek_yogurt': { per: '100g', cal: 59, protein: 10, carbs: 4, fat: 0 },
  'cottage_cheese': { per: '100g', cal: 98, protein: 11, carbs: 3, fat: 4 },
  'whey_protein': { per: '1 scoop 30g', cal: 120, protein: 25, carbs: 3, fat: 1 },

  // Carbs
  'brown_rice_cooked': { per: '100g', cal: 112, protein: 2, carbs: 24, fat: 1 },
  'white_rice_cooked': { per: '100g', cal: 130, protein: 3, carbs: 28, fat: 0 },
  'quinoa_cooked': { per: '100g', cal: 120, protein: 4, carbs: 21, fat: 2 },
  'sweet_potato': { per: '100g', cal: 86, protein: 2, carbs: 20, fat: 0 },
  'oats_cooked': { per: '100g', cal: 71, protein: 2, carbs: 12, fat: 1 },
  'whole_wheat_bread': { per: '1 slice 28g', cal: 80, protein: 4, carbs: 14, fat: 1 },
  'pasta_cooked': { per: '100g', cal: 131, protein: 5, carbs: 25, fat: 1 },

  // Fats
  'avocado': { per: '100g', cal: 160, protein: 2, carbs: 9, fat: 15 },
  'olive_oil': { per: '1 tbsp 14g', cal: 120, protein: 0, carbs: 0, fat: 14 },
  'almond_butter': { per: '1 tbsp 16g', cal: 95, protein: 3, carbs: 3, fat: 9 },
  'almonds': { per: '28g', cal: 160, protein: 6, carbs: 6, fat: 14 },
  'cheddar_cheese': { per: '28g', cal: 115, protein: 7, carbs: 0, fat: 9 },

  // Vegetables
  'broccoli': { per: '100g', cal: 34, protein: 3, carbs: 7, fat: 0 },
  'spinach': { per: '100g', cal: 23, protein: 3, carbs: 4, fat: 0 },
  'bell_pepper': { per: '100g', cal: 26, protein: 1, carbs: 6, fat: 0 },
  'asparagus': { per: '100g', cal: 20, protein: 2, carbs: 4, fat: 0 },
  'green_beans': { per: '100g', cal: 31, protein: 2, carbs: 7, fat: 0 },

  // Fruits
  'banana': { per: '1 medium 118g', cal: 105, protein: 1, carbs: 27, fat: 0 },
  'apple': { per: '1 medium 182g', cal: 95, protein: 0, carbs: 25, fat: 0 },
  'blueberries': { per: '100g', cal: 57, protein: 1, carbs: 14, fat: 0 },
  'strawberries': { per: '100g', cal: 32, protein: 1, carbs: 8, fat: 0 }
};

/**
 * Corrects meal macro calculations using Claude API
 * Takes Gemini's creative meal and asks Claude to verify/correct the macros
 */
async function correctMealMacros(geminiMeal) {
  if (!ANTHROPIC_API_KEY) {
    console.warn('‚ö†Ô∏è ANTHROPIC_API_KEY not configured, skipping macro correction');
    return geminiMeal; // Return original if Claude not available
  }

  try {
    console.log(`üîç Claude correcting macros for: ${geminiMeal.name}`);

    const anthropic = new Anthropic({
      apiKey: ANTHROPIC_API_KEY,
    });

    // Build correction prompt with properly escaped meal data
    const mealData = {
      name: geminiMeal.name,
      calories: geminiMeal.calories,
      protein: geminiMeal.protein,
      carbs: geminiMeal.carbs,
      fat: geminiMeal.fat,
      instructions: geminiMeal.instructions
    };

    const correctionPrompt = `You are a precision nutrition calculator. I have a meal generated by another AI, but the macro calculations may be incorrect.

## FOOD DATABASE (USDA-VERIFIED):
${JSON.stringify(FOOD_DATABASE, null, 2)}

## MEAL TO CORRECT:
${JSON.stringify(mealData, null, 2)}

## YOUR TASK:
1. Analyze the meal name and instructions to identify the ingredients and portions
2. Using ONLY foods from the database above, calculate the correct macros
3. Verify the math: (protein √ó 4) + (carbs √ó 4) + (fat √ó 9) should approximately equal calories
4. Return a corrected version of this meal with accurate macros

## CRITICAL RULES:
- Keep the same meal name and instructions (DO NOT change the meal itself)
- ONLY correct the macro numbers (calories, protein, carbs, fat)
- Use realistic portions based on the meal description
- Make sure the math is correct: (P√ó4) + (C√ó4) + (F√ó9) ‚âà calories

## RESPONSE FORMAT (JSON only, no markdown):
{
  "name": "keep original name",
  "calories": <corrected_integer>,
  "protein": <corrected_integer>,
  "carbs": <corrected_integer>,
  "fat": <corrected_integer>,
  "instructions": "keep original instructions",
  "correction_notes": "Brief explanation of what was corrected and why"
}

Return ONLY the JSON object, no markdown, no backticks.`;

    const message = await anthropic.messages.create({
      model: "claude-3-5-sonnet-20241022",
      max_tokens: 1024,
      temperature: 0.3, // Low temperature for precision
      messages: [
        {
          role: "user",
          content: correctionPrompt
        }
      ]
    });

    const responseText = message.content[0].text;
    console.log('ü§ñ Claude correction response preview:', responseText.substring(0, 300));

    // Parse JSON
    const correctedMeal = extractJSON(responseText);

    // Validate corrected meal has all required fields
    if (!correctedMeal.name || !correctedMeal.calories || !correctedMeal.protein ||
        !correctedMeal.carbs || !correctedMeal.fat || !correctedMeal.instructions) {
      console.error('‚ùå Claude correction missing fields, using original');
      return geminiMeal;
    }

    console.log(`‚úÖ Claude corrected: ${correctedMeal.calories} cal (was ${geminiMeal.calories})`);
    if (correctedMeal.correction_notes) {
      console.log(`üìù Correction notes: ${correctedMeal.correction_notes}`);
    }

    return correctedMeal;

  } catch (error) {
    console.error('‚ùå Claude correction error:', error.message);
    console.warn('‚ö†Ô∏è Falling back to original Gemini meal');
    return geminiMeal; // Fallback to original on error
  }
}

exports.handler = async (event, context) => {
  // Only allow POST requests
  if (event.httpMethod !== 'POST') {
    return {
      statusCode: 405,
      body: JSON.stringify({ error: 'Method not allowed' })
    };
  }

  // Check if API key is configured
  if (!GEMINI_API_KEY) {
    console.error('‚ùå GEMINI_API_KEY not configured in environment variables');
    return {
      statusCode: 500,
      body: JSON.stringify({ error: 'API key not configured' })
    };
  }

  try {
    const { prompt, targets, previousAttempt } = JSON.parse(event.body);

    if (!prompt) {
      return {
        statusCode: 400,
        body: JSON.stringify({ error: 'Prompt is required' })
      };
    }

    console.log('üì§ Calling Gemini API...');
    if (targets) {
      console.log('Targets:', targets);
    }
    
    // ‚úÖ FIXED: Proper fetch syntax with parentheses
    const response = await fetch(`${GEMINI_API_URL}?key=${GEMINI_API_KEY}`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        contents: [{
          parts: [{
            text: prompt
          }]
        }],
        generationConfig: {
          temperature: 0.7,
          maxOutputTokens: 2048,
          topP: 0.95,
          topK: 40
        }
      })
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('‚ùå Gemini API Error:', errorText);
      return {
        statusCode: response.status,
        body: JSON.stringify({ 
          error: 'Gemini API request failed',
          details: errorText
        })
      };
    }

    const data = await response.json();
    console.log('‚úÖ Gemini API Response received');
    console.log('Full response structure:', JSON.stringify(data, null, 2));

    // Validate response structure
    if (!data.candidates || !data.candidates[0] || !data.candidates[0].content) {
      console.error('‚ùå Invalid response structure:', JSON.stringify(data));
      return {
        statusCode: 500,
        body: JSON.stringify({
          error: 'Invalid response from Gemini API',
          data: data
        })
      };
    }

    // Validate parts array exists
    if (!data.candidates[0].content.parts || !data.candidates[0].content.parts[0]) {
      console.error('‚ùå Missing parts in response:', JSON.stringify(data));
      return {
        statusCode: 500,
        body: JSON.stringify({
          error: 'Invalid response structure from Gemini API',
          message: 'Missing parts array in response',
          data: data
        })
      };
    }

    // Log first 500 chars of AI response for debugging
    const responseText = data.candidates[0].content.parts[0].text;
    console.log('ü§ñ Gemini Response preview:', responseText.substring(0, 500));

    // Parse JSON (handle markdown-wrapped responses)
    const jsonData = extractJSON(responseText);

    // üéØ NEW: Correct macros using Claude
    console.log('üîÑ Starting Claude macro correction...');
    let correctedData = jsonData;

    // Handle both single meal and array of meals
    if (Array.isArray(jsonData)) {
      console.log(`üìä Correcting ${jsonData.length} meals with Claude...`);
      correctedData = [];
      for (let i = 0; i < jsonData.length; i++) {
        console.log(`‚è≥ Correcting meal ${i + 1}/${jsonData.length}...`);
        const correctedMeal = await correctMealMacros(jsonData[i]);
        correctedData.push(correctedMeal);
      }
      console.log(`‚úÖ All ${jsonData.length} meals corrected!`);
    } else if (jsonData.name && jsonData.calories) {
      // Single meal object
      console.log('üìä Correcting single meal with Claude...');
      correctedData = await correctMealMacros(jsonData);
      console.log('‚úÖ Meal corrected!');
    } else {
      console.log('‚ö†Ô∏è Unexpected data format, skipping correction');
    }

    return {
      statusCode: 200,
      headers: {
        'Content-Type': 'application/json',
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Headers': 'Content-Type'
      },
      body: JSON.stringify({
        success: true,
        data: correctedData,
        rawResponse: responseText,
        claudeCorrected: ANTHROPIC_API_KEY ? true : false
      })
    };

  } catch (error) {
    console.error('‚ùå Function error:', error);
    console.error('Error stack:', error.stack);
    return {
      statusCode: 500,
      body: JSON.stringify({
        error: 'Internal server error',
        message: error.message,
        details: error.stack,
        apiKey: GEMINI_API_KEY ? 'configured' : 'missing'
      })
    };
  }
};

function extractJSON(text) {
  // Remove markdown code blocks if present
  let cleaned = text.trim();

  // Remove ```json and ``` if wrapped
  if (cleaned.startsWith('```json')) {
    cleaned = cleaned.replace(/^```json\s*/, '').replace(/\s*```$/, '');
  } else if (cleaned.startsWith('```')) {
    cleaned = cleaned.replace(/^```\s*/, '').replace(/\s*```$/, '');
  }

  // Try to parse
  try {
    return JSON.parse(cleaned);
  } catch (error) {
    // Try to extract JSON from text
    const jsonMatch = cleaned.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      return JSON.parse(jsonMatch[0]);
    }
    throw new Error('Could not extract valid JSON from response');
  }
}
