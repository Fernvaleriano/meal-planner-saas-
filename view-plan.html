<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Your Meal Plan - Zique Fitness Nutrition</title>
    <!-- Prevent caching to avoid stale data on back navigation -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0d9488 0%, #0284c7 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .header h1 {
            color: #0d9488;
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .back-btn:hover {
            color: #0284c7;
        }

        .client-info {
            background: #f8f9ff;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 30px;
        }

        .section-title {
            color: #0d9488;
            font-weight: 700;
            font-size: 1.1em;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e0e7ff;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .info-item {
            padding: 15px;
            background: white;
            border-radius: 10px;
            border: 2px solid #e0e7ff;
        }

        .info-label {
            color: #0d9488;
            font-weight: 600;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .info-value {
            color: #333;
            font-size: 1.2em;
            font-weight: 700;
        }

        .meal-card {
            background: #f8f9ff;
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 25px;
            border: 2px solid #e0e7ff;
        }

        .meal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .meal-name {
            color: #0d9488;
            font-size: 1.8em;
            font-weight: 700;
        }

        .meal-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9em;
        }

        .btn-change {
            background: #0d9488;
            color: white;
        }

        .btn-change:hover {
            background: #5568d3;
            transform: translateY(-2px);
        }

        .btn-revise {
            background: #0284c7;
            color: white;
        }

        .btn-revise:hover {
            background: #653a8a;
            transform: translateY(-2px);
        }

        .btn-undo {
            background: #dc2626;
            color: white;
        }

        .btn-undo:hover {
            background: #b91c1c;
            transform: translateY(-2px);
        }

        .btn-custom {
            background: #7c3aed;
            color: white;
        }

        .btn-custom:hover {
            background: #6d28d9;
            transform: translateY(-2px);
        }

        .btn-favorite {
            background: transparent;
            color: #e53e3e;
            border: 2px solid #fed7d7;
            padding: 8px 14px;
            font-size: 1.1em;
        }

        .btn-favorite:hover {
            background: #fed7d7;
            transform: translateY(-2px);
        }

        .btn-favorite.active {
            background: #fed7d7;
            color: #c53030;
        }

        .modified-badge {
            display: inline-block;
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.7em;
            font-weight: 600;
            margin-left: 10px;
            vertical-align: middle;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .btn-reset {
            background: linear-gradient(135deg, #6b7280, #4b5563);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            margin-left: 10px;
        }

        .btn-reset:hover {
            background: linear-gradient(135deg, #4b5563, #374151);
            transform: translateY(-1px);
        }

        .modified-notice {
            background: linear-gradient(135deg, #fef3c7, #fde68a);
            border-left: 4px solid #f59e0b;
            padding: 12px 16px;
            margin-bottom: 20px;
            border-radius: 0 8px 8px 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .modified-notice p {
            margin: 0;
            color: #92400e;
            font-size: 0.9em;
        }

        .macro-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .macro-item {
            background: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid #e0e7ff;
        }

        .macro-label {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .macro-value {
            color: #0d9488;
            font-size: 1.5em;
            font-weight: 700;
        }

        .instructions {
            background: #fff4e6;
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #ffa726;
            margin-top: 15px;
        }

        .instructions-label {
            color: #e65100;
            font-weight: 600;
            margin-bottom: 8px;
            display: block;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            margin-top: 40px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn-primary {
            background: linear-gradient(135deg, #0d9488 0%, #0284c7 100%);
            color: white;
            padding: 15px 40px;
            font-size: 1.1em;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
            padding: 15px 40px;
            font-size: 1.1em;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .revise-section {
            margin-top: 15px;
            padding: 15px;
            background: white;
            border-radius: 10px;
        }

        .revise-input {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #0d9488;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 10px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes slideOut {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 20px;
            padding: 40px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }

        .modal-header {
            text-align: center;
            margin-bottom: 25px;
        }

        .modal-header h2 {
            color: #0d9488;
            font-size: 1.8em;
            margin-bottom: 10px;
        }

        .share-link-container {
            background: #f8f9ff;
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #e0e7ff;
            margin-bottom: 20px;
            word-break: break-all;
        }

        .share-link {
            color: #0d9488;
            font-weight: 600;
            font-size: 0.95em;
        }

        .btn-copy {
            background: #0d9488;
            color: white;
            width: 100%;
            padding: 15px;
            font-size: 1.1em;
        }

        .btn-copy:hover {
            background: #5568d3;
        }

        .btn-close-modal {
            background: #6c757d;
            color: white;
            width: 100%;
            padding: 15px;
            font-size: 1.1em;
            margin-top: 10px;
        }

        .btn-close-modal:hover {
            background: #5a6268;
        }

        /* Custom Meal Modal Styles */
        .custom-meal-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .custom-meal-tab {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #e0e7ff;
            border-radius: 10px;
            background: #f8f9ff;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }

        .custom-meal-tab:hover {
            border-color: #0d9488;
        }

        .custom-meal-tab.active {
            background: #0d9488;
            color: white;
            border-color: #0d9488;
        }

        .custom-meal-tab-icon {
            font-size: 1.5em;
            display: block;
            margin-bottom: 5px;
        }

        .custom-meal-tab-label {
            font-size: 0.85em;
            font-weight: 600;
        }

        .custom-meal-panel {
            display: none;
        }

        .custom-meal-panel.active {
            display: block;
        }

        .custom-meal-input {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e0e7ff;
            border-radius: 10px;
            font-size: 1em;
            margin-bottom: 15px;
            box-sizing: border-box;
        }

        .custom-meal-input:focus {
            outline: none;
            border-color: #0d9488;
        }

        .custom-meal-textarea {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e0e7ff;
            border-radius: 10px;
            font-size: 1em;
            margin-bottom: 15px;
            min-height: 100px;
            resize: vertical;
            box-sizing: border-box;
            font-family: inherit;
        }

        .custom-meal-textarea:focus {
            outline: none;
            border-color: #0d9488;
        }

        .macro-inputs {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .macro-input-group {
            display: flex;
            flex-direction: column;
        }

        .macro-input-group label {
            font-size: 0.85em;
            color: #666;
            margin-bottom: 5px;
            font-weight: 600;
        }

        .macro-input-group input {
            padding: 10px 12px;
            border: 2px solid #e0e7ff;
            border-radius: 8px;
            font-size: 1em;
            text-align: center;
        }

        .macro-input-group input:focus {
            outline: none;
            border-color: #0d9488;
        }

        .custom-meal-hint {
            font-size: 0.8em;
            color: #888;
            margin-bottom: 15px;
            padding: 10px;
            background: #f8f9ff;
            border-radius: 8px;
        }

        .btn-submit-custom {
            background: #0d9488;
            color: white;
            width: 100%;
            padding: 15px;
            font-size: 1.1em;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
        }

        .btn-submit-custom:hover {
            background: #0b7a6e;
        }

        .btn-submit-custom:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        /* USDA Search Styles */
        .usda-search-container {
            position: relative;
            margin-bottom: 15px;
        }

        .usda-search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #e0e7ff;
            border-top: none;
            border-radius: 0 0 10px 10px;
            max-height: 250px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .usda-search-results.active {
            display: block;
        }

        .usda-search-item {
            padding: 10px 12px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            transition: background 0.2s;
        }

        .usda-search-item:hover {
            background: #f0fdf4;
        }

        .usda-search-item:last-child {
            border-bottom: none;
        }

        .usda-food-name {
            font-weight: 600;
            color: #333;
            font-size: 0.9em;
            margin-bottom: 3px;
        }

        .usda-food-macros {
            font-size: 0.75em;
            color: #666;
        }

        .usda-search-loading, .usda-search-empty {
            padding: 15px;
            text-align: center;
            color: #888;
            font-size: 0.9em;
        }

        /* Selected Ingredients Styles */
        .selected-ingredients {
            background: #f8f9ff;
            border-radius: 10px;
            padding: 12px;
            margin-bottom: 15px;
        }

        .selected-ingredients-header {
            display: flex;
            justify-content: space-between;
            font-weight: 600;
            color: #555;
            font-size: 0.9em;
            margin-bottom: 10px;
        }

        .ingredients-list {
            max-height: 150px;
            overflow-y: auto;
        }

        .no-ingredients {
            color: #aaa;
            font-size: 0.85em;
            text-align: center;
            padding: 10px;
        }

        .ingredient-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 10px;
            background: white;
            border-radius: 8px;
            margin-bottom: 6px;
            font-size: 0.85em;
        }

        .ingredient-item:last-child {
            margin-bottom: 0;
        }

        .ingredient-name {
            flex: 1;
            font-weight: 500;
            color: #333;
        }

        .ingredient-qty {
            width: 60px;
            padding: 5px 8px;
            border: 1px solid #ddd;
            border-radius: 5px;
            text-align: center;
            font-size: 0.9em;
        }

        .ingredient-unit {
            color: #888;
            font-size: 0.9em;
        }

        .ingredient-remove {
            background: #fee2e2;
            color: #dc2626;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 1em;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .ingredient-remove:hover {
            background: #fecaca;
        }

        /* Calculated Totals Styles */
        .calculated-totals {
            background: linear-gradient(135deg, #0d9488 0%, #14b8a6 100%);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            color: white;
        }

        .totals-header {
            font-weight: 600;
            margin-bottom: 10px;
            font-size: 0.95em;
        }

        .totals-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
        }

        .total-item {
            text-align: center;
        }

        .total-value {
            display: block;
            font-size: 1.3em;
            font-weight: 700;
        }

        .total-label {
            font-size: 0.75em;
            opacity: 0.9;
        }

        .btn-share {
            background: #28a745;
            color: white;
            padding: 15px 40px;
            font-size: 1.1em;
        }

        .btn-share:hover {
            background: #218838;
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(40, 167, 69, 0.4);
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }

            .header h1 {
                font-size: 1.8em;
            }

            .macro-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .modal-content {
                padding: 25px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header" style="position: relative;">
            <a href="#" id="backButton" class="back-btn" style="position: absolute; left: 0; top: 50%; transform: translateY(-50%); display: flex; align-items: center; gap: 6px; color: #0d9488; text-decoration: none; font-weight: 600; font-size: 0.95em;">
                <span style="font-size: 1.2em;">‚Üê</span> Back
            </a>
            <h1 id="planHeader">Your Meal Plan</h1>
            <button id="resetToOriginalBtn" class="btn-reset" onclick="resetToOriginal()" style="display: none;">‚Ü∫ Reset to Original</button>
        </div>

        <div class="client-info">
            <div class="section-title">Your Daily Targets</div>
            <div class="info-grid">
                <div class="info-item">
                    <div class="info-label">Calories</div>
                    <div class="info-value" id="totalCalories">Loading...</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Protein</div>
                    <div class="info-value" id="totalProtein">Loading...</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Carbs</div>
                    <div class="info-value" id="totalCarbs">Loading...</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Fat</div>
                    <div class="info-value" id="totalFat">Loading...</div>
                </div>
            </div>
        </div>

        <div id="mealsContainer"></div>

        <div class="action-buttons">
            <button class="btn btn-primary" onclick="showMealPrepGuide()" style="background:#ff6b6b;">üìã Meal Prep Guide</button>
            <button class="btn btn-primary" onclick="downloadPDF()">üì• Download PDF</button>
            <button id="sharePlanBtn" class="btn btn-share" onclick="generateShareLink()" style="display: none;">üîó Share Plan Link</button>
            <button id="generateNewBtn" class="btn btn-secondary" onclick="window.location.href='planner.html'" style="display: none;">‚Üê Generate New Plan</button>
        </div>
    </div>

    <!-- Meal Prep Guide Modal -->
    <div id="mealPrepModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 900px; max-height: 85vh; overflow-y: auto;">
            <div class="modal-header">
                <h2>üìã Meal Prep Guide</h2>
                <button class="close-btn" onclick="closeMealPrepModal()">&times;</button>
            </div>
            <div id="mealPrepContent" style="padding: 20px;">
                <div style="text-align: center; padding: 40px;">
                    <div class="loader" style="margin: 0 auto 20px;"></div>
                    <p style="color: #666;">Generating your comprehensive meal prep guide...</p>
                </div>
            </div>
            <div style="padding: 20px; border-top: 1px solid #ddd; text-align: right;">
                <button class="btn btn-secondary" onclick="closeMealPrepModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Share Modal -->
    <div id="shareModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üîó Share Your Meal Plan</h2>
                <p style="color: #666;">Share this link with your client</p>
            </div>
            <div class="share-link-container">
                <div class="share-link" id="shareLinkText">Generating link...</div>
            </div>
            <button class="btn btn-copy" onclick="copyShareLink()">üìã Copy Link</button>
            <button class="btn btn-close-modal" onclick="closeShareModal()">Close</button>
        </div>
    </div>

    <!-- Custom Meal Modal -->
    <div id="customMealModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 450px;">
            <div class="modal-header">
                <h2>üéØ Custom Meal</h2>
                <p style="color: #666;">Create your own meal</p>
            </div>

            <!-- Tabs -->
            <div class="custom-meal-tabs">
                <div class="custom-meal-tab active" onclick="switchCustomMealTab('calculate')">
                    <span class="custom-meal-tab-icon">üßÆ</span>
                    <span class="custom-meal-tab-label">Calculate from Ingredients</span>
                </div>
                <div class="custom-meal-tab" onclick="switchCustomMealTab('manual')">
                    <span class="custom-meal-tab-icon">‚úèÔ∏è</span>
                    <span class="custom-meal-tab-label">Enter Macros Manually</span>
                </div>
            </div>

            <!-- Calculate Panel -->
            <div id="calculatePanel" class="custom-meal-panel active">
                <div class="custom-meal-hint">
                    üí° Search USDA database for ingredients. Add them with quantities to calculate macros.
                </div>

                <!-- USDA Search Input -->
                <div class="usda-search-container">
                    <input
                        type="text"
                        id="usdaSearchInput"
                        class="custom-meal-input"
                        placeholder="Search foods (e.g., chicken breast, rice, broccoli)..."
                        oninput="handleUsdaSearch(this.value)"
                        autocomplete="off"
                    >
                    <div id="usdaSearchResults" class="usda-search-results"></div>
                </div>

                <!-- Selected Ingredients List -->
                <div id="selectedIngredients" class="selected-ingredients">
                    <div class="selected-ingredients-header">
                        <span>Selected Ingredients</span>
                        <span id="ingredientCount">(0)</span>
                    </div>
                    <div id="ingredientsList" class="ingredients-list">
                        <div class="no-ingredients">No ingredients added yet</div>
                    </div>
                </div>

                <!-- Calculated Totals -->
                <div id="calculatedTotals" class="calculated-totals" style="display: none;">
                    <div class="totals-header">üìä Total Nutrition</div>
                    <div class="totals-grid">
                        <div class="total-item">
                            <span class="total-value" id="totalCalories">0</span>
                            <span class="total-label">Calories</span>
                        </div>
                        <div class="total-item">
                            <span class="total-value" id="totalProtein">0g</span>
                            <span class="total-label">Protein</span>
                        </div>
                        <div class="total-item">
                            <span class="total-value" id="totalCarbs">0g</span>
                            <span class="total-label">Carbs</span>
                        </div>
                        <div class="total-item">
                            <span class="total-value" id="totalFat">0g</span>
                            <span class="total-label">Fat</span>
                        </div>
                    </div>
                </div>

                <!-- Meal Name Input -->
                <input
                    type="text"
                    id="calculatedMealName"
                    class="custom-meal-input"
                    placeholder="Meal name (optional - auto-generated if blank)"
                    style="margin-top: 10px;"
                >

                <button class="btn-submit-custom" onclick="submitCalculatedMeal()" id="createCalculatedMealBtn" disabled>
                    üßÆ Create Meal
                </button>
            </div>

            <!-- Manual Panel -->
            <div id="manualPanel" class="custom-meal-panel">
                <div class="custom-meal-hint">
                    üí° Enter the meal name and macros directly. Use nutrition labels or apps like MyFitnessPal.
                </div>
                <input
                    type="text"
                    id="customMealName"
                    class="custom-meal-input"
                    placeholder="Meal name (e.g., Protein Shake, Chipotle Bowl)"
                >
                <div class="macro-inputs">
                    <div class="macro-input-group">
                        <label>Calories</label>
                        <input type="number" id="customMealCalories" placeholder="0">
                    </div>
                    <div class="macro-input-group">
                        <label>Protein (g)</label>
                        <input type="number" id="customMealProtein" placeholder="0">
                    </div>
                    <div class="macro-input-group">
                        <label>Carbs (g)</label>
                        <input type="number" id="customMealCarbs" placeholder="0">
                    </div>
                    <div class="macro-input-group">
                        <label>Fat (g)</label>
                        <input type="number" id="customMealFat" placeholder="0">
                    </div>
                </div>
                <input
                    type="text"
                    id="customMealInstructions"
                    class="custom-meal-input"
                    placeholder="Instructions (optional)"
                >
                <button class="btn-submit-custom" onclick="submitManualMeal()">
                    ‚úÖ Create Meal
                </button>
            </div>

            <button class="btn btn-close-modal" onclick="closeCustomMealModal()" style="margin-top: 15px;">Cancel</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
        // Initialize Supabase client
        const SUPABASE_URL = 'https://qewqcjzlfqamqwbccapr.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFld3FjanpsZnFhbXF3YmNjYXByIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM2OTg0NzAsImV4cCI6MjA3OTI3NDQ3MH0.mQnMC33O88oLkLLGWD2oG-oaSHGI-NfHmtQCZxnxSLs';

        const { createClient } = supabase;
        const supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        const API_ENDPOINT = '/.netlify/functions/generate-meal-plan';
        const SAVE_PLAN_ENDPOINT = '/.netlify/functions/save-shared-plan';
        const GET_PLAN_ENDPOINT = '/.netlify/functions/get-shared-plan';
        const TOGGLE_FAVORITE_ENDPOINT = '/.netlify/functions/toggle-favorite';
        const SAVE_CLIENT_MODIFICATION_ENDPOINT = '/.netlify/functions/save-client-modification';
        const RESET_CLIENT_MODIFICATION_ENDPOINT = '/.netlify/functions/reset-client-modification';
        let currentPlan = null;
        let clientFavorites = [];
        let currentShareUrl = '';
        let realtimeChannel = null;
        let currentPlanId = null;
        let currentClientId = null; // Track client ID for saving modifications
        let isClientModified = false; // Track if client has modified the plan
        let isClientView = false; // Track if viewing as client
        let previousMealStates = {}; // Store previous meal states for undo functionality

        // Custom meal modal state
        let currentCustomMealIndex = null;
        let currentCustomMealDayIndex = null;
        let currentCustomMealMealIndex = null;

        // USDA search state
        const USDA_SEARCH_ENDPOINT = '/.netlify/functions/usda-search';
        let selectedIngredients = [];
        let usdaSearchTimeout = null;
        let usdaSearchResults = []; // Store search results for safe onclick handling

        // Simple notification function
        function showNotification(message, type = 'info') {
            // Create notification element
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 15px 25px;
                border-radius: 8px;
                color: white;
                font-weight: 500;
                z-index: 10000;
                animation: slideIn 0.3s ease;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            `;
            notification.style.background = type === 'success' ? '#10b981' : type === 'error' ? '#ef4444' : '#3b82f6';
            notification.textContent = message;
            document.body.appendChild(notification);

            // Auto-remove after 3 seconds
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        // Helper function to escape HTML and convert URLs to clickable links
        function linkifyText(text) {
            if (!text) return '';

            // First escape HTML to prevent XSS
            const escaped = text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');

            // URL regex pattern - matches http, https, and www URLs
            const urlPattern = /(\b(https?:\/\/|www\.)[^\s<]+[^\s<.,;:!?"'\])}>])/gi;

            // Convert URLs to clickable links
            return escaped.replace(urlPattern, (url) => {
                let href = url;
                // Add https:// if URL starts with www.
                if (url.toLowerCase().startsWith('www.')) {
                    href = 'https://' + url;
                }
                return `<a href="${href}" target="_blank" rel="noopener noreferrer" style="color: #0284c7; text-decoration: underline;">${url}</a>`;
            });
        }

        // Detect if page was loaded from back/forward cache and force reload
        window.addEventListener('pageshow', function(event) {
            if (event.persisted) {
                // Page was loaded from bfcache (back/forward cache)
                console.log('Page loaded from cache, forcing reload...');
                window.location.reload();
            }
        });

        // Load meal plan
        document.addEventListener('DOMContentLoaded', async function() {
            // Check URL parameters
            const urlParams = new URLSearchParams(window.location.search);
            const shareId = urlParams.get('share');
            const planId = urlParams.get('planId');
            const clientView = urlParams.get('clientView') === 'true';
            const fromClientId = urlParams.get('fromClient');

            // Set back button URL based on view type
            const backButton = document.getElementById('backButton');
            if (fromClientId) {
                // Coach viewing from client profile - go back to client profile
                backButton.href = `client-profile.html?clientId=${fromClientId}`;
            } else if (clientView || shareId) {
                backButton.href = 'client-dashboard.html';
            } else {
                backButton.href = 'dashboard.html';
            }

            if (shareId) {
                // Load shared plan from database (client view)
                loadSharedPlan(shareId);
            } else if (planId) {
                // Load plan from database by ID (coach or client viewing)
                await loadCoachPlan(planId, clientView);
            } else {
                // Load from localStorage (newly generated plan)
                const planData = localStorage.getItem('currentMealPlan');

                if (!planData) {
                    alert('No meal plan found. Redirecting...');
                    window.location.href = 'planner.html';
                    return;
                }

                try {
                    currentPlan = JSON.parse(planData);
                    console.log('Loaded plan from localStorage:', currentPlan);

                    // Show coach-only buttons
                    document.getElementById('sharePlanBtn').style.display = 'inline-block';
                    document.getElementById('generateNewBtn').style.display = 'inline-block';

                    displayMealPlan();
                } catch (error) {
                    console.error('Error loading plan:', error);
                    alert('Error loading plan. Please generate a new one.');
                    window.location.href = 'planner.html';
                }
            }
        });

        // Load shared plan from database
        async function loadSharedPlan(shareId) {
            try {
                console.log('üì• Loading shared plan:', shareId);

                const response = await fetch(`${GET_PLAN_ENDPOINT}?shareId=${shareId}`);

                if (!response.ok) {
                    throw new Error('Failed to load shared plan');
                }

                const data = await response.json();
                currentPlan = data.planData;

                console.log('‚úÖ Loaded shared plan:', currentPlan);

                // Also save to localStorage for offline access
                localStorage.setItem('currentMealPlan', JSON.stringify(currentPlan));

                displayMealPlan();

                // Update header with client name
                const clientName = currentPlan.clientName || 'Client';
                const mealCount = currentPlan.meals ? currentPlan.meals.length : 0;
                const planText = mealCount > 1 ? 'Meal Plans' : 'Meal Plan';
                document.getElementById('planHeader').textContent = `üî• ${clientName}'s ${planText}`;

            } catch (error) {
                console.error('‚ùå Error loading shared plan:', error);
                alert('Failed to load shared plan. The link may be invalid or expired.');
                window.location.href = 'planner.html';
            }
        }

        // Load coach plan from database by ID
        async function loadCoachPlan(planId, clientView = false) {
            // Store in global variable
            isClientView = clientView;

            try {
                console.log('Loading plan:', planId, 'Client view:', isClientView);

                // Clear any cached session data to force fresh fetch
                await supabaseClient.auth.refreshSession();

                // Check if user is logged in
                const { data: { session }, error: sessionError } = await supabaseClient.auth.getSession();

                if (sessionError || !session) {
                    alert('Please log in to view this plan.');
                    const redirectUrl = isClientView ? 'client-login.html' : 'index.html';
                    window.location.href = redirectUrl;
                    return;
                }

                const currentUser = session.user;
                let query = supabaseClient
                    .from('coach_meal_plans')
                    .select('*')
                    .eq('id', planId);

                if (isClientView) {
                    // For client view, verify the client owns this plan
                    const { data: clientData, error: clientError } = await supabaseClient
                        .from('clients')
                        .select('id')
                        .eq('user_id', currentUser.id)
                        .single();

                    if (clientError || !clientData) {
                        alert('Client account not found. Please contact your coach.');
                        window.location.href = 'client-login.html';
                        return;
                    }

                    // Store client ID for saving modifications later
                    currentClientId = clientData.id;

                    // Load favorites for the client
                    await loadFavorites(clientData.id);

                    query = query.eq('client_id', clientData.id);
                } else {
                    // For coach view, verify the coach owns this plan
                    query = query.eq('coach_id', currentUser.id);
                }

                const { data, error } = await query.single();

                if (error) {
                    console.error('Supabase error:', error);
                    throw new Error('Failed to load plan');
                }

                if (!data) {
                    throw new Error('Plan not found');
                }

                console.log('Loaded plan:', data);
                currentPlanId = planId;

                // For client view: Use client_modified_data if it exists (client's personalized version)
                // Otherwise use plan_data (coach's original)
                let planData;
                console.log('üîç Plan data check:', {
                    isClientView: isClientView,
                    hasClientModifiedData: !!data.client_modified_data,
                    clientModifiedDataType: typeof data.client_modified_data
                });
                if (isClientView && data.client_modified_data) {
                    console.log('üìù Loading CLIENT MODIFIED version of plan');
                    planData = data.client_modified_data;
                    isClientModified = true;
                } else {
                    console.log('üìã Loading ORIGINAL coach plan');
                    planData = data.plan_data;
                    isClientModified = false;
                }

                // FIXED: Store multi-day structure instead of flattening
                if (planData.currentPlan && Array.isArray(planData.currentPlan)) {
                    // Multi-day plan structure - keep it organized by day
                    // Get nutrition from top-level OR from first day's targets
                    const dayTargets = planData.currentPlan[0]?.targets || {};
                    const nutrition = {
                        calories: planData.calories || dayTargets.calories || 0,
                        protein: planData.protein || dayTargets.protein || 0,
                        carbs: planData.carbs || dayTargets.carbs || 0,
                        fat: planData.fat || dayTargets.fat || 0
                    };
                    console.log('üìä Extracted nutrition for Daily Targets:', nutrition);

                    currentPlan = {
                        planId: data.id, // Store the coach plan ID for linking shared plans
                        clientName: planData.clientName || data.client_name,
                        preferences: planData.preferences || {},
                        multiDay: true,
                        days: planData.currentPlan, // Store all days with structure
                        nutrition: nutrition,
                        coachNotes: data.coach_notes || null
                    };
                } else {
                    // Fallback for old single-day format
                    currentPlan = {
                        planId: data.id, // Store the coach plan ID for linking shared plans
                        clientName: planData.clientName || data.client_name,
                        preferences: planData.preferences || {},
                        meals: planData.meals || [],
                        nutrition: planData.nutrition || {},
                        coachNotes: data.coach_notes || null
                    };
                }

                console.log('Transformed plan:', currentPlan);

                // Show coach-only buttons (only for coach view)
                if (!isClientView) {
                    document.getElementById('sharePlanBtn').style.display = 'inline-block';
                    document.getElementById('generateNewBtn').style.display = 'inline-block';
                }

                displayMealPlan();

                // Show modified indicator and reset button if client has modified the plan
                if (isClientModified) {
                    updateModifiedIndicator();
                    document.getElementById('resetToOriginalBtn').style.display = 'inline-block';
                }

                // Update header with client name
                const clientName = currentPlan.clientName || 'Client';
                const mealCount = currentPlan.meals ? currentPlan.meals.length : 0;
                const planText = mealCount > 1 ? 'Meal Plans' : 'Meal Plan';
                if (isClientView) {
                    document.getElementById('planHeader').textContent = `Your ${planText}`;
                } else {
                    document.getElementById('planHeader').textContent = `${clientName}'s ${planText}`;
                }

                // Set up real-time subscription for automatic updates
                setupRealtimeSubscription(planId, isClientView);

            } catch (error) {
                console.error('Error loading plan:', error);
                alert('Failed to load plan. Please try again.');
                const redirectUrl = isClientView ? 'client-dashboard.html' : 'dashboard.html';
                window.location.href = redirectUrl;
            }
        }

        function setupRealtimeSubscription(planId, isClientView) {
            // Clean up existing subscription if any
            if (realtimeChannel) {
                supabaseClient.removeChannel(realtimeChannel);
            }

            // Subscribe to changes for this specific plan
            realtimeChannel = supabaseClient
                .channel(`plan_${planId}`)
                .on(
                    'postgres_changes',
                    {
                        event: '*', // Listen to all events (INSERT, UPDATE, DELETE)
                        schema: 'public',
                        table: 'coach_meal_plans',
                        filter: `id=eq.${planId}`
                    },
                    (payload) => {
                        console.log('Real-time update received:', payload);
                        handlePlanUpdate(payload, isClientView);
                    }
                )
                .subscribe((status) => {
                    console.log('Realtime subscription status:', status);
                });
        }

        async function handlePlanUpdate(payload, isClientView) {
            const { eventType, new: newRecord } = payload;

            if (eventType === 'DELETE') {
                // Plan was deleted by coach
                console.log('Plan deleted');
                alert('This meal plan has been removed by your coach.');
                const redirectUrl = isClientView ? 'client-dashboard.html' : 'dashboard.html';
                window.location.href = redirectUrl;
            } else if (eventType === 'UPDATE') {
                // Plan was updated - reload and display
                console.log('Plan updated:', newRecord);

                const planData = newRecord.plan_data;

                // Update the currentPlan with new data
                if (planData.currentPlan && Array.isArray(planData.currentPlan)) {
                    // Get nutrition from top-level OR from first day's targets
                    const dayTargets = planData.currentPlan[0]?.targets || {};
                    const nutrition = {
                        calories: planData.calories || dayTargets.calories || 0,
                        protein: planData.protein || dayTargets.protein || 0,
                        carbs: planData.carbs || dayTargets.carbs || 0,
                        fat: planData.fat || dayTargets.fat || 0
                    };
                    currentPlan = {
                        planId: newRecord.id,
                        clientName: planData.clientName || newRecord.client_name,
                        preferences: planData.preferences || {},
                        multiDay: true,
                        days: planData.currentPlan,
                        nutrition: nutrition
                    };
                } else {
                    currentPlan = {
                        planId: newRecord.id,
                        clientName: planData.clientName || newRecord.client_name,
                        preferences: planData.preferences || {},
                        meals: planData.meals || [],
                        nutrition: planData.nutrition || {}
                    };
                }

                // Refresh the display with updated data
                displayMealPlan();

                console.log('Plan display refreshed with updated data');
            }
        }

        // Clean up subscription when page unloads
        window.addEventListener('beforeunload', function() {
            if (realtimeChannel) {
                supabaseClient.removeChannel(realtimeChannel);
            }
        });

        // Save current plan back to database if viewing from database
        async function savePlanToDatabase() {
            if (!currentPlanId) {
                console.log('‚è≠Ô∏è Skipping database save - no planId (viewing from localStorage)');
                return;
            }

            try {
                // Prepare the plan data in the format the database expects
                const planData = {
                    clientName: currentPlan.clientName,
                    preferences: currentPlan.preferences || {},
                    nutrition: currentPlan.nutrition
                };

                // Add the plan structure based on type
                if (currentPlan.multiDay && currentPlan.days) {
                    planData.currentPlan = currentPlan.days;
                    planData.calories = currentPlan.nutrition.calories;
                    planData.protein = currentPlan.nutrition.protein;
                    planData.carbs = currentPlan.nutrition.carbs;
                    planData.fat = currentPlan.nutrition.fat;
                } else if (currentPlan.meals) {
                    planData.meals = currentPlan.meals;
                }

                // CLIENT VIEW: Save to client_modified_data (preserves coach's original)
                if (isClientView && currentClientId) {
                    console.log('üíæ Saving CLIENT modifications to database...', currentPlanId);

                    const response = await fetch(SAVE_CLIENT_MODIFICATION_ENDPOINT, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            planId: currentPlanId,
                            clientId: currentClientId,
                            modifiedPlanData: planData
                        })
                    });

                    const result = await response.json();

                    if (!response.ok) {
                        console.error('‚ùå Client modification save error:', result);
                        throw new Error(result.error || 'Failed to save modifications');
                    }

                    // Mark as modified
                    isClientModified = true;
                    console.log('‚úÖ Client modifications saved to database');

                    // Update UI to show modified indicator and reset button
                    updateModifiedIndicator();
                    document.getElementById('resetToOriginalBtn').style.display = 'inline-block';
                    return;
                }

                // COACH VIEW: Save directly to plan_data
                console.log('üíæ Saving plan changes to database...', currentPlanId);

                const { error } = await supabaseClient
                    .from('coach_meal_plans')
                    .update({ plan_data: planData })
                    .eq('id', currentPlanId);

                if (error) {
                    console.error('‚ùå Database save error:', error);
                    throw error;
                }

                console.log('‚úÖ Plan saved to database successfully');
            } catch (error) {
                console.error('‚ùå Failed to save plan to database:', error);
                alert('Warning: Changes saved locally but failed to sync to database.');
            }
        }

        // Update UI to show that client has modified the plan
        function updateModifiedIndicator() {
            const header = document.getElementById('planHeader');
            if (header && isClientModified && !header.innerHTML.includes('modified-badge')) {
                header.innerHTML += ' <span class="modified-badge">Modified</span>';
            }
        }

        // Reset to coach's original plan (remove client modifications)
        async function resetToOriginal() {
            if (!currentPlanId || !currentClientId) {
                alert('Cannot reset: Plan information not available');
                return;
            }

            if (!confirm('Are you sure you want to reset to the original plan from your coach? All your modifications will be lost.')) {
                return;
            }

            try {
                console.log('üîÑ Resetting to original plan...', { planId: currentPlanId, clientId: currentClientId });

                // Use backend function to reset (bypasses RLS)
                const response = await fetch(RESET_CLIENT_MODIFICATION_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        planId: currentPlanId,
                        clientId: currentClientId
                    })
                });

                const result = await response.json();

                if (!response.ok) {
                    console.error('‚ùå Reset error:', result);
                    throw new Error(result.error || 'Failed to reset plan');
                }

                console.log('‚úÖ Plan reset to original:', result);

                // Verify the reset worked by checking returned data
                if (result.plan) {
                    console.log('üìã Returned plan client_modified_data:', result.plan.client_modified_data);
                    if (result.plan.client_modified_data !== null) {
                        console.error('‚ö†Ô∏è WARNING: client_modified_data was not cleared!');
                    }
                }

                if (result.alreadyOriginal) {
                    alert('Plan is already at the original version.');
                    return;
                }

                alert('Plan has been reset to the original version from your coach.');

                // Force a hard reload with cache busting to ensure fresh data
                const url = new URL(window.location.href);
                url.searchParams.set('_reset', Date.now());
                window.location.href = url.toString();

            } catch (error) {
                console.error('Error resetting plan:', error);
                alert('Failed to reset plan. Please try again.');
            }
        }

        // Generate and save share link
        async function generateShareLink() {
            if (!currentPlan) {
                alert('No meal plan to share');
                return;
            }

            // Show modal with loading state
            const modal = document.getElementById('shareModal');
            const linkText = document.getElementById('shareLinkText');
            linkText.textContent = 'Generating share link...';
            modal.classList.add('show');

            try {
                console.log('üì§ Saving plan for sharing...');

                // Prepare request body
                const requestBody = { planData: currentPlan };

                // If this plan was loaded from database (has planId), include it
                // This links the shared plan to the coach plan for cascade deletion
                if (currentPlan.planId) {
                    requestBody.coachPlanId = currentPlan.planId;
                    console.log('Linking shared plan to coach plan:', currentPlan.planId);
                }

                const response = await fetch(SAVE_PLAN_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    throw new Error('Failed to generate share link');
                }

                const data = await response.json();
                currentShareUrl = data.shareUrl;

                console.log('‚úÖ Share link generated:', currentShareUrl);

                linkText.textContent = currentShareUrl;

            } catch (error) {
                console.error('‚ùå Error generating share link:', error);
                linkText.textContent = 'Failed to generate link. Please try again.';
                alert('Failed to generate share link. Please try again.');
            }
        }

        // Copy share link to clipboard
        async function copyShareLink() {
            if (!currentShareUrl) {
                alert('No share link available');
                return;
            }

            try {
                await navigator.clipboard.writeText(currentShareUrl);

                // Update button text temporarily
                const copyBtn = event.target;
                const originalText = copyBtn.textContent;
                copyBtn.textContent = '‚úÖ Copied!';
                copyBtn.style.background = '#28a745';

                setTimeout(() => {
                    copyBtn.textContent = originalText;
                    copyBtn.style.background = '';
                }, 2000);

            } catch (error) {
                console.error('‚ùå Copy error:', error);
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = currentShareUrl;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                alert('Link copied to clipboard!');
            }
        }

        // Close share modal
        function closeShareModal() {
            const modal = document.getElementById('shareModal');
            modal.classList.remove('show');
        }

        // ===== CUSTOM MEAL MODAL FUNCTIONS =====

        function openCustomMealModal(index, dayIndex = null, mealIndex = null) {
            // Store the current meal context
            currentCustomMealIndex = index;
            currentCustomMealDayIndex = dayIndex;
            currentCustomMealMealIndex = mealIndex;

            // Reset manual panel form
            document.getElementById('customMealName').value = '';
            document.getElementById('customMealCalories').value = '';
            document.getElementById('customMealProtein').value = '';
            document.getElementById('customMealCarbs').value = '';
            document.getElementById('customMealFat').value = '';
            document.getElementById('customMealInstructions').value = '';

            // Reset USDA search/calculate panel
            document.getElementById('usdaSearchInput').value = '';
            document.getElementById('usdaSearchResults').classList.remove('active');
            document.getElementById('usdaSearchResults').innerHTML = '';
            document.getElementById('calculatedMealName').value = '';
            selectedIngredients = [];
            renderSelectedIngredients();
            updateCalculatedTotals();

            // Reset to calculate tab
            switchCustomMealTab('calculate');

            // Show modal
            document.getElementById('customMealModal').classList.add('show');
        }

        function closeCustomMealModal() {
            document.getElementById('customMealModal').classList.remove('show');
            currentCustomMealIndex = null;
            currentCustomMealDayIndex = null;
            currentCustomMealMealIndex = null;
        }

        function switchCustomMealTab(tab) {
            // Update tab styles
            const tabs = document.querySelectorAll('.custom-meal-tab');
            tabs.forEach(t => t.classList.remove('active'));

            // Update panel visibility
            document.getElementById('calculatePanel').classList.remove('active');
            document.getElementById('manualPanel').classList.remove('active');

            if (tab === 'calculate') {
                tabs[0].classList.add('active');
                document.getElementById('calculatePanel').classList.add('active');
            } else {
                tabs[1].classList.add('active');
                document.getElementById('manualPanel').classList.add('active');
            }
        }

        // ===== USDA SEARCH FUNCTIONS =====

        function handleUsdaSearch(query) {
            // Clear previous timeout
            if (usdaSearchTimeout) {
                clearTimeout(usdaSearchTimeout);
            }

            const resultsDiv = document.getElementById('usdaSearchResults');

            // If query is too short, hide results
            if (query.trim().length < 2) {
                resultsDiv.classList.remove('active');
                resultsDiv.innerHTML = '';
                usdaSearchResults = [];
                return;
            }

            // Show loading state
            resultsDiv.classList.add('active');
            resultsDiv.innerHTML = '<div class="usda-search-loading">Searching USDA database...</div>';

            // Debounce the search (wait 300ms after user stops typing)
            usdaSearchTimeout = setTimeout(async () => {
                try {
                    const response = await fetch(`${USDA_SEARCH_ENDPOINT}?query=${encodeURIComponent(query)}`);
                    const data = await response.json();

                    if (!response.ok) {
                        throw new Error(data.error || 'Search failed');
                    }

                    if (data.foods && data.foods.length > 0) {
                        // Store results for safe onclick handling
                        usdaSearchResults = data.foods;

                        resultsDiv.innerHTML = data.foods.map((food, index) => `
                            <div class="usda-search-item" onclick="selectUsdaFood(${index})">
                                <div class="usda-food-name">${escapeHtml(food.name)}</div>
                                <div class="usda-food-macros">
                                    Per 100g: ${food.caloriesPer100g} cal | ${food.proteinPer100g}g protein | ${food.carbsPer100g}g carbs | ${food.fatPer100g}g fat
                                </div>
                            </div>
                        `).join('');
                    } else {
                        usdaSearchResults = [];
                        resultsDiv.innerHTML = '<div class="usda-search-empty">No foods found. Try a different search term.</div>';
                    }
                } catch (error) {
                    console.error('USDA search error:', error);
                    usdaSearchResults = [];
                    resultsDiv.innerHTML = '<div class="usda-search-empty">Search failed. Please try again.</div>';
                }
            }, 300);
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function selectUsdaFood(index) {
            const food = usdaSearchResults[index];
            if (!food) {
                console.error('Food not found at index:', index);
                return;
            }
            addIngredientFromUsda(food);
        }

        function addIngredientFromUsda(food) {
            console.log('Adding ingredient:', food); // Debug log

            // Add ingredient with default 100g quantity
            selectedIngredients.push({
                fdcId: food.fdcId,
                name: food.name,
                quantity: 100,
                caloriesPer100g: food.caloriesPer100g,
                proteinPer100g: food.proteinPer100g,
                carbsPer100g: food.carbsPer100g,
                fatPer100g: food.fatPer100g
            });

            // Clear search
            document.getElementById('usdaSearchInput').value = '';
            document.getElementById('usdaSearchResults').classList.remove('active');
            document.getElementById('usdaSearchResults').innerHTML = '';

            // Update UI
            renderSelectedIngredients();
            updateCalculatedTotals();
        }

        function removeIngredient(index) {
            selectedIngredients.splice(index, 1);
            renderSelectedIngredients();
            updateCalculatedTotals();
        }

        function updateIngredientQuantity(index, quantity) {
            const qty = parseFloat(quantity) || 0;
            selectedIngredients[index].quantity = qty;
            updateCalculatedTotals();
        }

        function renderSelectedIngredients() {
            const listDiv = document.getElementById('ingredientsList');
            const countSpan = document.getElementById('ingredientCount');

            countSpan.textContent = `(${selectedIngredients.length})`;

            if (selectedIngredients.length === 0) {
                listDiv.innerHTML = '<div class="no-ingredients">No ingredients added yet</div>';
                return;
            }

            listDiv.innerHTML = selectedIngredients.map((ing, index) => `
                <div class="ingredient-item">
                    <span class="ingredient-name" title="${escapeHtml(ing.name)}">${truncateName(ing.name, 25)}</span>
                    <input type="number" class="ingredient-qty" value="${ing.quantity}" min="1"
                           onchange="updateIngredientQuantity(${index}, this.value)"
                           onclick="event.stopPropagation()">
                    <span class="ingredient-unit">g</span>
                    <button class="ingredient-remove" onclick="removeIngredient(${index})" title="Remove">√ó</button>
                </div>
            `).join('');
        }

        function truncateName(name, maxLength) {
            if (name.length <= maxLength) return name;
            return name.substring(0, maxLength) + '...';
        }

        function updateCalculatedTotals() {
            const totalsDiv = document.getElementById('calculatedTotals');
            const createBtn = document.getElementById('createCalculatedMealBtn');

            if (selectedIngredients.length === 0) {
                totalsDiv.style.display = 'none';
                createBtn.disabled = true;
                return;
            }

            // Calculate totals based on quantities
            let totalCal = 0, totalProtein = 0, totalCarbs = 0, totalFat = 0;

            selectedIngredients.forEach(ing => {
                const multiplier = ing.quantity / 100;
                totalCal += ing.caloriesPer100g * multiplier;
                totalProtein += ing.proteinPer100g * multiplier;
                totalCarbs += ing.carbsPer100g * multiplier;
                totalFat += ing.fatPer100g * multiplier;
            });

            // Update display
            document.getElementById('totalCalories').textContent = Math.round(totalCal);
            document.getElementById('totalProtein').textContent = Math.round(totalProtein) + 'g';
            document.getElementById('totalCarbs').textContent = Math.round(totalCarbs) + 'g';
            document.getElementById('totalFat').textContent = Math.round(totalFat) + 'g';

            totalsDiv.style.display = 'block';
            createBtn.disabled = false;
        }

        async function submitManualMeal() {
            const mealName = document.getElementById('customMealName').value.trim();
            const calories = parseInt(document.getElementById('customMealCalories').value) || 0;
            const protein = parseInt(document.getElementById('customMealProtein').value) || 0;
            const carbs = parseInt(document.getElementById('customMealCarbs').value) || 0;
            const fat = parseInt(document.getElementById('customMealFat').value) || 0;
            const instructions = document.getElementById('customMealInstructions').value.trim() || 'Prepare as desired.';

            if (!mealName) {
                alert('Please enter a meal name');
                return;
            }

            if (calories === 0 && protein === 0 && carbs === 0 && fat === 0) {
                alert('Please enter at least some macro values');
                return;
            }

            // Get the current meal for type reference
            let meal;
            if (currentCustomMealDayIndex !== null && currentCustomMealMealIndex !== null) {
                meal = currentPlan.days[currentCustomMealDayIndex].plan[currentCustomMealMealIndex];
            } else {
                meal = currentPlan.meals[currentCustomMealIndex];
            }

            // Save current meal state for undo
            const stateKey = currentCustomMealDayIndex !== null ? `${currentCustomMealDayIndex}-${currentCustomMealMealIndex}` : `${currentCustomMealIndex}`;
            previousMealStates[stateKey] = JSON.parse(JSON.stringify(meal));
            console.log(`üíæ Saved previous state for manual custom meal:`, previousMealStates[stateKey]);

            // Create the custom meal object
            const customMealData = {
                type: meal.type || 'meal',
                name: mealName,
                ingredients: [`${mealName} (manual entry)`],
                calories: calories,
                protein: protein,
                carbs: carbs,
                fat: fat,
                instructions: instructions
            };

            // Save the custom meal
            if (currentCustomMealDayIndex !== null && currentCustomMealMealIndex !== null) {
                currentPlan.days[currentCustomMealDayIndex].plan[currentCustomMealMealIndex] = customMealData;
            } else {
                currentPlan.meals[currentCustomMealIndex] = customMealData;
            }
            localStorage.setItem('currentMealPlan', JSON.stringify(currentPlan));

            // Save to database
            await savePlanToDatabase();

            // Update day totals if multi-day
            if (currentCustomMealDayIndex !== null) {
                updateDayTotals(currentCustomMealDayIndex);
            }

            // Close modal and refresh display
            closeCustomMealModal();
            displayMealPlan();

            showNotification(`Custom meal created: ${calories} cal, ${protein}g protein`, 'success');
        }

        async function submitCalculatedMeal() {
            // Check if we have selected ingredients
            if (selectedIngredients.length === 0) {
                alert('Please search and add some ingredients first');
                return;
            }

            const index = currentCustomMealIndex;
            const dayIndex = currentCustomMealDayIndex;
            const mealIndex = currentCustomMealMealIndex;

            // Get the current meal for reference
            let meal;
            if (dayIndex !== null && mealIndex !== null) {
                meal = currentPlan.days[dayIndex].plan[mealIndex];
            } else {
                meal = currentPlan.meals[index];
            }

            // Save current meal state for undo
            const stateKey = dayIndex !== null ? `${dayIndex}-${mealIndex}` : `${index}`;
            previousMealStates[stateKey] = JSON.parse(JSON.stringify(meal));
            console.log(`üíæ Saved previous state for USDA custom meal:`, previousMealStates[stateKey]);

            // Calculate totals from selected ingredients
            let totalCal = 0, totalProtein = 0, totalCarbs = 0, totalFat = 0;
            const ingredients = [];

            selectedIngredients.forEach(ing => {
                const multiplier = ing.quantity / 100;
                totalCal += ing.caloriesPer100g * multiplier;
                totalProtein += ing.proteinPer100g * multiplier;
                totalCarbs += ing.carbsPer100g * multiplier;
                totalFat += ing.fatPer100g * multiplier;

                // Format ingredient name with quantity
                const shortName = ing.name.length > 40 ? ing.name.substring(0, 40) + '...' : ing.name;
                ingredients.push(`${shortName} (${ing.quantity}g)`);
            });

            // Generate meal name
            let mealName = document.getElementById('calculatedMealName').value.trim();
            if (!mealName) {
                // Auto-generate name from first ingredient(s)
                if (selectedIngredients.length === 1) {
                    const firstName = selectedIngredients[0].name.split(',')[0];
                    mealName = firstName.length > 30 ? firstName.substring(0, 30) : firstName;
                } else {
                    const firstName = selectedIngredients[0].name.split(',')[0];
                    const shortFirst = firstName.length > 20 ? firstName.substring(0, 20) : firstName;
                    mealName = `${shortFirst} + ${selectedIngredients.length - 1} more`;
                }
            }

            // Create the custom meal object
            const customMealData = {
                type: meal.type || 'meal',
                name: mealName,
                ingredients: ingredients,
                calories: Math.round(totalCal),
                protein: Math.round(totalProtein),
                carbs: Math.round(totalCarbs),
                fat: Math.round(totalFat),
                instructions: 'Prepare as desired.',
                source: 'USDA FoodData Central'
            };

            console.log('‚úÖ USDA Custom meal created:', customMealData);

            // Save the custom meal
            if (dayIndex !== null && mealIndex !== null) {
                currentPlan.days[dayIndex].plan[mealIndex] = customMealData;
            } else {
                currentPlan.meals[index] = customMealData;
            }
            localStorage.setItem('currentMealPlan', JSON.stringify(currentPlan));

            // Close modal
            closeCustomMealModal();

            // Save to database
            await savePlanToDatabase();

            // Update day totals if multi-day
            if (dayIndex !== null) {
                updateDayTotals(dayIndex);
            }

            displayMealPlan();

            showNotification(`Custom meal created: ${customMealData.calories} cal, ${customMealData.protein}g protein`, 'success');
        }

        function displayMealPlan() {
            console.log('üìã displayMealPlan called, currentPlan:', currentPlan);

            // FIXED: Handle both multi-day and single-day plans
            let nutrition = currentPlan.nutrition || {};

            // Check if nutrition values are missing or zero
            if (!nutrition.calories && !nutrition.protein && !nutrition.carbs && !nutrition.fat) {
                console.warn('‚ö†Ô∏è Nutrition object empty or all zeros, calculating from plan...');

                // Calculate based on plan type
                if (currentPlan.multiDay && currentPlan.days && currentPlan.days.length > 0) {
                    // For multi-day, get from first day's targets
                    if (currentPlan.days[0].targets) {
                        nutrition = { ...currentPlan.days[0].targets };
                        console.log('‚úÖ Got nutrition from day 1 targets:', nutrition);
                    }
                } else if (currentPlan.meals && currentPlan.meals.length > 0) {
                    // For single-day, calculate totals from meals
                    nutrition = { calories: 0, protein: 0, carbs: 0, fat: 0 };
                    currentPlan.meals.forEach(meal => {
                        nutrition.calories += parseInt(meal.calories) || 0;
                        nutrition.protein += parseInt(meal.protein) || 0;
                        nutrition.carbs += parseInt(meal.carbs) || 0;
                        nutrition.fat += parseInt(meal.fat) || 0;
                    });
                    console.log('‚úÖ Calculated nutrition from meals:', nutrition);
                }

                currentPlan.nutrition = nutrition;
                localStorage.setItem('currentMealPlan', JSON.stringify(currentPlan));
            }

            console.log('üìä Displaying Daily Targets:', nutrition);

            // Display DAILY nutrition totals
            document.getElementById('totalCalories').textContent = nutrition.calories || 0;
            document.getElementById('totalProtein').textContent = (nutrition.protein || 0) + 'g';
            document.getElementById('totalCarbs').textContent = (nutrition.carbs || 0) + 'g';
            document.getElementById('totalFat').textContent = (nutrition.fat || 0) + 'g';

            // Display coach notes if present
            const existingNotesSection = document.getElementById('coachNotesSection');
            if (existingNotesSection) {
                existingNotesSection.remove();
            }

            if (currentPlan.coachNotes) {
                const notesSection = document.createElement('div');
                notesSection.id = 'coachNotesSection';
                notesSection.style.cssText = 'background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); padding: 20px; border-radius: 12px; margin-bottom: 20px; border: 1px solid #7dd3fc;';
                notesSection.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
                        <span style="font-size: 20px;">üìù</span>
                        <h3 style="margin: 0; color: #0369a1; font-size: 16px; font-weight: 600;">Message from Your Coach</h3>
                    </div>
                    <p style="margin: 0; color: #334155; font-size: 15px; line-height: 1.6; white-space: pre-wrap;">${linkifyText(currentPlan.coachNotes)}</p>
                `;
                document.getElementById('mealsContainer').parentNode.insertBefore(notesSection, document.getElementById('mealsContainer'));
            }

            // Display meals - FIXED for multi-day plans
            const container = document.getElementById('mealsContainer');
            container.innerHTML = '';

            // Helper function to get color class based on variance
            const getVarianceColor = (variancePercent) => {
                const abs = Math.abs(variancePercent);
                if (abs <= 10) return '#16a34a'; // green - within ¬±10%
                if (abs <= 20) return '#ca8a04'; // yellow - within ¬±20%
                return '#dc2626'; // red - over ¬±20%
            };

            // Helper function to format variance display
            const formatVariance = (actual, target, variancePercent) => {
                const diff = actual - target;
                const sign = diff >= 0 ? '+' : '';
                return `${sign}${diff} (${sign}${variancePercent.toFixed(1)}%)`;
            };

            if (currentPlan.multiDay && currentPlan.days) {
                // Multi-day plan: show days with separators
                currentPlan.days.forEach((dayData, dayIndex) => {
                    // Calculate per-day actual totals
                    let dayTotals = { calories: 0, protein: 0, carbs: 0, fat: 0 };
                    if (dayData.plan && Array.isArray(dayData.plan)) {
                        dayData.plan.forEach(meal => {
                            dayTotals.calories += parseInt(meal.calories) || 0;
                            dayTotals.protein += parseInt(meal.protein) || 0;
                            dayTotals.carbs += parseInt(meal.carbs) || 0;
                            dayTotals.fat += parseInt(meal.fat) || 0;
                        });
                    }

                    // Get targets (use day targets if available, otherwise use plan nutrition)
                    const targets = dayData.targets || nutrition;

                    // Calculate per-day variance
                    const dayVariance = {
                        calories: targets.calories ? ((dayTotals.calories - targets.calories) / targets.calories * 100) : 0,
                        protein: targets.protein ? ((dayTotals.protein - targets.protein) / targets.protein * 100) : 0,
                        carbs: targets.carbs ? ((dayTotals.carbs - targets.carbs) / targets.carbs * 100) : 0,
                        fat: targets.fat ? ((dayTotals.fat - targets.fat) / targets.fat * 100) : 0
                    };

                    // Day header with regenerate button
                    const dayHeader = document.createElement('div');
                    dayHeader.className = 'day-header';
                    dayHeader.style.cssText = 'background: linear-gradient(135deg, #0d9488 0%, #0284c7 100%); color: white; padding: 15px 20px; border-radius: 12px; margin: 20px 0 15px 0; font-weight: 700; font-size: 1.3em; display: flex; justify-content: space-between; align-items: center;';

                    // Check if client view - hide regenerate button for clients
                    const urlParams = new URLSearchParams(window.location.search);
                    const isClientView = urlParams.get('clientView') === 'true';

                    dayHeader.innerHTML = `
                        <span>Day ${dayData.day}</span>
                        ${!isClientView ? `<button onclick="regenerateDay(${dayIndex})" class="btn" style="background: rgba(255,255,255,0.2); color: white; border: 1px solid rgba(255,255,255,0.3); padding: 8px 16px; font-size: 0.8em;">üîÑ Regenerate Day</button>` : ''}
                    `;
                    container.appendChild(dayHeader);

                    // Day totals section
                    const dayTotalsDiv = document.createElement('div');
                    dayTotalsDiv.id = `day-totals-${dayIndex}`;
                    dayTotalsDiv.style.cssText = 'background: #f8f9ff; padding: 15px; border-radius: 10px; margin-bottom: 15px; border: 1px solid #e0e7ff;';
                    dayTotalsDiv.innerHTML = `
                        <p style="font-size: 0.85em; font-weight: 600; color: #666; margin-bottom: 10px;">Day ${dayData.day} Totals:</p>
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; text-align: center;">
                            <div>
                                <p style="font-size: 0.75em; color: #888;">Calories</p>
                                <span style="font-weight: 700; color: ${getVarianceColor(dayVariance.calories)}">${dayTotals.calories}</span>
                                <p style="font-size: 0.7em; color: ${getVarianceColor(dayVariance.calories)}">${formatVariance(dayTotals.calories, targets.calories, dayVariance.calories)}</p>
                            </div>
                            <div>
                                <p style="font-size: 0.75em; color: #888;">Protein</p>
                                <span style="font-weight: 700; color: ${getVarianceColor(dayVariance.protein)}">${dayTotals.protein}g</span>
                                <p style="font-size: 0.7em; color: ${getVarianceColor(dayVariance.protein)}">${formatVariance(dayTotals.protein, targets.protein, dayVariance.protein)}</p>
                            </div>
                            <div>
                                <p style="font-size: 0.75em; color: #888;">Carbs</p>
                                <span style="font-weight: 700; color: ${getVarianceColor(dayVariance.carbs)}">${dayTotals.carbs}g</span>
                                <p style="font-size: 0.7em; color: ${getVarianceColor(dayVariance.carbs)}">${formatVariance(dayTotals.carbs, targets.carbs, dayVariance.carbs)}</p>
                            </div>
                            <div>
                                <p style="font-size: 0.75em; color: #888;">Fat</p>
                                <span style="font-weight: 700; color: ${getVarianceColor(dayVariance.fat)}">${dayTotals.fat}g</span>
                                <p style="font-size: 0.7em; color: ${getVarianceColor(dayVariance.fat)}">${formatVariance(dayTotals.fat, targets.fat, dayVariance.fat)}</p>
                            </div>
                        </div>
                        <div style="margin-top: 8px; text-align: center; font-size: 0.7em; color: #888;">
                            <span style="color: #16a34a;">‚óè</span> Within ¬±10% |
                            <span style="color: #ca8a04;">‚óè</span> Within ¬±20% |
                            <span style="color: #dc2626;">‚óè</span> Over ¬±20%
                        </div>
                    `;
                    container.appendChild(dayTotalsDiv);

                    // Meals for this day
                    if (dayData.plan && Array.isArray(dayData.plan)) {
                        dayData.plan.forEach((meal, mealIndex) => {
                            const mealCard = createMealCard(meal, `${dayIndex}-${mealIndex}`, dayIndex, mealIndex);
                            container.appendChild(mealCard);
                        });
                    }
                });
            } else if (currentPlan.meals) {
                // Single-day plan: show meals directly
                currentPlan.meals.forEach((meal, index) => {
                    const mealCard = createMealCard(meal, index);
                    container.appendChild(mealCard);
                });
            }
        }

        function createMealCard(meal, index, dayIndex = null, mealIndex = null) {
            const card = document.createElement('div');
            card.className = 'meal-card';
            card.id = `meal-${index}`;

            // For multi-day plans, pass both indices; for single-day, pass just the index
            const changeParam = dayIndex !== null ? `'${index}', ${dayIndex}, ${mealIndex}` : index;
            const reviseParam = dayIndex !== null ? `'${index}', ${dayIndex}, ${mealIndex}` : index;

            // Check if client view
            const urlParams = new URLSearchParams(window.location.search);
            const isClientView = urlParams.get('clientView') === 'true' || urlParams.get('share');

            // Check if meal is already favorited
            const isFavorited = clientFavorites.some(f => f.meal_name === meal.name);
            const favoriteClass = isFavorited ? 'active' : '';
            const favoriteIcon = isFavorited ? '‚ù§Ô∏è' : 'ü§ç';

            // Escape meal name for use in onclick
            const escapedMealName = meal.name.replace(/'/g, "\\'").replace(/"/g, '\\"');

            // Get existing note for this meal
            const mealNote = meal.coach_note || '';

            // Build notes section based on view type
            let notesSection = '';
            if (isClientView) {
                // Client view: show note if exists (read-only)
                if (mealNote) {
                    notesSection = `
                        <div class="meal-note-display" style="background: #fef3c7; border-left: 4px solid #f59e0b; padding: 12px 15px; margin-top: 15px; border-radius: 0 8px 8px 0;">
                            <div style="font-weight: 600; color: #92400e; font-size: 0.85em; margin-bottom: 6px;">üìù Coach Note:</div>
                            <div style="color: #78350f; font-size: 0.95em; line-height: 1.5; white-space: pre-wrap;">${linkifyText(mealNote)}</div>
                        </div>
                    `;
                }
            } else {
                // Coach view: show editable note field
                notesSection = `
                    <div class="meal-note-section" style="margin-top: 15px; background: #f0f9ff; padding: 12px; border-radius: 8px; border: 1px solid #bae6fd;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <span style="font-weight: 600; color: #0369a1; font-size: 0.85em;">üìù Note for Client:</span>
                            <button class="btn" onclick="saveMealNote('${index}', ${dayIndex}, ${mealIndex})" style="background: #0284c7; color: white; padding: 4px 12px; font-size: 0.8em; border-radius: 4px;">Save Note</button>
                        </div>
                        <textarea id="meal-note-${index}" style="width: 100%; min-height: 60px; padding: 8px; border: 1px solid #7dd3fc; border-radius: 6px; font-size: 0.9em; resize: vertical;" placeholder="Add a note for your client about this meal...">${mealNote}</textarea>
                    </div>
                `;
            }

            // Build action buttons - clients can also change/revise meals
            // Check if there's a previous state for undo
            const undoStateKey = dayIndex !== null ? `${dayIndex}-${mealIndex}` : `${index}`;
            const hasUndoState = previousMealStates[undoStateKey] !== undefined;
            const undoButton = hasUndoState
                ? `<button class="btn btn-undo" onclick="undoRevision(${changeParam})" title="Undo last revision">‚Ü©Ô∏è Undo</button>`
                : '';

            let actionButtons = `
                <button class="btn btn-favorite ${favoriteClass}" id="fav-${index}" onclick="toggleFavorite('${escapedMealName}', '${meal.type || ''}', ${meal.calories}, ${meal.protein}, ${meal.carbs}, ${meal.fat}, '${index}')" title="${isFavorited ? 'Remove from favorites' : 'Add to favorites'}">${favoriteIcon}</button>
                <button class="btn btn-change" onclick="changeMeal(${changeParam})">üîÑ Change</button>
                <button class="btn btn-revise" onclick="reviseMeal(${changeParam})">‚úèÔ∏è Revise</button>
                <button class="btn btn-custom" onclick="customMeal(${changeParam})" title="Create exact meal from scratch">üéØ Custom</button>
                ${undoButton}
            `;

            card.innerHTML = `
                <div class="meal-header">
                    <div class="meal-name">${meal.name}</div>
                    <div class="meal-actions">
                        ${actionButtons}
                    </div>
                </div>
                <div class="macro-grid">
                    <div class="macro-item">
                        <div class="macro-label">Calories</div>
                        <div class="macro-value">${meal.calories}</div>
                    </div>
                    <div class="macro-item">
                        <div class="macro-label">Protein</div>
                        <div class="macro-value">${meal.protein}g</div>
                    </div>
                    <div class="macro-item">
                        <div class="macro-label">Carbs</div>
                        <div class="macro-value">${meal.carbs}g</div>
                    </div>
                    <div class="macro-item">
                        <div class="macro-label">Fat</div>
                        <div class="macro-value">${meal.fat}g</div>
                    </div>
                </div>
                <div class="instructions">
                    <span class="instructions-label">üìù Instructions:</span>
                    ${meal.instructions}
                </div>
                ${notesSection}
            `;
            return card;
        }

        // Update day totals after meal changes (undo, revise, change, custom)
        function updateDayTotals(dayIndex) {
            if (!currentPlan.multiDay || !currentPlan.days || !currentPlan.days[dayIndex]) {
                console.log('‚ö†Ô∏è updateDayTotals: Not a multi-day plan or invalid dayIndex');
                return;
            }

            const dayData = currentPlan.days[dayIndex];
            const dayTotalsDiv = document.getElementById(`day-totals-${dayIndex}`);

            if (!dayTotalsDiv) {
                console.log('‚ö†Ô∏è updateDayTotals: Could not find day-totals div for day', dayIndex);
                return;
            }

            // Recalculate totals from meals
            let dayTotals = { calories: 0, protein: 0, carbs: 0, fat: 0 };
            if (dayData.plan && Array.isArray(dayData.plan)) {
                dayData.plan.forEach(meal => {
                    dayTotals.calories += parseInt(meal.calories) || 0;
                    dayTotals.protein += parseInt(meal.protein) || 0;
                    dayTotals.carbs += parseInt(meal.carbs) || 0;
                    dayTotals.fat += parseInt(meal.fat) || 0;
                });
            }

            // Get targets (use day targets if available, otherwise use plan nutrition)
            const nutrition = currentPlan.nutrition || {};
            const targets = dayData.targets || nutrition;

            // Calculate variance
            const dayVariance = {
                calories: targets.calories ? ((dayTotals.calories - targets.calories) / targets.calories * 100) : 0,
                protein: targets.protein ? ((dayTotals.protein - targets.protein) / targets.protein * 100) : 0,
                carbs: targets.carbs ? ((dayTotals.carbs - targets.carbs) / targets.carbs * 100) : 0,
                fat: targets.fat ? ((dayTotals.fat - targets.fat) / targets.fat * 100) : 0
            };

            // Helper functions for display
            const getVarianceColor = (variancePercent) => {
                const abs = Math.abs(variancePercent);
                if (abs <= 10) return '#16a34a'; // green - within ¬±10%
                if (abs <= 20) return '#ca8a04'; // yellow - within ¬±20%
                return '#dc2626'; // red - over ¬±20%
            };

            const formatVariance = (actual, target, variancePercent) => {
                const diff = actual - target;
                const sign = diff >= 0 ? '+' : '';
                return `${sign}${diff} (${sign}${variancePercent.toFixed(1)}%)`;
            };

            // Update the day totals div
            dayTotalsDiv.innerHTML = `
                <p style="font-size: 0.85em; font-weight: 600; color: #666; margin-bottom: 10px;">Day ${dayData.day} Totals:</p>
                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; text-align: center;">
                    <div>
                        <p style="font-size: 0.75em; color: #888;">Calories</p>
                        <span style="font-weight: 700; color: ${getVarianceColor(dayVariance.calories)}">${dayTotals.calories}</span>
                        <p style="font-size: 0.7em; color: ${getVarianceColor(dayVariance.calories)}">${formatVariance(dayTotals.calories, targets.calories, dayVariance.calories)}</p>
                    </div>
                    <div>
                        <p style="font-size: 0.75em; color: #888;">Protein</p>
                        <span style="font-weight: 700; color: ${getVarianceColor(dayVariance.protein)}">${dayTotals.protein}g</span>
                        <p style="font-size: 0.7em; color: ${getVarianceColor(dayVariance.protein)}">${formatVariance(dayTotals.protein, targets.protein, dayVariance.protein)}</p>
                    </div>
                    <div>
                        <p style="font-size: 0.75em; color: #888;">Carbs</p>
                        <span style="font-weight: 700; color: ${getVarianceColor(dayVariance.carbs)}">${dayTotals.carbs}g</span>
                        <p style="font-size: 0.7em; color: ${getVarianceColor(dayVariance.carbs)}">${formatVariance(dayTotals.carbs, targets.carbs, dayVariance.carbs)}</p>
                    </div>
                    <div>
                        <p style="font-size: 0.75em; color: #888;">Fat</p>
                        <span style="font-weight: 700; color: ${getVarianceColor(dayVariance.fat)}">${dayTotals.fat}g</span>
                        <p style="font-size: 0.7em; color: ${getVarianceColor(dayVariance.fat)}">${formatVariance(dayTotals.fat, targets.fat, dayVariance.fat)}</p>
                    </div>
                </div>
                <div style="margin-top: 8px; text-align: center; font-size: 0.7em; color: #888;">
                    <span style="color: #16a34a;">‚óè</span> Within ¬±10% |
                    <span style="color: #ca8a04;">‚óè</span> Within ¬±20% |
                    <span style="color: #dc2626;">‚óè</span> Over ¬±20%
                </div>
            `;

            console.log(`‚úÖ Updated day ${dayIndex} totals:`, dayTotals);
        }

        async function undoRevision(index, dayIndex = null, mealIndex = null) {
            // Get the state key
            const stateKey = dayIndex !== null ? `${dayIndex}-${mealIndex}` : `${index}`;
            const previousState = previousMealStates[stateKey];

            if (!previousState) {
                alert('No previous state to undo');
                return;
            }

            console.log(`‚Ü©Ô∏è Undoing revision for meal ${stateKey}:`, previousState);

            // Restore the previous meal state
            if (dayIndex !== null && mealIndex !== null) {
                // Multi-day plan
                currentPlan.days[dayIndex].plan[mealIndex] = JSON.parse(JSON.stringify(previousState));
            } else {
                // Single-day plan
                currentPlan.meals[index] = JSON.parse(JSON.stringify(previousState));
            }

            // Remove the undo state (can only undo once)
            delete previousMealStates[stateKey];

            // Re-render the meal card
            const mealCard = document.getElementById(`meal-${index}`);
            const newCard = createMealCard(previousState, index, dayIndex, mealIndex);
            mealCard.innerHTML = newCard.innerHTML;

            // Recalculate day totals if multi-day plan
            if (dayIndex !== null) {
                updateDayTotals(dayIndex);
            }

            // Save to database if client view
            if (isClientView && currentPlanId) {
                try {
                    await saveClientModification();
                    console.log('‚úÖ Undo saved to database');
                } catch (err) {
                    console.error('Failed to save undo:', err);
                }
            }

            showNotification('Revision undone successfully!', 'success');
        }

        async function saveMealNote(index, dayIndex = null, mealIndex = null) {
            const textarea = document.getElementById(`meal-note-${index}`);
            const note = textarea.value.trim();
            const saveBtn = textarea.parentElement.querySelector('button');

            // Update the meal in currentPlan
            let meal;
            if (dayIndex !== null && mealIndex !== null) {
                // Multi-day plan
                meal = currentPlan.days[dayIndex].plan[mealIndex];
            } else if (currentPlan.meals) {
                // Single-day plan
                meal = currentPlan.meals[index];
            } else if (currentPlan.days) {
                // Fallback for days structure
                const parts = index.split('-');
                if (parts.length === 2) {
                    meal = currentPlan.days[parseInt(parts[0])].plan[parseInt(parts[1])];
                }
            }

            if (!meal) {
                alert('Error: Could not find meal to save note');
                return;
            }

            // Save the note to the meal
            meal.coach_note = note;

            // Show saving state
            const originalText = saveBtn.textContent;
            saveBtn.textContent = 'Saving...';
            saveBtn.disabled = true;

            try {
                // Get planId from URL
                const urlParams = new URLSearchParams(window.location.search);
                const planId = urlParams.get('planId');

                if (planId) {
                    // Save to database
                    const { error } = await supabaseClient
                        .from('coach_meal_plans')
                        .update({ plan_data: currentPlan })
                        .eq('id', planId);

                    if (error) throw error;
                }

                // Also update localStorage if available
                localStorage.setItem('currentMealPlan', JSON.stringify(currentPlan));

                saveBtn.textContent = 'Saved!';
                saveBtn.style.background = '#16a34a';

                setTimeout(() => {
                    saveBtn.textContent = originalText;
                    saveBtn.style.background = '#0284c7';
                    saveBtn.disabled = false;
                }, 2000);

            } catch (error) {
                console.error('Error saving note:', error);
                saveBtn.textContent = 'Error';
                saveBtn.style.background = '#dc2626';

                setTimeout(() => {
                    saveBtn.textContent = originalText;
                    saveBtn.style.background = '#0284c7';
                    saveBtn.disabled = false;
                }, 2000);
            }
        }

        async function reviseMeal(index, dayIndex = null, mealIndex = null) {
            // Get the meal based on plan structure
            let meal;
            if (dayIndex !== null && mealIndex !== null) {
                // Multi-day plan
                meal = currentPlan.days[dayIndex].plan[mealIndex];
            } else {
                // Single-day plan
                meal = currentPlan.meals[index];
            }

            // Use window.prompt() like planner.html does
            const revisionText = window.prompt(
                `Revise "${meal.name}"?\n\nEnter your specific request (e.g., "make it vegetarian", "swap rice for sweet potato", "just protein shake with creatine"):`,
                ''
            );

            if (!revisionText || !revisionText.trim()) {
                return; // User cancelled or entered empty string
            }

            const mealCard = document.getElementById(`meal-${index}`);

            // Save current meal state for undo functionality
            const stateKey = dayIndex !== null ? `${dayIndex}-${mealIndex}` : `${index}`;
            previousMealStates[stateKey] = JSON.parse(JSON.stringify(meal)); // Deep copy
            console.log(`üíæ Saved previous state for meal ${stateKey}:`, previousMealStates[stateKey]);

            // Show loading
            mealCard.innerHTML = '<div class="spinner"></div><p style="text-align:center;">Revising meal...</p>';

            try {
                // Use EXACT same prompt as planner.html for consistency
                const prompt = `Revise this meal based on user request: "${meal.name}" (${meal.type || 'meal'})

USER REQUEST: ${revisionText}

CURRENT MEAL:
- Calories: ${meal.calories}
- Protein: ${meal.protein}g
- Carbs: ${meal.carbs}g
- Fat: ${meal.fat}g
- Ingredients: ${meal.ingredients ? (Array.isArray(meal.ingredients) ? meal.ingredients.join(', ') : meal.ingredients) : 'N/A'}

REVISION RULES - Follow these carefully:

1. EXPLICIT AMOUNTS: If user specifies exact amount (e.g., "make salmon 200g", "use 2 eggs"),
   use EXACTLY that amount even if it changes the meal's total calories.

2. VAGUE INCREASE: If user says "increase salmon" or "more protein" (no specific amount),
   increase by a reasonable amount (~30-50%) AND reduce other ingredients to keep total calories similar.

3. SWAP INGREDIENT: If user says "swap salmon for chicken" or "replace rice with quinoa",
   calculate the NEW ingredient amount to match the CALORIES of the original ingredient.
   Example: 130g salmon (230 cal) ‚Üí ~140g chicken breast to match ~230 cal

4. ADD NEW INGREDIENT: If user says "add chicken" to a meal that has none,
   ADD it on top - the meal will be bigger. Don't reduce other ingredients.

5. COMPLETE REPLACEMENT: If user specifies a simple meal or uses words like
   "just", "only", "make it", "change to", or "replace with":
   - Return ONLY the EXACT ingredients they specify - NOTHING ELSE
   - Do NOT add milk, water, banana, oats, peanut butter or ANY other ingredients
   - Do NOT try to make it a "complete meal" or "balanced"
   - Example: "just protein shake 2 scoops" = {"ingredients": ["Whey Protein (2 scoops)"]} - ONLY ONE INGREDIENT
   - Example: "only eggs and toast" = {"ingredients": ["Eggs (2 whole)", "Whole Wheat Bread (2 slices)"]} - ONLY TWO INGREDIENTS
   - The user WANTS a simple/small meal - this is intentional, not a mistake

Diet: ${currentPlan.preferences?.dietType || 'any'}
${currentPlan.preferences?.allergies ? `Avoid: ${currentPlan.preferences.allergies}` : ''}

Use ONLY foods from USDA database - you can choose from 200+ foods including:
Proteins: Chicken Breast, Salmon, Ground Turkey, Eggs, Shrimp, Tofu, Greek Yogurt, Whey Protein
Carbs: Brown Rice, Quinoa, Sweet Potato, Oats, Whole Wheat Bread, Pasta
Fats: Olive Oil, Avocado, Almonds, Peanut Butter
Vegetables: Broccoli, Spinach, Bell Pepper, Asparagus, etc.

CRITICAL:
1. Return ingredients as ARRAY OF STRINGS with amounts in parentheses
2. DO NOT include calories/protein/carbs/fat - backend will calculate from database
MEAL NAME FORMAT: Include ALL key ingredient portions inline in parentheses

EXAMPLE FORMAT:
{"type":"${meal.type || 'meal'}","name":"Whey Protein Shake (2 scoops)","ingredients":["Whey Protein (2 scoops)"],"instructions":"Mix with water and consume."}

Return ONLY valid JSON. NO quotes in text - use apostrophes. Keep it brief.`;

                // Send isJson and targets, but skipAutoScale for revise (user controls portions)
                const response = await fetch(API_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt,
                        isJson: true,
                        skipAutoScale: true, // Don't auto-scale revisions - user controls the portions
                        targets: {
                            calories: meal.calories || 500,
                            protein: meal.protein || 30,
                            carbs: meal.carbs || 50,
                            fat: meal.fat || 15
                        },
                        mealsPerDay: 1
                    })
                });

                if (!response.ok) throw new Error('API request failed');

                const data = await response.json();

                let revisedMeal;
                // Handle new backend format (with USDA calculation)
                if (data.success && data.data) {
                    console.log('‚úÖ Using new format with USDA calculation');
                    revisedMeal = data.data;

                    // Validate that backend calculated macros
                    if (!revisedMeal.calories || revisedMeal.calories === 0) {
                        console.warn('‚ö†Ô∏è Backend returned zero calories - ingredients may not have matched');
                    }
                } else {
                    // FALLBACK: Old Gemini format (shouldn't happen with new code)
                    console.log('‚ö†Ô∏è Using old Gemini format - macros may be inaccurate');
                    let text = data.candidates[0].content.parts[0].text;
                    text = text.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim();
                    text = text.replace(/:\s*NaN/g, ': null');

                    const jsonMatch = text.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        text = jsonMatch[0];
                    }

                    revisedMeal = JSON.parse(text);
                }

                // Ensure meal has required fields
                revisedMeal.type = revisedMeal.type || meal.type || 'meal';
                revisedMeal.name = revisedMeal.name || 'Revised Meal';
                revisedMeal.instructions = revisedMeal.instructions || meal.instructions || '';

                // Use calculated macros - only fallback if truly undefined/null (not 0)
                // Note: 0 is a valid value if ingredient wasn't found, so log warning
                if (revisedMeal.calories === 0 || revisedMeal.calories === undefined || revisedMeal.calories === null) {
                    console.warn('‚ö†Ô∏è Backend returned 0/missing calories - ingredient may not be in database');
                }
                revisedMeal.calories = revisedMeal.calories !== undefined && revisedMeal.calories !== null ? revisedMeal.calories : meal.calories;
                revisedMeal.protein = revisedMeal.protein !== undefined && revisedMeal.protein !== null ? revisedMeal.protein : meal.protein;
                revisedMeal.carbs = revisedMeal.carbs !== undefined && revisedMeal.carbs !== null ? revisedMeal.carbs : meal.carbs;
                revisedMeal.fat = revisedMeal.fat !== undefined && revisedMeal.fat !== null ? revisedMeal.fat : meal.fat;

                // Save the revised meal to the correct location
                if (dayIndex !== null && mealIndex !== null) {
                    // Multi-day plan
                    currentPlan.days[dayIndex].plan[mealIndex] = revisedMeal;
                } else {
                    // Single-day plan
                    currentPlan.meals[index] = revisedMeal;
                }
                localStorage.setItem('currentMealPlan', JSON.stringify(currentPlan));

                // Save to database if viewing from database
                await savePlanToDatabase();

                // Refresh display
                displayMealPlan();

            } catch (error) {
                console.error('‚ùå Revision error:', error);
                alert('Failed to revise meal. Please try again.');
                displayMealPlan();
            }
        }

        // CUSTOM MEAL - Opens modal for custom meal creation
        function customMeal(index, dayIndex = null, mealIndex = null) {
            openCustomMealModal(index, dayIndex, mealIndex);
        }

        async function changeMeal(index, dayIndex = null, mealIndex = null) {
            // Get the meal based on plan structure
            let meal;
            let mealsPerDay = 1;
            let allMealNames = []; // Collect all meal names to avoid repetition

            if (dayIndex !== null && mealIndex !== null) {
                // Multi-day plan
                meal = currentPlan.days[dayIndex].plan[mealIndex];
                mealsPerDay = currentPlan.days[dayIndex].plan.length;
                // Collect ALL meal names from ALL days
                currentPlan.days.forEach(day => {
                    day.plan.forEach(m => {
                        if (m.name) allMealNames.push(m.name);
                    });
                });
            } else {
                // Single-day plan
                meal = currentPlan.meals[index];
                mealsPerDay = currentPlan.meals.length;
                // Collect all meal names
                currentPlan.meals.forEach(m => {
                    if (m.name) allMealNames.push(m.name);
                });
            }

            // IMPORTANT: Calculate CONSISTENT per-meal targets from daily nutrition
            // This prevents calorie drift after multiple exchanges
            const dailyNutrition = currentPlan.nutrition || {};
            const targetCalories = Math.round((dailyNutrition.calories || 2000) / mealsPerDay);
            const targetProtein = Math.round((dailyNutrition.protein || 150) / mealsPerDay);
            const targetCarbs = Math.round((dailyNutrition.carbs || 200) / mealsPerDay);
            const targetFat = Math.round((dailyNutrition.fat || 70) / mealsPerDay);

            console.log(`üéØ Exchange targets (from daily ${dailyNutrition.calories}cal / ${mealsPerDay} meals): ${targetCalories}cal, ${targetProtein}P, ${targetCarbs}C, ${targetFat}F`);
            console.log(`üö´ Meals to avoid (${allMealNames.length}):`, allMealNames);

            const mealCard = document.getElementById(`meal-${index}`);

            // Save current meal state for undo functionality
            const stateKey = dayIndex !== null ? `${dayIndex}-${mealIndex}` : `${index}`;
            previousMealStates[stateKey] = JSON.parse(JSON.stringify(meal)); // Deep copy
            console.log(`üíæ Saved previous state for undo (change):`, previousMealStates[stateKey]);

            mealCard.innerHTML = '<div class="spinner"></div><p style="text-align:center;">Generating new meal...</p>';

            try {
                // Build the "avoid these meals" list for variety
                const avoidMealsList = allMealNames.length > 0
                    ? `\n\nNEVER generate any of these meals (they're already in the plan):\n${allMealNames.map(n => `- ${n}`).join('\n')}\n`
                    : '';

                // NEW: Prompt asks for ingredients array - backend will calculate macros from USDA database
                const prompt = `Generate a DIFFERENT ${meal.type || 'meal'} (not "${meal.name}"):
${avoidMealsList}
STRICT Target Nutrition - the new meal MUST closely match these values:
- Calories: ${targetCalories} (stay within ¬±50 calories)
- Protein: ${targetProtein}g (stay within ¬±5g)
- Carbs: ${targetCarbs}g (stay within ¬±10g)
- Fat: ${targetFat}g (stay within ¬±5g)

Diet: ${currentPlan.preferences?.dietType || 'any'}
${currentPlan.preferences?.allergies ? `Avoid: ${currentPlan.preferences.allergies}` : ''}

IMPORTANT: Be CREATIVE and suggest a UNIQUE meal. Try different cuisines (Mexican, Asian, Mediterranean, American, Indian) and cooking styles.

Use ONLY foods from USDA database including:
Proteins: Chicken Breast, Salmon, Ground Turkey, Eggs, Egg Whites, Shrimp, Tofu, Greek Yogurt, Tilapia, Cod, Tuna, Lean Beef, Pork Tenderloin
Carbs: Brown Rice, Quinoa, Sweet Potato, Oats, Whole Wheat Bread, Pasta, White Rice, Couscous, Black Beans, Chickpeas
Fats: Olive Oil, Avocado, Almonds, Peanut Butter, Walnuts, Cashews, Coconut Oil
Vegetables: Broccoli, Spinach, Bell Pepper, Asparagus, Zucchini, Mushrooms, Onions, Tomatoes, Carrots, Green Beans
Fruits: Blueberries, Strawberries, Banana, Apple, Mango, Pineapple, Orange

CRITICAL:
1. Return ingredients as ARRAY OF STRINGS with amounts in parentheses
2. DO NOT include calories/protein/carbs/fat values - the backend will calculate them
3. Choose portions that CLOSELY MATCH the target nutrition above - this is essential
4. If original meal was small (under 400 cal), keep new meal small. If large (over 600 cal), keep it large.

Return ONLY valid JSON (NO markdown, NO backticks):
{
  "type": "${meal.type || 'meal'}",
  "name": "Meal Name (with key portions)",
  "ingredients": ["Ingredient 1 (amount)", "Ingredient 2 (amount)"],
  "instructions": "Cooking instructions"
}`;

                // NEW: Send isJson and targets to trigger backend USDA calculation
                const response = await fetch(API_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt,
                        isJson: true,
                        targets: {
                            calories: targetCalories,
                            protein: targetProtein,
                            carbs: targetCarbs,
                            fat: targetFat
                        },
                        mealsPerDay: 1
                    })
                });

                if (!response.ok) throw new Error('API request failed');

                const data = await response.json();

                let newMeal;
                // Handle new backend format (with USDA calculation)
                if (data.success && data.data) {
                    console.log('‚úÖ Using new format with USDA calculation');
                    newMeal = data.data;

                    // Validate that backend calculated macros
                    if (!newMeal.calories || newMeal.calories === 0) {
                        console.warn('‚ö†Ô∏è Backend returned zero calories - ingredients may not have matched');
                    }
                } else {
                    // FALLBACK: Old Gemini format
                    console.log('‚ö†Ô∏è Using old Gemini format - macros may be inaccurate');
                    let text = data.candidates[0].content.parts[0].text;
                    text = text.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim();
                    text = text.replace(/:\s*NaN/g, ': null');

                    const jsonMatch = text.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        text = jsonMatch[0];
                    }

                    newMeal = JSON.parse(text);
                }

                // Ensure meal has required fields
                newMeal.type = newMeal.type || meal.type || 'meal';
                newMeal.name = newMeal.name || 'New Meal';
                newMeal.instructions = newMeal.instructions || '';

                // Use calculated macros - only fallback if truly undefined/null (not 0)
                if (newMeal.calories === 0 || newMeal.calories === undefined || newMeal.calories === null) {
                    console.warn('‚ö†Ô∏è Backend returned 0/missing calories - ingredient may not be in database');
                }
                newMeal.calories = newMeal.calories !== undefined && newMeal.calories !== null ? newMeal.calories : meal.calories;
                newMeal.protein = newMeal.protein !== undefined && newMeal.protein !== null ? newMeal.protein : meal.protein;
                newMeal.carbs = newMeal.carbs !== undefined && newMeal.carbs !== null ? newMeal.carbs : meal.carbs;
                newMeal.fat = newMeal.fat !== undefined && newMeal.fat !== null ? newMeal.fat : meal.fat;

                // Save the new meal to the correct location
                if (dayIndex !== null && mealIndex !== null) {
                    // Multi-day plan
                    currentPlan.days[dayIndex].plan[mealIndex] = newMeal;
                } else {
                    // Single-day plan
                    currentPlan.meals[index] = newMeal;
                }
                localStorage.setItem('currentMealPlan', JSON.stringify(currentPlan));

                // Save to database if viewing from database
                await savePlanToDatabase();

                displayMealPlan();

            } catch (error) {
                console.error('‚ùå Change meal error:', error);
                alert('Failed to change meal. Please try again.');
                displayMealPlan();
            }
        }

        // REGENERATE ENTIRE DAY - Generate all new meals for a specific day
        async function regenerateDay(dayIndex) {
            if (!currentPlan.multiDay || !currentPlan.days || !currentPlan.days[dayIndex]) {
                alert('Cannot regenerate: Invalid day index');
                return;
            }

            const dayData = currentPlan.days[dayIndex];
            const dayNumber = dayData.day;
            const numMeals = dayData.plan.length;
            const targets = dayData.targets || currentPlan.nutrition;

            // Get meal structure from original day
            const mealTypes = dayData.plan.map(m => m.type || 'meal');

            // Build list of meals from other days to avoid repetition
            let otherDaysMeals = [];
            currentPlan.days.forEach((d, idx) => {
                if (idx !== dayIndex && d.plan) {
                    d.plan.forEach(meal => {
                        otherDaysMeals.push(meal.name);
                    });
                }
            });
            const avoidMealsText = otherDaysMeals.length > 0
                ? `\nDO NOT repeat these meals from other days: ${otherDaysMeals.slice(0, 10).join(', ')}`
                : '';

            // Show loading state on all meal cards for this day
            const container = document.getElementById('mealsContainer');
            const dayHeaders = container.querySelectorAll('.day-header');
            if (dayHeaders[dayIndex]) {
                let currentElement = dayHeaders[dayIndex].nextElementSibling;
                // Skip the day totals div
                if (currentElement) currentElement = currentElement.nextElementSibling;

                while (currentElement && !currentElement.classList.contains('day-header')) {
                    if (currentElement.classList.contains('meal-card')) {
                        currentElement.innerHTML = '<div class="spinner"></div><p style="text-align:center;">Regenerating day...</p>';
                    }
                    currentElement = currentElement.nextElementSibling;
                }
            }

            try {
                // Generate all meals for the day in one request
                // NEW: Ask for ingredients arrays - backend will calculate macros from USDA database
                const prompt = `Generate a COMPLETELY NEW ${numMeals}-meal plan for Day ${dayNumber}.

Daily Nutrition Targets:
- Calories: ${targets.calories || 2000}
- Protein: ${targets.protein || 150}g
- Carbs: ${targets.carbs || 200}g
- Fat: ${targets.fat || 70}g

Required meal types (in order): ${mealTypes.join(', ')}

Diet: ${currentPlan.preferences?.dietType || 'any'}
${currentPlan.preferences?.allergies ? `Avoid: ${currentPlan.preferences.allergies}` : ''}${avoidMealsText}

CRITICAL: Return ingredients as ARRAY OF STRINGS with amounts in parentheses for EACH meal.
DO NOT include calories/protein/carbs/fat values - the backend will calculate them from the USDA database.
Use common foods with specific amounts like: "Chicken Breast (200g)", "Brown Rice (150g)", "Olive Oil (1 tbsp)"

Return ONLY a valid JSON array with ${numMeals} meal objects:
[
  {"type":"breakfast","name":"Meal Name (with portions)","ingredients":["Ingredient 1 (amount)","Ingredient 2 (amount)"],"instructions":"Cooking steps"},
  {"type":"lunch","name":"Another Meal (with portions)","ingredients":["Ingredient 1 (amount)","Ingredient 2 (amount)"],"instructions":"Steps"}
]

NO markdown, NO backticks, NO extra text. ONLY the JSON array.`;

                // NEW: Send isJson and targets to trigger backend USDA calculation
                const response = await fetch(API_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt,
                        isJson: true,
                        targets: {
                            calories: targets.calories || 2000,
                            protein: targets.protein || 150,
                            carbs: targets.carbs || 200,
                            fat: targets.fat || 70
                        },
                        mealsPerDay: numMeals
                    })
                });

                if (!response.ok) throw new Error('API request failed');

                const data = await response.json();

                let newMeals;
                // Handle new backend format (with Claude corrections)
                if (data.success && data.data) {
                    console.log('‚úÖ Using new format with Claude corrections');
                    newMeals = Array.isArray(data.data) ? data.data : [data.data];
                } else {
                    // FALLBACK: Old Gemini format
                    console.log('‚ö†Ô∏è Using old Gemini format');
                    let text = data.candidates[0].content.parts[0].text;
                    text = text.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim();
                    text = text.replace(/:\s*NaN/g, ': null');

                    // Extract JSON array
                    const jsonMatch = text.match(/\[[\s\S]*\]/);
                    if (jsonMatch) {
                        text = jsonMatch[0];
                    }
                    newMeals = JSON.parse(text);
                }

                // Validate and sanitize the meals
                if (!Array.isArray(newMeals) || newMeals.length === 0) {
                    throw new Error('Invalid response format');
                }

                // Sanitize and preserve all meal data including ingredients
                // Backend calculates macros from USDA database based on ingredients
                newMeals = newMeals.map((meal, i) => ({
                    type: meal.type || mealTypes[i] || 'meal',
                    name: meal.name || 'New Meal',
                    calories: parseInt(meal.calories) || Math.round(targets.calories / numMeals),
                    protein: parseInt(meal.protein) || Math.round(targets.protein / numMeals),
                    carbs: parseInt(meal.carbs) || Math.round(targets.carbs / numMeals),
                    fat: parseInt(meal.fat) || Math.round(targets.fat / numMeals),
                    ingredients: meal.ingredients || [],
                    instructions: meal.instructions || 'Follow recipe instructions.'
                }));

                // Update the day's meals
                currentPlan.days[dayIndex].plan = newMeals;
                localStorage.setItem('currentMealPlan', JSON.stringify(currentPlan));

                // Save to database if viewing from database
                await savePlanToDatabase();

                // Refresh the display
                displayMealPlan();

                console.log(`‚úÖ Day ${dayNumber} regenerated successfully`);

            } catch (error) {
                console.error('‚ùå Regenerate day error:', error);
                alert('Failed to regenerate day. Please try again.');
                displayMealPlan();
            }
        }

        // MEAL PREP GUIDE FUNCTIONS
        async function showMealPrepGuide() {
            const modal = document.getElementById('mealPrepModal');
            const content = document.getElementById('mealPrepContent');

            // Show modal with loading state
            modal.style.display = 'flex';
            content.innerHTML = `
                <div style="text-align: center; padding: 40px;">
                    <div class="loader" style="margin: 0 auto 20px; border: 4px solid #f3f3f3; border-top: 4px solid #0d9488; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite;"></div>
                    <p style="color: #666;">Generating your comprehensive meal prep guide...</p>
                </div>
            `;

            try {
                // Collect all meals from the plan (handle both single-day and multi-day)
                const allMeals = [];
                let numDays = 1;

                if (currentPlan.multiDay && currentPlan.days) {
                    // Multi-day plan: collect from all days
                    numDays = currentPlan.days.length;
                    currentPlan.days.forEach(dayData => {
                        if (dayData.plan && Array.isArray(dayData.plan)) {
                            dayData.plan.forEach(meal => {
                                allMeals.push({
                                    day: dayData.day,
                                    type: meal.type,
                                    name: meal.name,
                                    calories: meal.calories,
                                    protein: meal.protein,
                                    carbs: meal.carbs,
                                    fat: meal.fat
                                });
                            });
                        }
                    });
                } else if (currentPlan.meals && Array.isArray(currentPlan.meals)) {
                    // Single-day plan
                    currentPlan.meals.forEach(meal => {
                        allMeals.push({
                            type: meal.type,
                            name: meal.name,
                            calories: meal.calories,
                            protein: meal.protein,
                            carbs: meal.carbs,
                            fat: meal.fat
                        });
                    });
                }

                if (allMeals.length === 0) {
                    content.innerHTML = '<p style="text-align: center; color: #666;">No meal plan found.</p>';
                    return;
                }

                // Build meals list (include day number for multi-day plans)
                const mealsList = allMeals.map(m => {
                    if (m.day) {
                        return `Day ${m.day} ${m.type}: ${m.name}`;
                    }
                    return `${m.type}: ${m.name}`;
                }).join('\n');

                const prompt = `You are a professional meal prep consultant. Create a comprehensive meal prep guide for the following ${numDays}-day meal plan:

${mealsList}

Create a detailed, actionable meal prep guide with the following sections:

## üìù Shopping List
Group all ingredients by category (Proteins, Vegetables, Fruits, Grains/Carbs, Dairy, Pantry Items, etc.)
Combine quantities where meals share ingredients
Be specific with quantities and measurements

## ‚è∞ Meal Prep Timeline
Provide a prep schedule (e.g., "Sunday: Cook all proteins", "Monday: Prep vegetables")
Include which meals to batch cook together
Suggest which components can be prepared ahead
Include estimated time for each prep session

## ü•° Storage Instructions
For EACH meal, specify:
- How long it keeps in the refrigerator (be specific: 3-4 days, 5-6 days, etc.)
- Whether it can be frozen and for how long
- Best storage containers (airtight, glass, etc.)
- Any special storage notes

## üî• Reheating Instructions
For EACH meal type, provide:
- Microwave instructions (time and power level)
- Oven/stovetop instructions if better quality
- Tips to maintain texture and flavor

## üí° Time-Saving Tips
- Batch cooking strategies (cook all chicken at once, prep all vegetables together, etc.)
- Make-ahead components (cook rice/grains in bulk, pre-chop vegetables, etc.)
- Kitchen shortcuts and efficiency tips
- Which meals taste better fresh vs reheated

Format the response in clean, readable markdown with clear headings and bullet points.
Be specific, practical, and actionable. Focus on making meal prep as easy and efficient as possible.`;

                const response = await callGeminiAPI(prompt);

                // Format the response nicely
                content.innerHTML = `<div style="line-height: 1.6;">${formatMarkdown(response)}</div>`;

            } catch (error) {
                console.error('Error generating meal prep guide:', error);
                content.innerHTML = `
                    <div style="text-align: center; color: #f44336; padding: 40px;">
                        <p style="font-weight: bold;">Error generating meal prep guide</p>
                        <p style="font-size: 14px; margin-top: 10px;">${error.message}</p>
                    </div>
                `;
            }
        }

        function closeMealPrepModal() {
            document.getElementById('mealPrepModal').style.display = 'none';
        }

        // Simple markdown formatter
        function formatMarkdown(text) {
            if (!text || typeof text !== 'string') {
                console.error('formatMarkdown received invalid input:', text);
                throw new Error('Invalid response format from AI');
            }
            return text
                .replace(/^## (.+)$/gm, '<h2 style="font-size: 24px; font-weight: bold; margin: 30px 0 15px 0; color: #333;">$1</h2>')
                .replace(/^### (.+)$/gm, '<h3 style="font-size: 18px; font-weight: 600; margin: 20px 0 10px 0; color: #555;">$1</h3>')
                .replace(/^\* (.+)$/gm, '<li style="margin-left: 20px; margin-bottom: 8px;">$1</li>')
                .replace(/^- (.+)$/gm, '<li style="margin-left: 20px; margin-bottom: 8px;">$1</li>')
                .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                .replace(/\n\n/g, '</p><p style="margin: 12px 0;">')
                .replace(/^(?!<[hl]|<li)/gm, '<p style="margin: 12px 0;">')
                .replace(/<\/li>\n<li/g, '</li><li');
        }

        // API call to Gemini (reuse existing implementation if available, or add new one)
        async function callGeminiAPI(prompt) {
            const response = await fetch('/.netlify/functions/generate-meal-plan', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    prompt,
                    isJson: false // üÜï CRITICAL: This is a text-only request (markdown)
                })
            });

            if (!response.ok) {
                const errorText = await response.text();
                console.error('API Error:', errorText);
                throw new Error('Failed to generate meal prep guide');
            }

            const data = await response.json();
            console.log('API Response:', data);

            // NEW: Handle new backend format (with Claude corrections)
            if (data.success && data.data) {
                console.log('‚úÖ Using new format with Claude corrections');
                // Backend returns parsed data, convert to text if needed
                return typeof data.data === 'string' ? data.data : JSON.stringify(data.data);
            }

            // FALLBACK: Extract text from Gemini response structure
            if (data.candidates && data.candidates[0] && data.candidates[0].content) {
                console.log('‚ö†Ô∏è Using old Gemini format');
                const text = data.candidates[0].content.parts[0].text;
                if (!text) {
                    console.error('No text in response:', data);
                    throw new Error('Invalid response from AI service');
                }
                return text;
            }

            // Fallback: check for data.result (in case of different response format)
            if (data.result) {
                return data.result;
            }

            console.error('Unexpected response structure:', data);
            throw new Error('Invalid response from AI service');
        }

        async function downloadPDF() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();

            const margin = 15;
            const pageWidth = doc.internal.pageSize.getWidth();
            const maxWidth = pageWidth - (margin * 2);
            let y = 20;

            // Title
            doc.setFontSize(24);
            doc.setTextColor(102, 126, 234);
            doc.text('Personalized Meal Plan', margin, y);
            y += 10;

            // Client Name
            if (currentPlan.clientName) {
                doc.setFontSize(16);
                doc.setTextColor(0, 0, 0);
                doc.text(`For: ${currentPlan.clientName}`, margin, y);
                y += 12;
            }

            // Daily Nutrition Summary
            doc.setFontSize(14);
            doc.setTextColor(0, 0, 0);
            doc.text('Daily Nutrition Targets:', margin, y);
            y += 8;
            doc.setFontSize(11);
            const nutrition = currentPlan.nutrition;
            doc.text(`Calories: ${nutrition.calories} | Protein: ${nutrition.protein}g | Carbs: ${nutrition.carbs}g | Fat: ${nutrition.fat}g`, margin, y);
            y += 15;

            // Collect all meals (handles both single-day and multi-day plans)
            let allMeals = [];
            if (currentPlan.multiDay && currentPlan.days) {
                // Multi-day plan: collect meals from all days
                currentPlan.days.forEach(dayData => {
                    if (dayData.plan && Array.isArray(dayData.plan)) {
                        dayData.plan.forEach(meal => {
                            allMeals.push({ ...meal, dayNumber: dayData.day });
                        });
                    }
                });
            } else if (currentPlan.meals) {
                // Single-day plan
                allMeals = currentPlan.meals;
            }

            // Meals
            allMeals.forEach((meal, index) => {
                // Add day header for multi-day plans
                if (meal.dayNumber && (index === 0 || meal.dayNumber !== allMeals[index - 1].dayNumber)) {
                    if (y > 250) {
                        doc.addPage();
                        y = 20;
                    }
                    doc.setFontSize(16);
                    doc.setTextColor(102, 126, 234);
                    doc.text(`Day ${meal.dayNumber}`, margin, y);
                    y += 10;
                }
                if (y > 230) {
                    doc.addPage();
                    y = 20;
                }

                // Meal Name
                doc.setFontSize(14);
                doc.setTextColor(102, 126, 234);
                const mealNameLines = doc.splitTextToSize(meal.name, maxWidth);
                doc.text(mealNameLines, margin, y);
                y += mealNameLines.length * 6;

                // Macros
                doc.setFontSize(10);
                doc.setTextColor(100, 100, 100);
                doc.text(`${meal.calories} cal | ${meal.protein}g protein | ${meal.carbs}g carbs | ${meal.fat}g fat`, margin + 5, y);
                y += 7;

                // Ingredients (if available)
                if (meal.ingredients && Array.isArray(meal.ingredients) && meal.ingredients.length > 0) {
                    doc.setFontSize(11);
                    doc.setTextColor(0, 0, 0);
                    doc.setFont(undefined, 'bold');
                    doc.text('Ingredients:', margin + 5, y);
                    y += 5;
                    doc.setFont(undefined, 'normal');
                    doc.setFontSize(9);
                    meal.ingredients.forEach(ingredient => {
                        if (y > 270) {
                            doc.addPage();
                            y = 20;
                        }
                        const ingredientLines = doc.splitTextToSize(`‚Ä¢ ${ingredient}`, maxWidth - 10);
                        doc.text(ingredientLines, margin + 10, y);
                        y += ingredientLines.length * 4;
                    });
                    y += 3;
                }

                // Cooking Instructions
                if (meal.instructions) {
                    if (y > 260) {
                        doc.addPage();
                        y = 20;
                    }
                    doc.setFontSize(11);
                    doc.setFont(undefined, 'bold');
                    doc.text('Cooking Instructions:', margin + 5, y);
                    y += 5;
                    doc.setFont(undefined, 'normal');
                    doc.setFontSize(9);
                    const instructionLines = doc.splitTextToSize(meal.instructions, maxWidth - 10);
                    doc.text(instructionLines, margin + 10, y);
                    y += instructionLines.length * 4 + 8;
                }

                y += 5; // Space between meals
            });

            // Grocery List
            const groceryList = aggregateGroceryList();
            if (groceryList && groceryList.length > 0) {
                doc.addPage();
                y = 20;
                doc.setFontSize(20);
                doc.setTextColor(102, 126, 234);
                doc.text('Shopping List', margin, y);
                y += 12;

                doc.setFontSize(10);
                doc.setTextColor(0, 0, 0);
                groceryList.forEach(item => {
                    if (y > 270) {
                        doc.addPage();
                        y = 20;
                    }
                    const itemText = `- ${item.quantity.toFixed(1)} ${item.unit} ${item.name}`;
                    doc.text(itemText, margin, y);
                    y += 6;
                });
            }

            // Meal Prep Guide
            try {
                // Show loading indicator
                const loadingMsg = document.createElement('div');
                loadingMsg.id = 'pdf-loading';
                loadingMsg.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:white;padding:30px;border-radius:10px;box-shadow:0 4px 20px rgba(0,0,0,0.3);z-index:10001;text-align:center;';
                loadingMsg.innerHTML = '<div style="font-size:18px;font-weight:bold;margin-bottom:10px;">üìÑ Generating PDF...</div><div style="color:#666;">Adding meal prep guide</div>';
                document.body.appendChild(loadingMsg);

                // Generate meal prep guide
                const allMeals = [];
                let numDays = 1;

                if (currentPlan.multiDay && currentPlan.days) {
                    // Multi-day plan: collect from all days
                    numDays = currentPlan.days.length;
                    currentPlan.days.forEach(dayData => {
                        if (dayData.plan && Array.isArray(dayData.plan)) {
                            dayData.plan.forEach(meal => {
                                allMeals.push({
                                    day: dayData.day,
                                    type: meal.type,
                                    name: meal.name,
                                    calories: meal.calories,
                                    protein: meal.protein,
                                    carbs: meal.carbs,
                                    fat: meal.fat
                                });
                            });
                        }
                    });
                } else if (currentPlan.meals && Array.isArray(currentPlan.meals)) {
                    // Single-day plan
                    currentPlan.meals.forEach(meal => {
                        allMeals.push({
                            type: meal.type,
                            name: meal.name,
                            calories: meal.calories,
                            protein: meal.protein,
                            carbs: meal.carbs,
                            fat: meal.fat
                        });
                    });
                }

                // Build meals list (include day number for multi-day plans)
                const mealsList = allMeals.map(m => {
                    if (m.day) {
                        return `Day ${m.day} ${m.type}: ${m.name}`;
                    }
                    return `${m.type}: ${m.name}`;
                }).join('\n');

                const prompt = `You are a professional meal prep consultant. Create a comprehensive meal prep guide for the following ${numDays}-day meal plan:

${mealsList}

Create a detailed, actionable meal prep guide with the following sections:

## üìù Shopping List Tips
Provide tips for efficient shopping based on this meal plan (best stores, what to buy in bulk, what to buy fresh, etc.)

## ‚è∞ Meal Prep Timeline
Provide a day-by-day prep schedule (e.g., "Sunday: Cook all proteins", "Monday: Prep vegetables")
Include which meals to batch cook together
Suggest which components can be prepared ahead
Include estimated time for each prep session

## ü•° Storage Instructions
For EACH unique meal type, specify:
- How long it keeps in the refrigerator (be specific: 3-4 days, 5-6 days, etc.)
- Whether it can be frozen and for how long
- Best storage containers (airtight, glass, etc.)
- Any special storage notes

## üî• Reheating Instructions
For EACH unique meal type, provide:
- Microwave instructions (time and power level)
- Oven/stovetop instructions if better quality
- Tips to maintain texture and flavor

## üí° Time-Saving Tips
- Batch cooking strategies
- Make-ahead components
- Kitchen shortcuts and efficiency tips
- Which meals taste better fresh vs reheated

Format the response in clean, readable markdown with clear headings and bullet points.
Be specific, practical, and actionable. Keep it concise but comprehensive.`;

                const response = await callGeminiAPI(prompt);

                // Remove loading indicator
                document.body.removeChild(loadingMsg);

                // Add new page for meal prep guide
                doc.addPage();
                y = 20;

                // Title
                doc.setFontSize(20);
                doc.setTextColor(255, 107, 107);
                doc.text('Meal Prep Guide', margin, y);
                y += 12;

                // Parse and format the meal prep guide for PDF
                const lines = response.split('\n');
                doc.setTextColor(0, 0, 0);

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();

                    if (!line) {
                        y += 4; // Blank line spacing
                        continue;
                    }

                    // Check if we need a new page
                    if (y > 270) {
                        doc.addPage();
                        y = 20;
                    }

                    // Section headers (## )
                    if (line.startsWith('## ')) {
                        y += 5;
                        if (y > 265) {
                            doc.addPage();
                            y = 20;
                        }
                        const headerText = line.replace('## ', '').replace(/[üìù‚è∞ü•°üî•üí°]/g, '').trim();
                        doc.setFontSize(14);
                        doc.setFont(undefined, 'bold');
                        doc.setTextColor(102, 126, 234);
                        doc.text(headerText, margin, y);
                        y += 8;
                        doc.setFont(undefined, 'normal');
                        doc.setTextColor(0, 0, 0);
                        continue;
                    }

                    // Subsection headers (### )
                    if (line.startsWith('### ')) {
                        y += 3;
                        if (y > 268) {
                            doc.addPage();
                            y = 20;
                        }
                        const subheaderText = line.replace('### ', '');
                        doc.setFontSize(11);
                        doc.setFont(undefined, 'bold');
                        doc.text(subheaderText, margin + 5, y);
                        y += 6;
                        doc.setFont(undefined, 'normal');
                        continue;
                    }

                    // Bullet points
                    if (line.startsWith('* ') || line.startsWith('- ')) {
                        doc.setFontSize(9);
                        const bulletText = line.replace(/^[*-] /, '').replace(/\*\*/g, '');
                        const bulletLines = doc.splitTextToSize(`‚Ä¢ ${bulletText}`, maxWidth - 15);

                        bulletLines.forEach((bulletLine, idx) => {
                            if (y > 275) {
                                doc.addPage();
                                y = 20;
                            }
                            doc.text(bulletLine, margin + (idx === 0 ? 8 : 12), y);
                            y += 4;
                        });
                        continue;
                    }

                    // Regular paragraph text
                    doc.setFontSize(9);
                    const textLines = doc.splitTextToSize(line, maxWidth - 5);
                    textLines.forEach(textLine => {
                        if (y > 275) {
                            doc.addPage();
                            y = 20;
                        }
                        doc.text(textLine, margin + 5, y);
                        y += 4;
                    });
                }

            } catch (error) {
                console.error('Error generating meal prep guide for PDF:', error);
                // Continue with PDF generation without meal prep guide
                const loadingEl = document.getElementById('pdf-loading');
                if (loadingEl) document.body.removeChild(loadingEl);
            }

            // Footer
            y += 10;
            if (y > 260) {
                doc.addPage();
                y = 20;
            }
            doc.setFontSize(8);
            doc.setTextColor(150, 150, 150);
            doc.text(`Generated on ${new Date().toLocaleDateString()}`, margin, y);

            doc.save('meal-plan.pdf');
        }

        // Helper functions for grocery list aggregation
        function parseIngredient(ingredient) {
            const match = ingredient.match(/^([\d.\/]+)?\s*([a-zA-Z]+)?\s*(.+)$/);
            if (!match) return { quantity: 1, unit: 'unit', name: ingredient };

            const quantity = match[1] ? eval(match[1]) : 1;
            const unit = match[2] || 'unit';
            const name = match[3] || ingredient;

            return { quantity, unit: unit.toLowerCase(), name: name.trim() };
        }

        function normalizeUnit(quantity, unit) {
            const conversions = {
                'tbsp': { base: 'cup', factor: 1/16 },
                'tablespoon': { base: 'cup', factor: 1/16 },
                'tsp': { base: 'cup', factor: 1/48 },
                'teaspoon': { base: 'cup', factor: 1/48 },
                'oz': { base: 'lb', factor: 1/16 },
                'ounce': { base: 'lb', factor: 1/16 },
                'g': { base: 'kg', factor: 0.001 },
                'gram': { base: 'kg', factor: 0.001 },
                'ml': { base: 'l', factor: 0.001 },
                'milliliter': { base: 'l', factor: 0.001 }
            };

            if (conversions[unit]) {
                return {
                    quantity: quantity * conversions[unit].factor,
                    unit: conversions[unit].base
                };
            }

            return { quantity, unit };
        }

        function aggregateGroceryList() {
            if (!currentPlan) return [];

            const aggregated = {};
            let allMeals = [];

            // Handle both multi-day and single-day plans
            if (currentPlan.multiDay && currentPlan.days) {
                // Multi-day plan: collect meals from all days
                currentPlan.days.forEach(dayData => {
                    if (dayData.plan && Array.isArray(dayData.plan)) {
                        allMeals = allMeals.concat(dayData.plan);
                    }
                });
            } else if (currentPlan.meals && Array.isArray(currentPlan.meals)) {
                // Single-day plan
                allMeals = currentPlan.meals;
            }

            // Aggregate ingredients from all meals
            allMeals.forEach(meal => {
                if (!meal.ingredients || !Array.isArray(meal.ingredients)) return;

                meal.ingredients.forEach(ingredient => {
                    const parsed = parseIngredient(ingredient);
                    const normalized = normalizeUnit(parsed.quantity, parsed.unit);

                    const key = `${parsed.name}|${normalized.unit}`;
                    if (aggregated[key]) {
                        aggregated[key].quantity += normalized.quantity;
                    } else {
                        aggregated[key] = {
                            name: parsed.name,
                            quantity: normalized.quantity,
                            unit: normalized.unit
                        };
                    }
                });
            });

            return Object.values(aggregated).sort((a, b) => a.name.localeCompare(b.name));
        }

        // ========== FAVORITES FUNCTIONS ==========

        async function loadFavorites(clientId) {
            if (!clientId) return;

            try {
                const response = await fetch(`${TOGGLE_FAVORITE_ENDPOINT}?clientId=${clientId}`);
                if (response.ok) {
                    const data = await response.json();
                    clientFavorites = data.favorites || [];
                    console.log('Loaded favorites:', clientFavorites.length);
                }
            } catch (error) {
                console.error('Error loading favorites:', error);
            }
        }

        async function toggleFavorite(mealName, mealType, calories, protein, carbs, fat, index) {
            // Get client ID from current context
            let clientId = null;
            let coachId = null;

            // Check URL params for client view
            const urlParams = new URLSearchParams(window.location.search);
            const isClientView = urlParams.get('clientView') === 'true';

            if (isClientView) {
                // Get client ID from session
                const { data: { session } } = await supabaseClient.auth.getSession();
                if (session) {
                    const { data: clientData } = await supabaseClient
                        .from('clients')
                        .select('id, coach_id')
                        .eq('user_id', session.user.id)
                        .single();

                    if (clientData) {
                        clientId = clientData.id;
                        coachId = clientData.coach_id;
                    }
                }
            }

            if (!clientId) {
                alert('Could not determine client. Please log in again.');
                return;
            }

            const btn = document.getElementById(`fav-${index}`);
            const originalContent = btn.innerHTML;
            btn.innerHTML = '...';
            btn.disabled = true;

            try {
                const response = await fetch(TOGGLE_FAVORITE_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        clientId,
                        coachId,
                        mealName,
                        mealType,
                        calories,
                        protein,
                        carbs,
                        fat
                    })
                });

                if (!response.ok) throw new Error('Failed to toggle favorite');

                const data = await response.json();

                if (data.action === 'added') {
                    btn.innerHTML = '‚ù§Ô∏è';
                    btn.classList.add('active');
                    btn.title = 'Remove from favorites';
                    clientFavorites.push({ meal_name: mealName });
                } else {
                    btn.innerHTML = 'ü§ç';
                    btn.classList.remove('active');
                    btn.title = 'Add to favorites';
                    clientFavorites = clientFavorites.filter(f => f.meal_name !== mealName);
                }

            } catch (error) {
                console.error('Error toggling favorite:', error);
                btn.innerHTML = originalContent;
            }

            btn.disabled = false;
        }
    </script>
</body>
</html>
