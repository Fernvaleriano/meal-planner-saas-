<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" href="/icons/logo.png" type="image/png">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="/js/theme.js"></script>
    <meta name="theme-color" content="#0d9488">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Zique Fitness">
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" href="/icons/logo.png">
    <title>Your Meal Plan - Zique Fitness Nutrition</title>
    <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2" as="script">
    <link rel="preconnect" href="https://qewqcjzlfqamqwbccapr.supabase.co" crossorigin>
    <link rel="dns-prefetch" href="https://qewqcjzlfqamqwbccapr.supabase.co">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" defer></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0d9488 0%, #0284c7 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .header h1 {
            color: #0d9488;
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .back-btn:hover {
            color: #0284c7;
        }

        .client-info {
            background: #f8f9ff;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 30px;
        }

        .section-title {
            color: #0d9488;
            font-weight: 700;
            font-size: 1.1em;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e0e7ff;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .info-item {
            padding: 15px;
            background: white;
            border-radius: 10px;
            border: 2px solid #e0e7ff;
        }

        .info-label {
            color: #0d9488;
            font-weight: 600;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .info-value {
            color: #333;
            font-size: 1.2em;
            font-weight: 700;
        }

        .meal-card {
            background: #f8f9ff;
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 25px;
            border: 2px solid #e0e7ff;
            display: flex;
            gap: 20px;
        }

        .meal-card-image {
            width: 140px;
            height: 140px;
            min-width: 140px;
            border-radius: 12px;
            object-fit: cover;
            background: #e0e7ff;
        }

        .meal-card-image-placeholder {
            width: 140px;
            height: 140px;
            min-width: 140px;
            border-radius: 12px;
            background: linear-gradient(90deg, #e0f2fe 25%, #f0f9ff 50%, #e0f2fe 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            color: #94a3b8;
        }

        @keyframes shimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        .meal-card-image {
            opacity: 0;
            transition: opacity 0.3s ease-in;
        }

        .meal-card-image.loaded {
            opacity: 1;
        }

        .meal-card-content {
            flex: 1;
            min-width: 0;
        }

        .meal-header {
            display: flex;
            flex-direction: column;
            margin-bottom: 20px;
            gap: 15px;
        }

        @media (max-width: 600px) {
            .meal-card {
                flex-direction: column;
            }
            .meal-card-image, .meal-card-image-placeholder {
                width: 100%;
                height: 200px;
            }
        }

        .meal-name {
            color: #0d9488;
            font-size: 1.3em;
            font-weight: 700;
            word-wrap: break-word;
            overflow-wrap: break-word;
            flex: 1;
            min-width: 0;
        }

        .meal-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9em;
        }

        .btn-change {
            background: #0d9488;
            color: white;
        }

        .btn-change:hover {
            background: #5568d3;
            transform: translateY(-2px);
        }

        .btn-revise {
            background: #0284c7;
            color: white;
        }

        .btn-revise:hover {
            background: #653a8a;
            transform: translateY(-2px);
        }

        .btn-undo {
            background: #dc2626;
            color: white;
        }

        .btn-undo:hover {
            background: #b91c1c;
            transform: translateY(-2px);
        }

        .btn-custom {
            background: #7c3aed;
            color: white;
        }

        .btn-custom:hover {
            background: #6d28d9;
            transform: translateY(-2px);
        }

        .btn-portions {
            background: #0891b2;
            color: white;
        }

        .btn-portions:hover {
            background: #0e7490;
            transform: translateY(-2px);
        }

        .btn-edit {
            background: #0d9488;
            color: white;
        }

        .btn-edit:hover {
            background: #0f766e;
            transform: translateY(-2px);
        }

        .btn-recipe {
            background: #ea580c;
            color: white;
        }

        .btn-recipe:hover {
            background: #c2410c;
            transform: translateY(-2px);
        }

        .btn-log-diary {
            background: #16a34a;
            color: white;
        }

        .btn-log-diary:hover {
            background: #15803d;
            transform: translateY(-2px);
        }

        /* Log Entire Plan Button Styles */
        .log-entire-plan-section {
            background: linear-gradient(135deg, #ecfdf5 0%, #d1fae5 100%);
            border: 2px solid #10b981;
            border-radius: 12px;
            padding: 16px 20px;
            margin: 20px 0;
            text-align: center;
        }

        .btn-log-entire-plan {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            padding: 14px 28px;
            border-radius: 10px;
            font-size: 1.05em;
            font-weight: 600;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
            transition: all 0.2s ease;
        }

        .btn-log-entire-plan:hover {
            background: linear-gradient(135deg, #059669 0%, #047857 100%);
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(16, 185, 129, 0.4);
        }

        .btn-log-entire-plan:disabled {
            background: #9ca3af;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-log-entire-plan .btn-icon {
            font-size: 1.2em;
        }

        .log-plan-hint {
            margin: 10px 0 0 0;
            color: #065f46;
            font-size: 0.85em;
        }

        .log-progress-text {
            color: #047857;
            font-weight: 500;
            font-size: 0.95em;
        }

        .portions-dropdown {
            position: absolute;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            min-width: 120px;
            overflow: hidden;
        }

        .portions-dropdown button {
            display: block;
            width: 100%;
            padding: 10px 16px;
            text-align: left;
            border: none;
            background: white;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        .portions-dropdown button:hover {
            background: #f0f9ff;
        }

        /* Portions Stepper Styles */
        .portions-stepper {
            position: fixed;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            z-index: 1000;
            padding: 12px 16px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .portions-stepper-label {
            font-size: 11px;
            color: #6b7280;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .portions-stepper-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .portions-step-btn {
            width: 36px;
            height: 36px;
            border: 2px solid #0891b2;
            background: white;
            color: #0891b2;
            font-size: 20px;
            font-weight: bold;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .portions-step-btn:hover {
            background: #0891b2;
            color: white;
        }

        .portions-step-btn:disabled {
            border-color: #d1d5db;
            color: #d1d5db;
            cursor: not-allowed;
        }

        .portions-step-btn:disabled:hover {
            background: white;
            color: #d1d5db;
        }

        .portions-value {
            min-width: 60px;
            text-align: center;
            font-size: 18px;
            font-weight: 600;
            color: #0891b2;
        }

        .portions-stepper-apply {
            width: 100%;
            padding: 8px 16px;
            background: #0891b2;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
            margin-top: 4px;
        }

        .portions-stepper-apply:hover {
            background: #0e7490;
        }

        .portions-presets {
            display: flex;
            gap: 6px;
            margin-top: 4px;
        }

        .portions-preset-btn {
            padding: 4px 10px;
            background: #f0f9ff;
            border: 1px solid #0891b2;
            border-radius: 4px;
            font-size: 12px;
            color: #0891b2;
            cursor: pointer;
            transition: all 0.2s;
        }

        .portions-preset-btn:hover {
            background: #0891b2;
            color: white;
        }

        .btn-favorite {
            background: transparent;
            color: #e53e3e;
            border: 2px solid #fed7d7;
            padding: 8px 14px;
            font-size: 1.1em;
        }

        .btn-favorite:hover {
            background: #fed7d7;
            transform: translateY(-2px);
        }

        .btn-favorite.active {
            background: #fed7d7;
            color: #c53030;
        }

        .modified-badge {
            display: inline-block;
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.7em;
            font-weight: 600;
            margin-left: 10px;
            vertical-align: middle;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .btn-reset {
            background: linear-gradient(135deg, #6b7280, #4b5563);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            margin-left: 10px;
        }

        .btn-reset:hover {
            background: linear-gradient(135deg, #4b5563, #374151);
            transform: translateY(-1px);
        }

        .modified-notice {
            background: linear-gradient(135deg, #fef3c7, #fde68a);
            border-left: 4px solid #f59e0b;
            padding: 12px 16px;
            margin-bottom: 20px;
            border-radius: 0 8px 8px 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .modified-notice p {
            margin: 0;
            color: #92400e;
            font-size: 0.9em;
        }

        .macro-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .macro-item {
            background: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid #e0e7ff;
        }

        .macro-label {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .macro-value {
            color: #0d9488;
            font-size: 1.5em;
            font-weight: 700;
        }

        .instructions {
            background: #fff4e6;
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #ffa726;
            margin-top: 15px;
        }

        .instructions-label {
            color: #e65100;
            font-weight: 600;
            margin-bottom: 8px;
            display: block;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            margin-top: 40px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn-primary {
            background: linear-gradient(135deg, #0d9488 0%, #0284c7 100%);
            color: white;
            padding: 15px 40px;
            font-size: 1.1em;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
            padding: 15px 40px;
            font-size: 1.1em;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        /* Grocery List Styles */
        .btn-grocery {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            padding: 15px 40px;
            font-size: 1.1em;
        }

        .btn-grocery:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(16, 185, 129, 0.4);
        }

        .grocery-modal-content {
            max-width: 600px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
            padding: 0 !important;
        }

        .grocery-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 2px solid #e2e8f0;
            background: white;
            flex-shrink: 0;
        }

        [data-theme="dark"] .grocery-header {
            background: #1e293b;
            border-color: #475569;
        }

        .grocery-header h2 {
            margin: 0;
            font-size: 1.5rem;
            color: #0f172a;
            font-weight: 700;
        }

        [data-theme="dark"] .grocery-header h2 {
            color: #f8fafc;
        }

        .grocery-progress {
            font-size: 0.95rem;
            color: #059669;
            font-weight: 600;
            background: #ecfdf5;
            padding: 6px 12px;
            border-radius: 20px;
        }

        [data-theme="dark"] .grocery-progress {
            background: #064e3b;
            color: #6ee7b7;
        }

        #groceryListContent {
            flex: 1;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            min-height: 200px;
            max-height: 50vh;
        }

        .grocery-category {
            margin-bottom: 0;
        }

        .grocery-category-header {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 14px 20px;
            background: #f1f5f9;
            font-weight: 700;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #334155;
            cursor: pointer;
            transition: background 0.2s;
            border-top: 1px solid #e2e8f0;
        }

        .grocery-category-header:hover {
            background: #e2e8f0;
        }

        [data-theme="dark"] .grocery-category-header {
            background: #334155;
            color: #e2e8f0;
            border-color: #475569;
        }

        [data-theme="dark"] .grocery-category-header:hover {
            background: #475569;
        }

        .grocery-category-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .grocery-items {
            padding: 0;
            background: white;
        }

        [data-theme="dark"] .grocery-items {
            background: #1e293b;
        }

        .grocery-item {
            display: flex;
            align-items: center;
            gap: 14px;
            padding: 16px 20px;
            border-bottom: 1px solid #e2e8f0;
            cursor: pointer;
            transition: background 0.15s;
            background: white;
        }

        .grocery-item:hover {
            background: #f0fdf4;
        }

        [data-theme="dark"] .grocery-item {
            border-color: #334155;
            background: #1e293b;
        }

        [data-theme="dark"] .grocery-item:hover {
            background: #334155;
        }

        .grocery-item.checked {
            opacity: 0.6;
            background: #f8fafc;
        }

        [data-theme="dark"] .grocery-item.checked {
            background: #0f172a;
        }

        .grocery-item.checked .grocery-item-text {
            text-decoration: line-through;
            color: #94a3b8;
        }

        .grocery-checkbox {
            width: 26px;
            height: 26px;
            border: 2px solid #94a3b8;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            transition: all 0.2s;
            font-size: 14px;
            font-weight: bold;
        }

        [data-theme="dark"] .grocery-checkbox {
            border-color: #64748b;
        }

        .grocery-item.checked .grocery-checkbox {
            background: #10b981;
            border-color: #10b981;
            color: white;
        }

        .grocery-item-text {
            flex: 1;
            color: #0f172a;
            font-size: 1rem;
            font-weight: 500;
        }

        [data-theme="dark"] .grocery-item-text {
            color: #f1f5f9;
        }

        .grocery-item-qty {
            font-weight: 700;
            color: #059669;
            margin-right: 4px;
        }

        [data-theme="dark"] .grocery-item-qty {
            color: #34d399;
        }

        .grocery-actions {
            padding: 16px 20px;
            border-top: 2px solid #e2e8f0;
            display: flex;
            gap: 12px;
            justify-content: space-between;
            background: white;
            flex-shrink: 0;
        }

        [data-theme="dark"] .grocery-actions {
            background: #1e293b;
            border-color: #475569;
        }

        .grocery-btn-clear {
            background: #fef2f2;
            color: #dc2626;
            border: none;
            padding: 12px 20px;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
            font-size: 0.95rem;
        }

        .grocery-btn-clear:hover {
            background: #fee2e2;
        }

        [data-theme="dark"] .grocery-btn-clear {
            background: #450a0a;
            color: #fca5a5;
        }

        .grocery-btn-done {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            padding: 12px 28px;
            border-radius: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.95rem;
        }

        .grocery-btn-done:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }

        .grocery-empty {
            text-align: center;
            padding: 60px 20px;
            color: #475569;
        }

        [data-theme="dark"] .grocery-empty {
            color: #94a3b8;
        }

        .grocery-empty-icon {
            font-size: 56px;
            margin-bottom: 16px;
        }

        .revise-section {
            margin-top: 15px;
            padding: 15px;
            background: white;
            border-radius: 10px;
        }

        .revise-input {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #0d9488;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 10px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes slideOut {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 20px;
            padding: 40px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            box-sizing: border-box;
            overflow: hidden;
        }

        .modal-header {
            text-align: center;
            margin-bottom: 25px;
        }

        .modal-header h2 {
            color: #0d9488;
            font-size: 1.8em;
            margin-bottom: 10px;
        }

        .share-link-container {
            background: #f8f9ff;
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #e0e7ff;
            margin-bottom: 20px;
            word-break: break-all;
        }

        .share-link {
            color: #0d9488;
            font-weight: 600;
            font-size: 0.95em;
        }

        .btn-copy {
            background: #0d9488;
            color: white;
            width: 100%;
            padding: 15px;
            font-size: 1.1em;
        }

        .btn-copy:hover {
            background: #5568d3;
        }

        .btn-close-modal {
            background: #6c757d;
            color: white;
            width: 100%;
            padding: 15px;
            font-size: 1.1em;
            margin-top: 10px;
        }

        .btn-close-modal:hover {
            background: #5a6268;
        }

        /* Custom Meal Modal Styles */
        .custom-meal-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .custom-meal-tab {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #e0e7ff;
            border-radius: 10px;
            background: #f8f9ff;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }

        .custom-meal-tab:hover {
            border-color: #0d9488;
        }

        .custom-meal-tab.active {
            background: #0d9488;
            color: white;
            border-color: #0d9488;
        }

        .custom-meal-tab-icon {
            font-size: 1.5em;
            display: block;
            margin-bottom: 5px;
        }

        .custom-meal-tab-label {
            font-size: 0.85em;
            font-weight: 600;
        }

        .custom-meal-panel {
            display: none;
        }

        .custom-meal-panel.active {
            display: block;
        }

        .custom-meal-input {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e0e7ff;
            border-radius: 10px;
            font-size: 1em;
            margin-bottom: 15px;
            box-sizing: border-box;
        }

        .custom-meal-input:focus {
            outline: none;
            border-color: #0d9488;
        }

        .custom-meal-textarea {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e0e7ff;
            border-radius: 10px;
            font-size: 1em;
            margin-bottom: 15px;
            min-height: 100px;
            resize: vertical;
            box-sizing: border-box;
            font-family: inherit;
        }

        .custom-meal-textarea:focus {
            outline: none;
            border-color: #0d9488;
        }

        .macro-inputs {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .macro-input-group {
            display: flex;
            flex-direction: column;
        }

        .macro-input-group label {
            font-size: 0.85em;
            color: #666;
            margin-bottom: 5px;
            font-weight: 600;
        }

        .macro-input-group input {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #e0e7ff;
            border-radius: 8px;
            font-size: 1em;
            text-align: center;
            box-sizing: border-box;
        }

        .macro-input-group input:focus {
            outline: none;
            border-color: #0d9488;
        }

        .custom-meal-hint {
            font-size: 0.8em;
            color: #888;
            margin-bottom: 15px;
            padding: 10px;
            background: #f8f9ff;
            border-radius: 8px;
        }

        .btn-submit-custom {
            background: #0d9488;
            color: white;
            width: 100%;
            padding: 15px;
            font-size: 1.1em;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
        }

        .btn-submit-custom:hover {
            background: #0b7a6e;
        }

        .btn-submit-custom:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        /* Food Search Styles - synced with planner.html */
        .food-search-container {
            position: relative;
            margin-bottom: 15px;
        }

        .food-search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #e0e7ff;
            border-top: none;
            border-radius: 0 0 10px 10px;
            max-height: 250px;
            overflow-y: auto;
            z-index: 100;
            display: none;
        }

        .food-search-results.active {
            display: block;
        }

        .food-search-item {
            padding: 10px 12px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
        }

        .food-search-item:hover {
            background: #f0fdf4;
        }

        .food-search-item:last-child {
            border-bottom: none;
        }

        .food-name {
            font-weight: 600;
            color: #333;
            margin-bottom: 2px;
        }

        .food-macros {
            font-size: 0.8em;
            color: #666;
        }

        .food-search-loading, .food-search-empty {
            padding: 15px;
            text-align: center;
            color: #888;
        }

        /* Selected Ingredients Styles - synced with planner.html */
        .selected-ingredients {
            margin-bottom: 15px;
        }

        .selected-ingredients-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #e0e7ff;
            margin-bottom: 10px;
            font-weight: 600;
            color: #333;
        }

        .ingredients-list {
            max-height: 150px;
            overflow-y: auto;
        }

        .ingredient-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: #f8fafc;
            border-radius: 8px;
            margin-bottom: 6px;
        }

        .ingredient-name {
            flex: 1;
            font-size: 0.9em;
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: normal;
        }

        .ingredient-qty {
            width: 60px;
            padding: 4px 8px;
            border: 1px solid #e0e7ff;
            border-radius: 6px;
            text-align: center;
            font-size: 0.9em;
            -moz-appearance: textfield;
        }

        .ingredient-qty::-webkit-outer-spin-button,
        .ingredient-qty::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .qty-stepper {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .qty-step-btn {
            width: 28px;
            height: 28px;
            border: 1px solid #e0e7ff;
            border-radius: 6px;
            background: white;
            color: #6366f1;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
            user-select: none;
        }

        .qty-step-btn:hover {
            background: #6366f1;
            color: white;
            border-color: #6366f1;
        }

        .qty-step-btn:active {
            transform: scale(0.95);
        }

        .qty-step-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .ingredient-unit {
            font-size: 0.85em;
            color: #666;
        }

        .ingredient-unit-select {
            padding: 4px 6px;
            border: 1px solid #e0e7ff;
            border-radius: 6px;
            font-size: 0.8em;
            background: white;
            cursor: pointer;
            max-width: 90px;
        }

        .ingredient-unit-select:focus {
            outline: none;
            border-color: #6366f1;
        }

        .ingredient-remove {
            background: #fee2e2;
            border: none;
            color: #dc2626;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            font-weight: bold;
        }

        .no-ingredients {
            text-align: center;
            color: #888;
            padding: 15px;
            font-style: italic;
        }

        /* Calculated Totals Styles - synced with planner.html */
        .calculated-totals {
            background: linear-gradient(135deg, #ecfdf5 0%, #d1fae5 100%);
            border: 2px solid #10b981;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .totals-header {
            font-weight: 700;
            color: #065f46;
            margin-bottom: 10px;
            font-size: 0.9em;
        }

        .totals-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            text-align: center;
        }

        .total-item {
            background: white;
            padding: 8px;
            border-radius: 8px;
        }

        .total-value {
            font-weight: 700;
            color: #0d9488;
            font-size: 1.1em;
        }

        .total-label {
            font-size: 0.75em;
            color: #666;
        }

        .btn-share {
            background: #28a745;
            color: white;
            padding: 15px 40px;
            font-size: 1.1em;
        }

        .btn-share:hover {
            background: #218838;
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(40, 167, 69, 0.4);
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }

            .header h1 {
                font-size: 1.8em;
            }

            .macro-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .modal-content {
                padding: 25px;
            }

            /* 2x2 grid for daily targets on mobile */
            .info-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
            }

            .info-item {
                padding: 12px;
            }

            .info-label {
                font-size: 0.8em;
                margin-bottom: 3px;
            }

            .info-value {
                font-size: 1.1em;
            }
        }

        /* Saved Meals Styles */
        .saved-meals-list {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 15px;
        }

        .saved-meal-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            margin-bottom: 8px;
            background: #fafafa;
        }

        .saved-meal-item:hover {
            background: #f0fdf4;
            border-color: #86efac;
        }

        .saved-meal-info {
            flex: 1;
            min-width: 0;
        }

        .saved-meal-name {
            font-weight: 600;
            color: #1f2937;
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: normal;
        }

        .saved-meal-macros {
            font-size: 0.8em;
            color: #6b7280;
            margin-top: 2px;
        }

        .saved-meal-actions {
            display: flex;
            gap: 8px;
            margin-left: 10px;
        }

        .btn-use-saved {
            padding: 6px 12px;
            background: linear-gradient(135deg, #0d9488 0%, #0891b2 100%);
            border: none;
            border-radius: 6px;
            color: white;
            font-size: 0.85em;
            cursor: pointer;
        }

        .btn-delete-saved {
            padding: 6px 10px;
            background: #fee2e2;
            border: none;
            border-radius: 6px;
            color: #dc2626;
            font-size: 0.85em;
            cursor: pointer;
        }

        .btn-delete-saved:hover {
            background: #fecaca;
        }

        .btn-edit-saved {
            padding: 6px 10px;
            background: #dbeafe;
            border: none;
            border-radius: 6px;
            color: #2563eb;
            font-size: 0.85em;
            cursor: pointer;
        }

        .btn-edit-saved:hover {
            background: #bfdbfe;
        }

        .no-saved-meals {
            text-align: center;
            padding: 30px;
            color: #9ca3af;
        }

        .save-for-later-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 15px 0;
            padding: 10px;
            background: #fffbeb;
            border: 1px solid #fcd34d;
            border-radius: 8px;
        }

        .save-for-later-row input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .save-for-later-row label {
            font-size: 0.9em;
            color: #92400e;
            cursor: pointer;
        }

        /* Bottom Navigation Bar */
        .bottom-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: white;
            border-top: 1px solid #e2e8f0;
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 8px 0;
            padding-bottom: calc(8px + env(safe-area-inset-bottom));
            z-index: 1000;
            box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.08);
        }

        [data-theme="dark"] .bottom-nav {
            background: #1e293b;
            border-color: #334155;
        }

        .bottom-nav-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-decoration: none;
            color: #64748b;
            padding: 8px 16px;
            border-radius: 12px;
            transition: all 0.2s ease;
            min-width: 64px;
            -webkit-tap-highlight-color: transparent;
        }

        .bottom-nav-item:active {
            transform: scale(0.95);
        }

        .bottom-nav-item.active {
            color: #0d9488;
        }

        .bottom-nav-item.active .nav-icon {
            background: rgba(13, 148, 136, 0.1);
        }

        [data-theme="dark"] .bottom-nav-item {
            color: #94a3b8;
        }

        [data-theme="dark"] .bottom-nav-item.active {
            color: #14b8a6;
        }

        .nav-icon {
            width: 48px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            border-radius: 16px;
            margin-bottom: 2px;
        }

        .nav-label {
            font-size: 11px;
            font-weight: 600;
        }

        /* Add padding for bottom nav */
        .container {
            padding-bottom: 100px;
        }

        /* ===== DARK MODE STYLES ===== */
        [data-theme="dark"] body {
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
        }

        [data-theme="dark"] .container {
            background: #1e293b;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }

        [data-theme="dark"] .header h1 {
            color: #2dd4bf;
        }

        [data-theme="dark"] .back-btn {
            color: #2dd4bf !important;
        }

        [data-theme="dark"] .client-info {
            background: #0f172a;
        }

        [data-theme="dark"] .section-title {
            color: #2dd4bf;
            border-color: #334155;
        }

        .protocol-description {
            color: #666;
            margin-bottom: 15px;
        }

        [data-theme="dark"] .protocol-description {
            color: #94a3b8;
        }

        [data-theme="dark"] .info-item {
            background: #334155;
        }

        [data-theme="dark"] .info-label {
            color: #94a3b8;
        }

        [data-theme="dark"] .info-value {
            color: #f1f5f9;
        }

        [data-theme="dark"] .day-card {
            background: #0f172a;
            border-color: #334155;
        }

        [data-theme="dark"] .day-header {
            background: linear-gradient(135deg, #0d9488 0%, #0284c7 100%);
        }

        [data-theme="dark"] .day-totals {
            background: #1e293b;
            border-color: #334155;
        }

        [data-theme="dark"] .day-totals h4 {
            color: #f1f5f9;
        }

        [data-theme="dark"] .total-item {
            color: #94a3b8;
        }

        [data-theme="dark"] .total-value {
            color: #f1f5f9;
        }

        [data-theme="dark"] .meal-card {
            background: #334155;
            border-color: #475569;
        }

        [data-theme="dark"] .meal-name {
            color: #f1f5f9;
        }

        [data-theme="dark"] .meal-details {
            color: #94a3b8;
        }

        [data-theme="dark"] .macro-item {
            background: #1e293b;
            color: #f1f5f9;
        }

        [data-theme="dark"] .macro-label {
            color: #94a3b8;
        }

        [data-theme="dark"] .meal-recipe,
        [data-theme="dark"] .meal-instructions {
            background: #1e293b;
            border-color: #475569;
            color: #cbd5e1;
        }

        [data-theme="dark"] .meal-recipe h5,
        [data-theme="dark"] .meal-instructions h5 {
            color: #2dd4bf;
        }

        [data-theme="dark"] .recipe-ingredients li {
            color: #cbd5e1;
        }

        [data-theme="dark"] .action-buttons .btn {
            background: linear-gradient(135deg, #0d9488 0%, #0284c7 100%);
            color: white;
        }

        [data-theme="dark"] .loading {
            color: #94a3b8;
        }

        [data-theme="dark"] .error-message {
            background: rgba(239, 68, 68, 0.2);
            color: #fca5a5;
        }

        [data-theme="dark"] .btn-reset {
            background: #334155;
            color: #f1f5f9;
        }
    </style>
    <script src="https://unpkg.com/lucide@0.312.0/dist/umd/lucide.min.js" onload="lucide.createIcons()"></script>
</head>
<body>
    <div class="container">
        <div class="header" style="position: relative;">
            <a href="#" id="backButton" class="back-btn" style="display: flex; align-items: center; gap: 6px; color: #0d9488; text-decoration: none; font-weight: 600; font-size: 0.95em; margin-bottom: 10px;">
                <span style="font-size: 1.2em;">‚Üê</span> Back
            </a>
            <h1 id="planHeader">Your Meal Plan</h1>
            <button id="resetToOriginalBtn" class="btn-reset" onclick="resetToOriginal()" style="display: none;">‚Ü∫ Reset to Original</button>
        </div>

        <div class="client-info">
            <div class="section-title">Your Daily Targets</div>
            <div class="info-grid">
                <div class="info-item">
                    <div class="info-label">Calories</div>
                    <div class="info-value" id="totalCalories">Loading...</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Protein</div>
                    <div class="info-value" id="totalProtein">Loading...</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Carbs</div>
                    <div class="info-value" id="totalCarbs">Loading...</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Fat</div>
                    <div class="info-value" id="totalFat">Loading...</div>
                </div>
            </div>
        </div>

        <!-- Log Entire Plan to Diary Button (Client View Only) -->
        <div id="logEntirePlanSection" class="log-entire-plan-section" style="display: none;">
            <button id="logEntirePlanBtn" class="btn btn-log-entire-plan" onclick="logEntirePlanToDiary()">
                <span class="btn-icon">üìã</span>
                <span class="btn-text">Log Entire Plan to Diary</span>
            </button>
            <p class="log-plan-hint">Log all meals from this plan to today's food diary</p>
        </div>

        <!-- Supplement Protocol Section (Client View) -->
        <div id="protocolSection" class="client-info" style="display: none; margin-top: 20px;">
            <div class="section-title" style="cursor: pointer;" onclick="toggleProtocolSection()">
                <span id="protocolToggleIcon">‚ñº</span> Supplement Protocol
            </div>
            <div id="protocolContent">
                <p class="protocol-description">Your supplement and protocol schedule from your coach.</p>
                <div id="protocolsList"></div>
            </div>
        </div>

        <div id="mealsContainer"></div>

        <div class="action-buttons">
            <button id="groceryListBtn" class="btn btn-grocery" onclick="showGroceryListModal()">üõí Grocery List</button>
            <button class="btn btn-primary" onclick="showMealPrepGuide()" style="background:#ff6b6b;">üìã Meal Prep Guide</button>
            <button class="btn btn-primary" onclick="downloadPDF()">üì• Download PDF</button>
            <button id="sharePlanBtn" class="btn btn-share" onclick="generateShareLink()" style="display: none;">üîó Share Plan Link</button>
            <button id="generateNewBtn" class="btn btn-secondary" onclick="window.location.href='planner.html'" style="display: none;">‚Üê Generate New Plan</button>
        </div>
    </div>

    <!-- Meal Prep Guide Modal -->
    <div id="mealPrepModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 900px; max-height: 85vh; overflow-y: auto;">
            <div class="modal-header">
                <h2>üìã Meal Prep Guide</h2>
                <button class="close-btn" onclick="closeMealPrepModal()">&times;</button>
            </div>
            <div id="mealPrepContent" style="padding: 20px;">
                <div style="text-align: center; padding: 40px;">
                    <div class="loader" style="margin: 0 auto 20px;"></div>
                    <p style="color: #666;">Generating your comprehensive meal prep guide...</p>
                </div>
            </div>
            <div style="padding: 20px; border-top: 1px solid #ddd; text-align: right;">
                <button class="btn btn-secondary" onclick="closeMealPrepModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Recipe Modal -->
    <div id="recipeModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 700px; max-height: 80vh; overflow-y: auto;">
            <div class="modal-header">
                <h2 id="recipeTitle">üìñ Recipe</h2>
                <button class="close-btn" onclick="closeRecipeModal()">&times;</button>
            </div>
            <div id="recipeContent" style="padding: 20px;">
                <div style="text-align: center; padding: 40px;">
                    <div class="loader" style="margin: 0 auto 20px;"></div>
                    <p style="color: #666;">Loading recipe...</p>
                </div>
            </div>
            <div style="padding: 20px; border-top: 1px solid #ddd; text-align: right;">
                <button class="btn btn-secondary" onclick="closeRecipeModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Share Modal -->
    <div id="shareModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üîó Share Your Meal Plan</h2>
                <p style="color: #666;">Share this link with your client</p>
            </div>
            <div class="share-link-container">
                <div class="share-link" id="shareLinkText">Generating link...</div>
            </div>
            <button class="btn btn-copy" onclick="copyShareLink()">üìã Copy Link</button>
            <button class="btn btn-close-modal" onclick="closeShareModal()">Close</button>
        </div>
    </div>

    <!-- Grocery List Modal -->
    <div id="groceryListModal" class="modal-overlay">
        <div class="modal-content grocery-modal-content" style="padding: 0;">
            <div class="grocery-header">
                <h2>üõí Shopping List</h2>
                <span class="grocery-progress" id="groceryProgress">0/0 items</span>
            </div>
            <div id="groceryListContent">
                <!-- Grocery items will be rendered here -->
            </div>
            <div class="grocery-actions">
                <button class="grocery-btn-clear" onclick="clearGroceryChecks()">Clear All</button>
                <button class="grocery-btn-done" onclick="closeGroceryListModal()">Done</button>
            </div>
        </div>
    </div>

    <!-- Custom Meal Modal -->
    <div id="customMealModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 450px; max-height: 90vh; overflow-y: auto;">
            <div class="modal-header">
                <h2>üéØ Custom Meal</h2>
                <p style="color: #666;">Create your own meal</p>
            </div>

            <!-- Tabs -->
            <div class="custom-meal-tabs">
                <div class="custom-meal-tab active" onclick="switchCustomMealTab('calculate')">
                    <span class="custom-meal-tab-icon">üßÆ</span>
                    <span class="custom-meal-tab-label">Calculate</span>
                </div>
                <div class="custom-meal-tab" onclick="switchCustomMealTab('manual')">
                    <span class="custom-meal-tab-icon">‚úèÔ∏è</span>
                    <span class="custom-meal-tab-label">Manual</span>
                </div>
                <div class="custom-meal-tab" onclick="switchCustomMealTab('saved')">
                    <span class="custom-meal-tab-icon">üìö</span>
                    <span class="custom-meal-tab-label">My Saved</span>
                </div>
            </div>

            <!-- Calculate Panel -->
            <div id="calculatePanel" class="custom-meal-panel active">
                <div class="custom-meal-hint">
                    üí° Search our food database for ingredients. Add them with quantities to calculate macros.
                </div>

                <!-- Food Search Input -->
                <div class="food-search-container">
                    <input
                        type="text"
                        id="foodSearchInput"
                        class="custom-meal-input"
                        placeholder="Search foods (e.g., chicken breast, rice, Quest bar)..."
                        oninput="handleFoodSearch(this.value)"
                        autocomplete="off"
                        style="margin-bottom: 0;"
                    >
                    <div id="foodSearchResults" class="food-search-results"></div>
                </div>

                <!-- Selected Ingredients List -->
                <div class="selected-ingredients">
                    <div class="selected-ingredients-header">
                        <span>Selected Ingredients</span>
                        <span id="ingredientCount">(0)</span>
                    </div>
                    <div id="ingredientsList" class="ingredients-list">
                        <div class="no-ingredients">No ingredients added yet</div>
                    </div>
                </div>

                <!-- Calculated Totals -->
                <div class="calculated-totals">
                    <div class="totals-header">üìä Calculated Totals</div>
                    <div class="totals-grid">
                        <div class="total-item">
                            <div class="total-value" id="calcTotalCalories">0</div>
                            <div class="total-label">Calories</div>
                        </div>
                        <div class="total-item">
                            <div class="total-value" id="calcTotalProtein">0g</div>
                            <div class="total-label">Protein</div>
                        </div>
                        <div class="total-item">
                            <div class="total-value" id="calcTotalCarbs">0g</div>
                            <div class="total-label">Carbs</div>
                        </div>
                        <div class="total-item">
                            <div class="total-value" id="calcTotalFat">0g</div>
                            <div class="total-label">Fat</div>
                        </div>
                    </div>
                </div>

                <!-- Meal Name -->
                <input
                    type="text"
                    id="calculatedMealName"
                    class="custom-meal-input"
                    placeholder="Meal name (optional - auto-generated if blank)"
                >

                <!-- Instructions -->
                <textarea
                    id="calculatedMealInstructions"
                    class="custom-meal-input"
                    placeholder="Cooking instructions (optional)"
                    rows="3"
                    style="resize: vertical; min-height: 60px;"
                ></textarea>

                <div class="save-for-later-row">
                    <input type="checkbox" id="saveCalculatedForLater">
                    <label for="saveCalculatedForLater">üíæ Save this meal for future use</label>
                </div>

                <button class="btn-submit-custom" onclick="submitCalculatedMeal()" id="createCalculatedMealBtn" disabled>
                    üßÆ Create Meal
                </button>
            </div>

            <!-- Manual Panel -->
            <div id="manualPanel" class="custom-meal-panel">
                <div class="custom-meal-hint">
                    üí° Enter the meal name and macros directly. Use nutrition labels or apps like MyFitnessPal.
                </div>
                <input
                    type="text"
                    id="customMealName"
                    class="custom-meal-input"
                    placeholder="Meal name (e.g., Protein Shake, Chipotle Bowl)"
                >
                <div class="macro-inputs">
                    <div class="macro-input-group">
                        <label>Calories</label>
                        <input type="number" id="customMealCalories" placeholder="0">
                    </div>
                    <div class="macro-input-group">
                        <label>Protein (g)</label>
                        <input type="number" id="customMealProtein" placeholder="0">
                    </div>
                    <div class="macro-input-group">
                        <label>Carbs (g)</label>
                        <input type="number" id="customMealCarbs" placeholder="0">
                    </div>
                    <div class="macro-input-group">
                        <label>Fat (g)</label>
                        <input type="number" id="customMealFat" placeholder="0">
                    </div>
                </div>
                <textarea
                    id="customMealInstructions"
                    class="custom-meal-input"
                    placeholder="Cooking instructions (optional)"
                    rows="3"
                    style="resize: vertical; min-height: 60px;"
                ></textarea>

                <div class="save-for-later-row">
                    <input type="checkbox" id="saveManualForLater">
                    <label for="saveManualForLater">üíæ Save this meal for future use</label>
                </div>

                <button class="btn-submit-custom" onclick="submitManualMeal()">
                    ‚úÖ Create Meal
                </button>
            </div>

            <!-- Saved Meals Panel -->
            <div id="savedPanel" class="custom-meal-panel">
                <div class="custom-meal-hint">
                    üìö Your saved custom meals. Click "Use" to add to your plan.
                </div>
                <div id="savedMealsList" class="saved-meals-list">
                    <div class="no-saved-meals">No saved meals yet. Create a meal and check "Save for future use" to add it here.</div>
                </div>
            </div>

            <button class="btn btn-close-modal" onclick="closeCustomMealModal()" style="margin-top: 15px;">Cancel</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
        // Initialize Supabase client
        const SUPABASE_URL = 'https://qewqcjzlfqamqwbccapr.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFld3FjanpsZnFhbXF3YmNjYXByIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM2OTg0NzAsImV4cCI6MjA3OTI3NDQ3MH0.mQnMC33O88oLkLLGWD2oG-oaSHGI-NfHmtQCZxnxSLs';

        const { createClient } = supabase;
        const supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        const API_ENDPOINT = '/.netlify/functions/generate-meal-plan';
        const SAVE_PLAN_ENDPOINT = '/.netlify/functions/save-shared-plan';
        const GET_PLAN_ENDPOINT = '/.netlify/functions/get-shared-plan';
        const TOGGLE_FAVORITE_ENDPOINT = '/.netlify/functions/toggle-favorite';
        const SAVE_CLIENT_MODIFICATION_ENDPOINT = '/.netlify/functions/save-client-modification';
        const RESET_CLIENT_MODIFICATION_ENDPOINT = '/.netlify/functions/reset-client-modification';
        const CLIENT_PROTOCOLS_ENDPOINT = '/.netlify/functions/client-protocols';
        let currentPlan = null;
        let clientFavorites = [];
        let currentShareUrl = '';
        let realtimeChannel = null;
        let currentPlanId = null;
        let currentClientId = null; // Track client ID for saving modifications
        let currentCoachId = null; // Track coach ID for coach view
        let isClientModified = false; // Track if client has modified the plan
        let isClientView = false; // Track if viewing as client

        // Client permissions (default to true for coaches, loaded for clients)
        let clientPermissions = {
            canChangeMeals: true,
            canReviseMeals: true,
            canCustomMeals: true,
            canRequestNewPlan: true
        };

        // Store previous meal states for undo functionality - persisted to localStorage
        // Use same key as planner.html so undo states are shared between pages
        const UNDO_STATES_KEY = 'plannerUndoStates';
        let previousMealStates = {};

        // Load undo states from localStorage
        function loadUndoStates() {
            try {
                const stored = localStorage.getItem(UNDO_STATES_KEY);
                if (stored) {
                    previousMealStates = JSON.parse(stored);
                    console.log('üìÇ Loaded undo states from localStorage');
                }
            } catch (e) {
                console.error('Error loading undo states:', e);
            }
        }

        // Save undo states to localStorage
        function saveUndoStates() {
            try {
                localStorage.setItem(UNDO_STATES_KEY, JSON.stringify(previousMealStates));
            } catch (e) {
                console.error('Error saving undo states:', e);
            }
        }

        // Load undo states on page load
        loadUndoStates();

        // Custom meal modal state
        let currentCustomMealIndex = null;
        let currentCustomMealDayIndex = null;
        let currentCustomMealMealIndex = null;

        // Food search state - synced with planner.html
        const FOOD_SEARCH_ENDPOINT = '/.netlify/functions/usda-search';
        let customMealSelectedIngredients = [];
        let foodSearchTimeout = null;
        let foodSearchResults = [];

        // Simple notification function
        function showNotification(message, type = 'info') {
            // Create notification element
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 15px 25px;
                border-radius: 8px;
                color: white;
                font-weight: 500;
                z-index: 10000;
                animation: slideIn 0.3s ease;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            `;
            notification.style.background = type === 'success' ? '#10b981' : type === 'error' ? '#ef4444' : '#3b82f6';
            notification.textContent = message;
            document.body.appendChild(notification);

            // Auto-remove after 3 seconds
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        // Helper function to escape HTML and convert URLs to clickable links
        function linkifyText(text) {
            if (!text) return '';

            // First escape HTML to prevent XSS
            const escaped = text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');

            // URL regex pattern - matches http, https, and www URLs
            const urlPattern = /(\b(https?:\/\/|www\.)[^\s<]+[^\s<.,;:!?"'\])}>])/gi;

            // Convert URLs to clickable links
            return escaped.replace(urlPattern, (url) => {
                let href = url;
                // Add https:// if URL starts with www.
                if (url.toLowerCase().startsWith('www.')) {
                    href = 'https://' + url;
                }
                return `<a href="${href}" target="_blank" rel="noopener noreferrer" style="color: #0284c7; text-decoration: underline;">${url}</a>`;
            });
        }

        // Detect if page was loaded from back/forward cache and force reload
        window.addEventListener('pageshow', function(event) {
            if (event.persisted) {
                // Page was loaded from bfcache (back/forward cache)
                console.log('Page loaded from cache, forcing reload...');
                window.location.reload();
            }
        });

        // Load meal plan
        document.addEventListener('DOMContentLoaded', async function() {
            // Check URL parameters
            const urlParams = new URLSearchParams(window.location.search);
            const shareId = urlParams.get('share');
            const planId = urlParams.get('planId');
            const clientView = urlParams.get('clientView') === 'true';
            const fromClientId = urlParams.get('fromClient');

            // Set back button URL based on view type
            const backButton = document.getElementById('backButton');
            if (fromClientId) {
                // Coach viewing from client profile - go back to client profile
                backButton.href = `client-profile.html?clientId=${fromClientId}`;
            } else if (clientView || shareId) {
                backButton.href = 'client-dashboard.html';
            } else {
                backButton.href = 'dashboard.html';
            }

            if (shareId) {
                // Load shared plan from database (client view)
                loadSharedPlan(shareId);
            } else if (planId) {
                // Load plan from database by ID (coach or client viewing)
                await loadCoachPlan(planId, clientView);
            } else {
                // Load from localStorage (newly generated plan)
                const planData = localStorage.getItem('currentMealPlan');

                if (!planData) {
                    alert('No meal plan found. Redirecting...');
                    window.location.href = 'planner.html';
                    return;
                }

                try {
                    currentPlan = JSON.parse(planData);
                    console.log('Loaded plan from localStorage:', currentPlan);

                    // Show coach-only buttons
                    document.getElementById('sharePlanBtn').style.display = 'inline-block';
                    document.getElementById('generateNewBtn').style.display = 'inline-block';

                    displayMealPlan();
                } catch (error) {
                    console.error('Error loading plan:', error);
                    alert('Error loading plan. Please generate a new one.');
                    window.location.href = 'planner.html';
                }
            }
        });

        // Load shared plan from database
        async function loadSharedPlan(shareId) {
            try {
                console.log('üì• Loading shared plan:', shareId);

                const response = await fetch(`${GET_PLAN_ENDPOINT}?shareId=${shareId}`);

                if (!response.ok) {
                    throw new Error('Failed to load shared plan');
                }

                const data = await response.json();
                currentPlan = data.planData;

                console.log('‚úÖ Loaded shared plan:', currentPlan);

                // Also save to localStorage for offline access
                localStorage.setItem('currentMealPlan', JSON.stringify(currentPlan));

                displayMealPlan();

                // Update header with client name
                const clientName = currentPlan.clientName || 'Client';
                const mealCount = currentPlan.meals ? currentPlan.meals.length : 0;
                const planText = mealCount > 1 ? 'Meal Plans' : 'Meal Plan';
                document.getElementById('planHeader').textContent = `üî• ${clientName}'s ${planText}`;

                // Try to get client info for shared plan (if logged in as client)
                try {
                    const { data: { session } } = await supabaseClient.auth.getSession();
                    if (session) {
                        const { data: clientData } = await supabaseClient
                            .from('clients')
                            .select('id, coach_id')
                            .eq('user_id', session.user.id)
                            .single();

                        if (clientData) {
                            currentClientId = clientData.id;
                            currentCoachId = clientData.coach_id;
                            isClientView = true;
                            // Show "Log Entire Plan" button for logged-in clients
                            document.getElementById('logEntirePlanSection').style.display = 'block';
                        }
                    }
                } catch (e) {
                    console.log('Not logged in as client for shared plan');
                }

            } catch (error) {
                console.error('‚ùå Error loading shared plan:', error);
                alert('Failed to load shared plan. The link may be invalid or expired.');
                window.location.href = 'planner.html';
            }
        }

        // Load coach plan from database by ID
        async function loadCoachPlan(planId, clientView = false) {
            // Store in global variable
            isClientView = clientView;

            try {
                console.log('Loading plan:', planId, 'Client view:', isClientView);

                // Try to refresh the session to get a fresh token
                const { data: refreshData, error: refreshError } = await supabaseClient.auth.refreshSession();

                let session = null;

                // Check if refresh was successful
                if (refreshError) {
                    console.error('Session refresh failed:', refreshError);
                    // If refresh fails, try to get existing session as fallback
                    const { data: { session: existingSession } } = await supabaseClient.auth.getSession();
                    if (!existingSession) {
                        alert('Please log in to view this plan.');
                        const redirectUrl = isClientView ? 'client-login.html' : 'index.html';
                        window.location.href = redirectUrl;
                        return;
                    }
                    session = existingSession;
                } else {
                    session = refreshData?.session;
                }

                // Double-check we have a valid session
                if (!session || !session.access_token) {
                    console.error('No valid session after refresh');
                    alert('Please log in to view this plan.');
                    const redirectUrl = isClientView ? 'client-login.html' : 'index.html';
                    window.location.href = redirectUrl;
                    return;
                }

                const currentUser = session.user;
                let query = supabaseClient
                    .from('coach_meal_plans')
                    .select('*')
                    .eq('id', planId);

                if (isClientView) {
                    // For client view, verify the client owns this plan
                    // Use * to avoid errors if permission columns don't exist yet
                    const { data: clientData, error: clientError } = await supabaseClient
                        .from('clients')
                        .select('*')
                        .eq('user_id', currentUser.id)
                        .single();

                    if (clientError || !clientData) {
                        console.error('Client lookup error:', clientError);
                        alert('Client account not found. Please contact your coach.');
                        window.location.href = 'client-login.html';
                        return;
                    }

                    // Store client ID and coach ID for saving modifications later
                    currentClientId = clientData.id;
                    currentCoachId = clientData.coach_id;

                    // Load client permissions (default to true if columns don't exist or not set)
                    clientPermissions = {
                        canChangeMeals: clientData.can_change_meals !== false,
                        canReviseMeals: clientData.can_revise_meals !== false,
                        canCustomMeals: clientData.can_custom_meals !== false,
                        canRequestNewPlan: clientData.can_request_new_plan !== false
                    };
                    console.log('üìã Client permissions loaded:', clientPermissions);

                    // Load favorites for the client
                    await loadFavorites(clientData.id);

                    // Load saved meals for the client
                    await loadSavedMeals();

                    // Load supplement protocols for the client
                    await loadClientProtocols(clientData.id, clientData.coach_id);

                    query = query.eq('client_id', clientData.id);
                } else {
                    // For coach view, verify the coach owns this plan
                    currentCoachId = currentUser.id;

                    // Load saved meals for the coach
                    await loadSavedMeals();

                    query = query.eq('coach_id', currentUser.id);
                }

                const { data, error } = await query.single();

                if (error) {
                    console.error('Supabase error:', error);
                    throw new Error('Failed to load plan');
                }

                if (!data) {
                    throw new Error('Plan not found');
                }

                console.log('Loaded plan:', data);
                currentPlanId = planId;

                // For client view: Use client_modified_data if it exists (client's personalized version)
                // Otherwise use plan_data (coach's original)
                let planData;
                console.log('üîç Plan data check:', {
                    isClientView: isClientView,
                    hasClientModifiedData: !!data.client_modified_data,
                    clientModifiedDataType: typeof data.client_modified_data
                });
                if (isClientView && data.client_modified_data) {
                    console.log('üìù Loading CLIENT MODIFIED version of plan');
                    planData = data.client_modified_data;
                    isClientModified = true;
                } else {
                    console.log('üìã Loading ORIGINAL coach plan');
                    planData = data.plan_data;
                    isClientModified = false;
                }

                // FIXED: Store multi-day structure instead of flattening
                if (planData.currentPlan && Array.isArray(planData.currentPlan)) {
                    // Multi-day plan structure - keep it organized by day
                    // Get nutrition from top-level OR from first day's targets
                    const dayTargets = planData.currentPlan[0]?.targets || {};
                    const nutrition = {
                        calories: planData.calories || dayTargets.calories || 0,
                        protein: planData.protein || dayTargets.protein || 0,
                        carbs: planData.carbs || dayTargets.carbs || 0,
                        fat: planData.fat || dayTargets.fat || 0
                    };
                    console.log('üìä Extracted nutrition for Daily Targets:', nutrition);

                    currentPlan = {
                        planId: data.id, // Store the coach plan ID for linking shared plans
                        clientName: planData.clientName || data.client_name,
                        preferences: planData.preferences || {},
                        multiDay: true,
                        days: planData.currentPlan, // Store all days with structure
                        nutrition: nutrition,
                        coachNotes: data.coach_notes || null
                    };
                } else {
                    // Fallback for old single-day format
                    currentPlan = {
                        planId: data.id, // Store the coach plan ID for linking shared plans
                        clientName: planData.clientName || data.client_name,
                        preferences: planData.preferences || {},
                        meals: planData.meals || [],
                        nutrition: planData.nutrition || {},
                        coachNotes: data.coach_notes || null
                    };
                }

                console.log('Transformed plan:', currentPlan);

                // Show coach-only buttons (only for coach view)
                if (!isClientView) {
                    document.getElementById('sharePlanBtn').style.display = 'inline-block';
                    document.getElementById('generateNewBtn').style.display = 'inline-block';
                }

                displayMealPlan();

                // Show "Log Entire Plan" button for client view
                if (isClientView) {
                    document.getElementById('logEntirePlanSection').style.display = 'block';
                }

                // Show modified indicator and reset button if client has modified the plan
                if (isClientModified) {
                    updateModifiedIndicator();
                    document.getElementById('resetToOriginalBtn').style.display = 'inline-block';
                }

                // Update header with client name
                const clientName = currentPlan.clientName || 'Client';
                const mealCount = currentPlan.meals ? currentPlan.meals.length : 0;
                const planText = mealCount > 1 ? 'Meal Plans' : 'Meal Plan';
                if (isClientView) {
                    document.getElementById('planHeader').textContent = `Your ${planText}`;
                } else {
                    document.getElementById('planHeader').textContent = `${clientName}'s ${planText}`;
                }

                // Set up real-time subscription for automatic updates
                setupRealtimeSubscription(planId, isClientView);

            } catch (error) {
                console.error('Error loading plan:', error);
                alert('Failed to load plan. Please try again.');
                const redirectUrl = isClientView ? 'client-dashboard.html' : 'dashboard.html';
                window.location.href = redirectUrl;
            }
        }

        function setupRealtimeSubscription(planId, isClientView) {
            // Clean up existing subscription if any
            if (realtimeChannel) {
                supabaseClient.removeChannel(realtimeChannel);
            }

            // Subscribe to changes for this specific plan
            realtimeChannel = supabaseClient
                .channel(`plan_${planId}`)
                .on(
                    'postgres_changes',
                    {
                        event: '*', // Listen to all events (INSERT, UPDATE, DELETE)
                        schema: 'public',
                        table: 'coach_meal_plans',
                        filter: `id=eq.${planId}`
                    },
                    (payload) => {
                        console.log('Real-time update received:', payload);
                        handlePlanUpdate(payload, isClientView);
                    }
                )
                .subscribe((status) => {
                    console.log('Realtime subscription status:', status);
                });
        }

        async function handlePlanUpdate(payload, isClientView) {
            const { eventType, new: newRecord } = payload;

            if (eventType === 'DELETE') {
                // Plan was deleted by coach
                console.log('Plan deleted');
                alert('This meal plan has been removed by your coach.');
                const redirectUrl = isClientView ? 'client-dashboard.html' : 'dashboard.html';
                window.location.href = redirectUrl;
            } else if (eventType === 'UPDATE') {
                // Plan was updated - reload and display
                console.log('Plan updated:', newRecord);

                const planData = newRecord.plan_data;

                // Update the currentPlan with new data
                if (planData.currentPlan && Array.isArray(planData.currentPlan)) {
                    // Get nutrition from top-level OR from first day's targets
                    const dayTargets = planData.currentPlan[0]?.targets || {};
                    const nutrition = {
                        calories: planData.calories || dayTargets.calories || 0,
                        protein: planData.protein || dayTargets.protein || 0,
                        carbs: planData.carbs || dayTargets.carbs || 0,
                        fat: planData.fat || dayTargets.fat || 0
                    };
                    currentPlan = {
                        planId: newRecord.id,
                        clientName: planData.clientName || newRecord.client_name,
                        preferences: planData.preferences || {},
                        multiDay: true,
                        days: planData.currentPlan,
                        nutrition: nutrition
                    };
                } else {
                    currentPlan = {
                        planId: newRecord.id,
                        clientName: planData.clientName || newRecord.client_name,
                        preferences: planData.preferences || {},
                        meals: planData.meals || [],
                        nutrition: planData.nutrition || {}
                    };
                }

                // Refresh the display with updated data
                displayMealPlan();

                console.log('Plan display refreshed with updated data');
            }
        }

        // Clean up subscription when page unloads
        window.addEventListener('beforeunload', function() {
            if (realtimeChannel) {
                supabaseClient.removeChannel(realtimeChannel);
            }
        });

        // Save current plan back to database if viewing from database
        async function savePlanToDatabase() {
            if (!currentPlanId) {
                console.log('‚è≠Ô∏è Skipping database save - no planId (viewing from localStorage)');
                return;
            }

            try {
                // Prepare the plan data in the format the database expects
                const planData = {
                    clientName: currentPlan.clientName,
                    preferences: currentPlan.preferences || {},
                    nutrition: currentPlan.nutrition
                };

                // Add the plan structure based on type
                if (currentPlan.multiDay && currentPlan.days) {
                    planData.currentPlan = currentPlan.days;
                    planData.calories = currentPlan.nutrition.calories;
                    planData.protein = currentPlan.nutrition.protein;
                    planData.carbs = currentPlan.nutrition.carbs;
                    planData.fat = currentPlan.nutrition.fat;
                } else if (currentPlan.meals) {
                    planData.meals = currentPlan.meals;
                }

                // CLIENT VIEW: Save to client_modified_data (preserves coach's original)
                if (isClientView && currentClientId) {
                    console.log('üíæ Saving CLIENT modifications to database...', currentPlanId);

                    const response = await fetch(SAVE_CLIENT_MODIFICATION_ENDPOINT, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            planId: currentPlanId,
                            clientId: currentClientId,
                            modifiedPlanData: planData
                        })
                    });

                    const result = await response.json();

                    if (!response.ok) {
                        console.error('‚ùå Client modification save error:', result);
                        throw new Error(result.error || 'Failed to save modifications');
                    }

                    // Mark as modified
                    isClientModified = true;
                    console.log('‚úÖ Client modifications saved to database');

                    // Update UI to show modified indicator and reset button
                    updateModifiedIndicator();
                    document.getElementById('resetToOriginalBtn').style.display = 'inline-block';
                    return;
                }

                // COACH VIEW: Save directly to plan_data
                console.log('üíæ Saving plan changes to database...', currentPlanId);

                const { error } = await supabaseClient
                    .from('coach_meal_plans')
                    .update({ plan_data: planData })
                    .eq('id', currentPlanId);

                if (error) {
                    console.error('‚ùå Database save error:', error);
                    throw error;
                }

                console.log('‚úÖ Plan saved to database successfully');
            } catch (error) {
                console.error('‚ùå Failed to save plan to database:', error);
                alert('Warning: Changes saved locally but failed to sync to database.');
            }
        }

        // Update UI to show that client has modified the plan
        function updateModifiedIndicator() {
            const header = document.getElementById('planHeader');
            if (header && isClientModified && !header.innerHTML.includes('modified-badge')) {
                header.innerHTML += ' <span class="modified-badge">Modified</span>';
            }
        }

        // Reset to coach's original plan (remove client modifications)
        async function resetToOriginal() {
            if (!currentPlanId || !currentClientId) {
                alert('Cannot reset: Plan information not available');
                return;
            }

            if (!confirm('Are you sure you want to reset to the original plan from your coach? All your modifications will be lost.')) {
                return;
            }

            try {
                console.log('üîÑ Resetting to original plan...', { planId: currentPlanId, clientId: currentClientId });

                // Use backend function to reset (bypasses RLS)
                const response = await fetch(RESET_CLIENT_MODIFICATION_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        planId: currentPlanId,
                        clientId: currentClientId
                    })
                });

                const result = await response.json();

                if (!response.ok) {
                    console.error('‚ùå Reset error:', result);
                    throw new Error(result.error || 'Failed to reset plan');
                }

                console.log('‚úÖ Plan reset to original:', result);

                // Verify the reset worked by checking returned data
                if (result.plan) {
                    console.log('üìã Returned plan client_modified_data:', result.plan.client_modified_data);
                    if (result.plan.client_modified_data !== null) {
                        console.error('‚ö†Ô∏è WARNING: client_modified_data was not cleared!');
                    }
                }

                if (result.alreadyOriginal) {
                    alert('Plan is already at the original version.');
                    return;
                }

                alert('Plan has been reset to the original version from your coach.');

                // Force a hard reload with cache busting to ensure fresh data
                const url = new URL(window.location.href);
                url.searchParams.set('_reset', Date.now());
                window.location.href = url.toString();

            } catch (error) {
                console.error('Error resetting plan:', error);
                alert('Failed to reset plan. Please try again.');
            }
        }

        // Generate and save share link
        async function generateShareLink() {
            if (!currentPlan) {
                alert('No meal plan to share');
                return;
            }

            // Show modal with loading state
            const modal = document.getElementById('shareModal');
            const linkText = document.getElementById('shareLinkText');
            linkText.textContent = 'Generating share link...';
            modal.classList.add('show');

            try {
                console.log('üì§ Saving plan for sharing...');

                // Prepare request body
                const requestBody = { planData: currentPlan };

                // If this plan was loaded from database (has planId), include it
                // This links the shared plan to the coach plan for cascade deletion
                if (currentPlan.planId) {
                    requestBody.coachPlanId = currentPlan.planId;
                    console.log('Linking shared plan to coach plan:', currentPlan.planId);
                }

                const response = await fetch(SAVE_PLAN_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    throw new Error('Failed to generate share link');
                }

                const data = await response.json();
                currentShareUrl = data.shareUrl;

                console.log('‚úÖ Share link generated:', currentShareUrl);

                linkText.textContent = currentShareUrl;

            } catch (error) {
                console.error('‚ùå Error generating share link:', error);
                linkText.textContent = 'Failed to generate link. Please try again.';
                alert('Failed to generate share link. Please try again.');
            }
        }

        // Copy share link to clipboard
        async function copyShareLink() {
            if (!currentShareUrl) {
                alert('No share link available');
                return;
            }

            try {
                await navigator.clipboard.writeText(currentShareUrl);

                // Update button text temporarily
                const copyBtn = event.target;
                const originalText = copyBtn.textContent;
                copyBtn.textContent = '‚úÖ Copied!';
                copyBtn.style.background = '#28a745';

                setTimeout(() => {
                    copyBtn.textContent = originalText;
                    copyBtn.style.background = '';
                }, 2000);

            } catch (error) {
                console.error('‚ùå Copy error:', error);
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = currentShareUrl;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                alert('Link copied to clipboard!');
            }
        }

        // Close share modal
        function closeShareModal() {
            const modal = document.getElementById('shareModal');
            modal.classList.remove('show');
        }

        // ===== CUSTOM MEAL MODAL FUNCTIONS =====

        function openCustomMealModal(index, dayIndex = null, mealIndex = null) {
            // Store the current meal context
            currentCustomMealIndex = index;
            currentCustomMealDayIndex = dayIndex;
            currentCustomMealMealIndex = mealIndex;

            // Reset manual panel form
            document.getElementById('customMealName').value = '';
            document.getElementById('customMealCalories').value = '';
            document.getElementById('customMealProtein').value = '';
            document.getElementById('customMealCarbs').value = '';
            document.getElementById('customMealFat').value = '';
            document.getElementById('customMealInstructions').value = '';

            // Reset USDA search/calculate panel
            document.getElementById('foodSearchInput').value = '';
            document.getElementById('foodSearchResults').classList.remove('active');
            document.getElementById('foodSearchResults').innerHTML = '';
            document.getElementById('calculatedMealName').value = '';
            document.getElementById('calculatedMealInstructions').value = '';
            customMealSelectedIngredients = [];
            renderCustomMealIngredients();
            updateCustomMealTotals();

            // Reset to calculate tab
            switchCustomMealTab('calculate');

            // Show modal
            document.getElementById('customMealModal').classList.add('show');
        }

        function closeCustomMealModal() {
            document.getElementById('customMealModal').classList.remove('show');
            currentCustomMealIndex = null;
            currentCustomMealDayIndex = null;
            currentCustomMealMealIndex = null;

            // Reset form fields
            document.getElementById('foodSearchInput').value = '';
            document.getElementById('foodSearchResults').classList.remove('active');
            document.getElementById('calculatedMealName').value = '';
            document.getElementById('calculatedMealInstructions').value = '';
            document.getElementById('customMealName').value = '';
            document.getElementById('customMealCalories').value = '';
            document.getElementById('customMealProtein').value = '';
            document.getElementById('customMealCarbs').value = '';
            document.getElementById('customMealFat').value = '';
            document.getElementById('customMealInstructions').value = '';

            // Reset save for later checkboxes
            document.getElementById('saveCalculatedForLater').checked = false;
            document.getElementById('saveManualForLater').checked = false;

            // Reset to first tab
            switchCustomMealTab('calculate');
        }

        function switchCustomMealTab(tab) {
            // Update tab styles
            const tabs = document.querySelectorAll('.custom-meal-tab');
            tabs.forEach(t => t.classList.remove('active'));

            // Update panel visibility
            document.getElementById('calculatePanel').classList.remove('active');
            document.getElementById('manualPanel').classList.remove('active');
            document.getElementById('savedPanel').classList.remove('active');

            if (tab === 'calculate') {
                tabs[0].classList.add('active');
                document.getElementById('calculatePanel').classList.add('active');
            } else if (tab === 'manual') {
                tabs[1].classList.add('active');
                document.getElementById('manualPanel').classList.add('active');
            } else if (tab === 'saved') {
                tabs[2].classList.add('active');
                document.getElementById('savedPanel').classList.add('active');
                renderSavedMeals();
            }
        }

        // ===== SAVED MEALS FUNCTIONS (Database backed - per account) =====
        const SAVED_MEALS_ENDPOINT = '/.netlify/functions/saved-meals';
        let savedMealsCache = []; // In-memory cache of saved meals

        async function loadSavedMeals() {
            // Determine which ID to use based on view type
            const queryParam = currentClientId
                ? `clientId=${currentClientId}`
                : currentCoachId
                    ? `coachId=${currentCoachId}`
                    : null;

            if (!queryParam) {
                console.log('‚ö†Ô∏è Cannot load saved meals - no user ID');
                savedMealsCache = [];
                return [];
            }

            try {
                const response = await fetch(`${SAVED_MEALS_ENDPOINT}?${queryParam}`);
                const data = await response.json();

                if (data.meals) {
                    // Transform database format to match expected format
                    savedMealsCache = data.meals.map(m => ({
                        id: m.id.toString(),
                        savedAt: m.created_at,
                        ...m.meal_data
                    }));
                    console.log(`üìö Loaded ${savedMealsCache.length} saved meals from database`);
                } else {
                    savedMealsCache = [];
                }
                return savedMealsCache;
            } catch (error) {
                console.error('Error loading saved meals:', error);
                savedMealsCache = [];
                return [];
            }
        }

        function getSavedMeals() {
            return savedMealsCache;
        }

        async function saveMealToLibrary(meal) {
            // Determine which ID to use based on view type
            const payload = currentClientId
                ? { clientId: currentClientId, mealData: meal }
                : currentCoachId
                    ? { coachId: currentCoachId, mealData: meal }
                    : null;

            if (!payload) {
                alert('Cannot save meal - not logged in');
                return null;
            }

            try {
                const response = await fetch(SAVED_MEALS_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const data = await response.json();

                if (data.success && data.meal) {
                    // Add to cache
                    const newMeal = {
                        id: data.meal.id.toString(),
                        savedAt: data.meal.created_at,
                        ...data.meal.meal_data
                    };
                    savedMealsCache.unshift(newMeal);
                    console.log('üíæ Meal saved to library:', newMeal.name);
                    return newMeal;
                } else {
                    throw new Error(data.error || 'Failed to save meal');
                }
            } catch (error) {
                console.error('Error saving meal to library:', error);
                alert('Failed to save meal to library. Please try again.');
                return null;
            }
        }

        async function deleteSavedMeal(mealId) {
            // Determine which ID to use based on view type
            const queryParam = currentClientId
                ? `clientId=${currentClientId}`
                : currentCoachId
                    ? `coachId=${currentCoachId}`
                    : null;

            if (!queryParam) {
                alert('Cannot delete meal - not logged in');
                return;
            }

            try {
                const response = await fetch(`${SAVED_MEALS_ENDPOINT}?mealId=${mealId}&${queryParam}`, {
                    method: 'DELETE'
                });

                const data = await response.json();

                if (data.success) {
                    // Remove from cache
                    savedMealsCache = savedMealsCache.filter(m => m.id !== mealId);
                    renderSavedMeals();
                    console.log('üóëÔ∏è Meal deleted from library:', mealId);
                } else {
                    throw new Error(data.error || 'Failed to delete meal');
                }
            } catch (error) {
                console.error('Error deleting saved meal:', error);
                alert('Failed to delete meal. Please try again.');
            }
        }

        function useSavedMeal(mealId) {
            const savedMeals = getSavedMeals();
            const meal = savedMeals.find(m => m.id === mealId);
            if (!meal) {
                alert('Meal not found');
                return;
            }

            // Get meal type and index info
            const mealType = currentPlan.multiDay
                ? currentPlan.days[currentCustomMealDayIndex].plan[currentCustomMealMealIndex]?.type || 'meal'
                : currentPlan.meals[currentCustomMealIndex]?.type || 'meal';

            // Create the meal
            const newMeal = {
                type: mealType,
                name: meal.name,
                ingredients: meal.ingredients,
                ingredientData: meal.ingredientData,  // Include full ingredient data for editing
                calories: meal.calories,
                protein: meal.protein,
                carbs: meal.carbs,
                fat: meal.fat,
                instructions: meal.instructions || 'Prepare as desired.',
                source: meal.source || 'Saved Meal',
                isCustom: true
            };

            // Update the meal in the plan
            if (currentPlan.multiDay) {
                currentPlan.days[currentCustomMealDayIndex].plan[currentCustomMealMealIndex] = newMeal;
            } else {
                currentPlan.meals[currentCustomMealIndex] = newMeal;
            }

            // Save changes
            localStorage.setItem('currentMealPlan', JSON.stringify(currentPlan));
            savePlanToDatabase();

            // Close modal and refresh display
            closeCustomMealModal();
            displayMealPlan();
            console.log('‚úÖ Used saved meal:', newMeal.name);
        }

        // Parse ingredient string and look up in food database
        async function parseAndLookupIngredients(ingredients) {
            if (!ingredients || !Array.isArray(ingredients) || ingredients.length === 0) {
                return null;
            }

            const ingredientData = [];

            for (const ingStr of ingredients) {
                // Try to parse formats like "Food Name (150g)" or "Food Name (1 Serving)"
                // Also handle "150g Food Name" format
                let match = ingStr.match(/^(.+?)\s*\((\d+\.?\d*)\s*(g|serving|cup|tbsp|tsp|oz|scoop|whole|medium|large|slice)s?\)$/i);

                if (!match) {
                    // Try alternate format: "150g Food Name"
                    match = ingStr.match(/^(\d+\.?\d*)\s*(g|serving|cup|tbsp|tsp|oz)\s+(.+)$/i);
                    if (match) {
                        // Rearrange to [full, name, quantity, unit]
                        match = [match[0], match[3], match[1], match[2]];
                    }
                }

                if (!match) {
                    console.log('Could not parse ingredient:', ingStr);
                    continue;
                }

                const [, name, quantity, unit] = match;
                const cleanName = name.trim();
                const qty = parseFloat(quantity);
                const cleanUnit = unit.toLowerCase();

                try {
                    // Look up in food database
                    const response = await fetch(`${FOOD_SEARCH_ENDPOINT}?query=${encodeURIComponent(cleanName)}`);
                    const data = await response.json();

                    if (data.foods && data.foods.length > 0) {
                        // Use the first match
                        const food = data.foods[0];

                        // Calculate quantity in grams
                        let quantityGrams = qty;
                        if (cleanUnit !== 'g') {
                            // Use serving size conversion if available
                            if (food.gramsPerServing) {
                                quantityGrams = qty * food.gramsPerServing;
                            } else {
                                // Default conversions
                                const conversions = { cup: 240, tbsp: 15, tsp: 5, oz: 28, serving: 100, scoop: 30, whole: 50, medium: 150, large: 200, slice: 30 };
                                quantityGrams = qty * (conversions[cleanUnit] || 100);
                            }
                        }

                        ingredientData.push({
                            name: food.name,
                            caloriesPer100g: food.caloriesPer100g,
                            proteinPer100g: food.proteinPer100g,
                            carbsPer100g: food.carbsPer100g,
                            fatPer100g: food.fatPer100g,
                            quantity: qty,
                            selectedUnit: cleanUnit,
                            quantityGrams: quantityGrams,
                            gramsPerServing: food.gramsPerServing
                        });
                        console.log('‚úÖ Found ingredient:', cleanName, '‚Üí', food.name);
                    } else {
                        console.log('‚ùå No match found for:', cleanName);
                    }
                } catch (error) {
                    console.error('Error looking up ingredient:', cleanName, error);
                }
            }

            return ingredientData.length > 0 ? ingredientData : null;
        }

        // Edit a saved meal before using it
        async function editSavedMeal(mealId) {
            const savedMeals = getSavedMeals();
            const meal = savedMeals.find(m => m.id === mealId);
            if (!meal) {
                alert('Meal not found');
                return;
            }

            // Check if meal has full ingredient data (from Food Database)
            let ingredientData = meal.ingredientData;

            // If no ingredientData, try to parse and look up ingredients
            if ((!ingredientData || !Array.isArray(ingredientData) || ingredientData.length === 0) && meal.ingredients) {
                console.log('üîç No ingredientData found, attempting to parse ingredients...');
                ingredientData = await parseAndLookupIngredients(meal.ingredients);
            }

            if (ingredientData && Array.isArray(ingredientData) && ingredientData.length > 0) {
                // Load ingredients into Calculate tab
                customMealSelectedIngredients = JSON.parse(JSON.stringify(ingredientData));

                // Switch to calculate tab
                switchCustomMealTab('calculate');

                // Pre-populate meal name and instructions
                document.getElementById('calculatedMealName').value = meal.name || '';
                document.getElementById('calculatedMealInstructions').value = meal.instructions || '';

                // Render the ingredients and update totals
                renderCustomMealIngredients();
                updateCustomMealTotals();

                console.log('üìù Editing saved meal with ingredients:', customMealSelectedIngredients);
            } else {
                // Fall back to manual tab for meals without ingredient data
                switchCustomMealTab('manual');

                // Pre-populate the manual panel fields with existing meal data
                document.getElementById('customMealName').value = meal.name || '';
                document.getElementById('customMealCalories').value = meal.calories || '';
                document.getElementById('customMealProtein').value = meal.protein || '';
                document.getElementById('customMealCarbs').value = meal.carbs || '';
                document.getElementById('customMealFat').value = meal.fat || '';
                document.getElementById('customMealInstructions').value = meal.instructions || '';
            }
        }

        function renderSavedMeals() {
            const container = document.getElementById('savedMealsList');
            const savedMeals = getSavedMeals();

            if (savedMeals.length === 0) {
                container.innerHTML = '<div class="no-saved-meals">No saved meals yet. Create a meal and check "Save for future use" to add it here.</div>';
                return;
            }

            container.innerHTML = savedMeals.map(meal => `
                <div class="saved-meal-item">
                    <div class="saved-meal-info">
                        <div class="saved-meal-name">${escapeHtml(meal.name)}</div>
                        <div class="saved-meal-macros">${meal.calories} cal | ${meal.protein}g P | ${meal.carbs}g C | ${meal.fat}g F</div>
                    </div>
                    <div class="saved-meal-actions">
                        <button class="btn-edit-saved" onclick="editSavedMeal('${meal.id}')" title="Edit before using">‚úé</button>
                        <button class="btn-use-saved" onclick="useSavedMeal('${meal.id}')">Use</button>
                        <button class="btn-delete-saved" onclick="deleteSavedMeal('${meal.id}')">üóëÔ∏è</button>
                    </div>
                </div>
            `).join('');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ===== FOOD SEARCH FUNCTIONS - synced with planner.html =====

        function handleFoodSearch(query) {
            const resultsDiv = document.getElementById('foodSearchResults');

            if (foodSearchTimeout) {
                clearTimeout(foodSearchTimeout);
            }

            if (!query || query.trim().length < 2) {
                resultsDiv.classList.remove('active');
                resultsDiv.innerHTML = '';
                foodSearchResults = [];
                return;
            }

            // Show loading state
            resultsDiv.classList.add('active');
            resultsDiv.innerHTML = '<div class="food-search-loading">Searching foods...</div>';

            // Debounce the search
            foodSearchTimeout = setTimeout(async () => {
                try {
                    const response = await fetch(`${FOOD_SEARCH_ENDPOINT}?query=${encodeURIComponent(query)}`);
                    const data = await response.json();

                    if (!response.ok) {
                        throw new Error(data.error || 'Search failed');
                    }

                    if (data.foods && data.foods.length > 0) {
                        foodSearchResults = data.foods;

                        resultsDiv.innerHTML = data.foods.map((food, index) => {
                            let macroDisplay;
                            if (food.servingSize && food.caloriesPerServing !== undefined) {
                                macroDisplay = `${escapeHtmlCustomMeal(food.servingSize)}: ${food.caloriesPerServing} cal | ${food.proteinPerServing}g P | ${food.carbsPerServing}g C | ${food.fatPerServing}g F`;
                            } else {
                                macroDisplay = `Per 100g: ${food.caloriesPer100g} cal | ${food.proteinPer100g}g P | ${food.carbsPer100g}g C | ${food.fatPer100g}g F`;
                            }

                            return `
                            <div class="food-search-item" onclick="selectFoodItem(${index})">
                                <div class="food-name">${escapeHtmlCustomMeal(food.name)}${food.brand ? ` <span style="color: #888; font-size: 12px;">(${escapeHtmlCustomMeal(food.brand)})</span>` : ''}</div>
                                <div class="food-macros">${macroDisplay}</div>
                            </div>
                        `}).join('');
                    } else {
                        foodSearchResults = [];
                        resultsDiv.innerHTML = '<div class="food-search-empty">No foods found. Try a different search term.</div>';
                    }
                } catch (error) {
                    console.error('Food search error:', error);
                    foodSearchResults = [];
                    resultsDiv.innerHTML = '<div class="food-search-empty">Search failed. Please try again.</div>';
                }
            }, 300);
        }

        function escapeHtmlCustomMeal(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function selectFoodItem(index) {
            const food = foodSearchResults[index];
            if (!food) return;

            // Build measures array - always include grams as default
            let measures = [{ label: 'g', weight: 1, isGrams: true }];

            // Add measures from API if available
            if (food.measures && food.measures.length > 0) {
                food.measures.forEach(m => {
                    if (m.label && m.weight && m.label.toLowerCase() !== 'gram') {
                        measures.push({
                            label: m.label,
                            weight: m.weight,
                            isGrams: false
                        });
                    }
                });
            }

            // Use first non-gram serving as default if available, otherwise 100g
            const defaultMeasure = measures.length > 1 ? measures[1] : measures[0];
            const defaultQty = defaultMeasure.isGrams ? 100 : 1;
            const defaultGrams = defaultMeasure.isGrams ? 100 : defaultMeasure.weight;

            customMealSelectedIngredients.push({
                fdcId: food.fdcId,
                name: food.name,
                quantity: defaultQty,
                quantityGrams: defaultGrams,
                selectedUnit: defaultMeasure.label,
                measures: measures,
                caloriesPer100g: food.caloriesPer100g,
                proteinPer100g: food.proteinPer100g,
                carbsPer100g: food.carbsPer100g,
                fatPer100g: food.fatPer100g
            });

            // Clear search
            document.getElementById('foodSearchInput').value = '';
            document.getElementById('foodSearchResults').classList.remove('active');
            document.getElementById('foodSearchResults').innerHTML = '';

            // Update UI
            renderCustomMealIngredients();
            updateCustomMealTotals();
        }

        function removeCustomMealIngredient(index) {
            customMealSelectedIngredients.splice(index, 1);
            renderCustomMealIngredients();
            updateCustomMealTotals();
        }

        function updateCustomMealIngredientQty(index, quantity) {
            const qty = parseFloat(quantity) || 0;
            const ing = customMealSelectedIngredients[index];
            ing.quantity = qty;

            // Recalculate grams based on current unit
            const measure = ing.measures.find(m => m.label === ing.selectedUnit);
            if (measure) {
                ing.quantityGrams = measure.isGrams ? qty : qty * measure.weight;
            }

            updateCustomMealTotals();
        }

        // Step ingredient quantity up or down with +/- buttons
        function stepIngredientQty(index, direction) {
            const ing = customMealSelectedIngredients[index];
            if (!ing) return;

            const isGrams = ing.selectedUnit === 'g';
            const stepAmount = isGrams ? 10 : 0.5; // 10g for grams, 0.5 for servings

            let newQty = ing.quantity + (stepAmount * direction);

            // Minimum value
            if (newQty < 0.1) newQty = 0.1;

            // Round appropriately
            if (isGrams) {
                newQty = Math.round(newQty);
            } else {
                newQty = Math.round(newQty * 10) / 10;
            }

            ing.quantity = newQty;

            // Recalculate grams
            const measure = ing.measures.find(m => m.label === ing.selectedUnit);
            if (measure) {
                ing.quantityGrams = measure.isGrams ? newQty : newQty * measure.weight;
            }

            // Re-render to update the input field and update totals
            renderCustomMealIngredients();
            updateCustomMealTotals();
        }

        function updateCustomMealIngredientUnit(index, unitLabel) {
            const ing = customMealSelectedIngredients[index];
            const newMeasure = ing.measures.find(m => m.label === unitLabel);

            if (!newMeasure) return;

            // Convert current grams to new unit quantity
            if (newMeasure.isGrams) {
                // Switching to grams - quantity becomes the gram value
                ing.quantity = Math.round(ing.quantityGrams);
            } else {
                // Switching to a serving unit - calculate how many servings
                ing.quantity = Math.round((ing.quantityGrams / newMeasure.weight) * 10) / 10;
                if (ing.quantity < 0.1) ing.quantity = 0.1;
            }

            ing.selectedUnit = unitLabel;

            // Recalculate grams to ensure consistency
            ing.quantityGrams = newMeasure.isGrams ? ing.quantity : ing.quantity * newMeasure.weight;

            renderCustomMealIngredients();
            updateCustomMealTotals();
        }

        function renderCustomMealIngredients() {
            const listDiv = document.getElementById('ingredientsList');
            const countSpan = document.getElementById('ingredientCount');

            countSpan.textContent = `(${customMealSelectedIngredients.length})`;

            if (customMealSelectedIngredients.length === 0) {
                listDiv.innerHTML = '<div class="no-ingredients">No ingredients added yet</div>';
                return;
            }

            listDiv.innerHTML = customMealSelectedIngredients.map((ing, index) => {
                const displayName = ing.name;
                const gramsInfo = ing.selectedUnit !== 'g' ? ` (${Math.round(ing.quantityGrams)}g)` : '';
                const titleText = `${escapeHtmlCustomMeal(ing.name)}${gramsInfo}`;

                // Build unit dropdown options
                const unitOptions = ing.measures.map(m => {
                    const selected = m.label === ing.selectedUnit ? 'selected' : '';
                    const weightInfo = m.isGrams ? '' : ` (${m.weight}g)`;
                    return `<option value="${escapeHtmlCustomMeal(m.label)}" ${selected}>${escapeHtmlCustomMeal(m.label)}${weightInfo}</option>`;
                }).join('');

                const isGrams = ing.selectedUnit === 'g';
                const stepAmount = isGrams ? 10 : 0.5;

                return `
                <div class="ingredient-item">
                    <span class="ingredient-name" title="${titleText}">${escapeHtmlCustomMeal(displayName)}</span>
                    <div class="qty-stepper">
                        <button class="qty-step-btn" onclick="stepIngredientQty(${index}, -1)" title="Decrease">‚àí</button>
                        <input type="number" class="ingredient-qty" value="${ing.quantity}" min="0.1" step="${stepAmount}"
                               onchange="updateCustomMealIngredientQty(${index}, this.value)"
                               oninput="updateCustomMealIngredientQty(${index}, this.value)"
                               onclick="event.stopPropagation()">
                        <button class="qty-step-btn" onclick="stepIngredientQty(${index}, 1)" title="Increase">+</button>
                    </div>
                    <select class="ingredient-unit-select" onchange="updateCustomMealIngredientUnit(${index}, this.value)">
                        ${unitOptions}
                    </select>
                    <button class="ingredient-remove" onclick="removeCustomMealIngredient(${index})" title="Remove">√ó</button>
                </div>
            `}).join('');
        }

        function updateCustomMealTotals() {
            let totalCal = 0, totalProtein = 0, totalCarbs = 0, totalFat = 0;

            customMealSelectedIngredients.forEach(ing => {
                // Use quantityGrams for accurate calculation
                const grams = ing.quantityGrams || ing.quantity;
                const factor = grams / 100;
                totalCal += ing.caloriesPer100g * factor;
                totalProtein += ing.proteinPer100g * factor;
                totalCarbs += ing.carbsPer100g * factor;
                totalFat += ing.fatPer100g * factor;
            });

            document.getElementById('calcTotalCalories').textContent = Math.round(totalCal);
            document.getElementById('calcTotalProtein').textContent = Math.round(totalProtein) + 'g';
            document.getElementById('calcTotalCarbs').textContent = Math.round(totalCarbs) + 'g';
            document.getElementById('calcTotalFat').textContent = Math.round(totalFat) + 'g';

            // Update meal name placeholder with auto-generated name
            const mealNameInput = document.getElementById('calculatedMealName');
            if (customMealSelectedIngredients.length > 0) {
                const autoName = customMealSelectedIngredients.map(ing => {
                    const grams = ing.quantityGrams || ing.quantity;
                    const shortName = ing.name.split(',')[0].trim();
                    if (ing.selectedUnit === 'g') {
                        return `${Math.round(grams)}g ${shortName}`;
                    } else {
                        return `${ing.quantity} ${ing.selectedUnit} ${shortName}`;
                    }
                }).join(', ');
                mealNameInput.placeholder = autoName;
            } else {
                mealNameInput.placeholder = 'Meal name (optional - auto-generated if blank)';
            }

            // Enable/disable create button
            const createBtn = document.getElementById('createCalculatedMealBtn');
            createBtn.disabled = customMealSelectedIngredients.length === 0;
        }

        async function submitManualMeal() {
            const mealName = document.getElementById('customMealName').value.trim();
            const calories = parseInt(document.getElementById('customMealCalories').value) || 0;
            const protein = parseInt(document.getElementById('customMealProtein').value) || 0;
            const carbs = parseInt(document.getElementById('customMealCarbs').value) || 0;
            const fat = parseInt(document.getElementById('customMealFat').value) || 0;
            const instructions = document.getElementById('customMealInstructions').value.trim() || 'Prepare as desired.';

            if (!mealName) {
                alert('Please enter a meal name');
                return;
            }

            if (calories === 0 && protein === 0 && carbs === 0 && fat === 0) {
                alert('Please enter at least some macro values');
                return;
            }

            // Validate macro math (calories should roughly equal P*4 + C*4 + F*9)
            if (calories > 0 && (protein > 0 || carbs > 0 || fat > 0)) {
                const calculatedCal = (protein * 4) + (carbs * 4) + (fat * 9);
                const variance = Math.abs(calories - calculatedCal);
                const variancePercent = (variance / calories) * 100;

                if (variancePercent > 25) {
                    const proceed = confirm(
                        `‚ö†Ô∏è Macro Math Check\n\n` +
                        `Entered: ${calories} calories\n` +
                        `Calculated from macros: ${calculatedCal} cal\n` +
                        `(Protein√ó4 + Carbs√ó4 + Fat√ó9)\n\n` +
                        `Difference: ${variance} cal (${Math.round(variancePercent)}%)\n\n` +
                        `This seems off. Continue anyway?`
                    );
                    if (!proceed) return;
                }
            }

            // Get the current meal for type reference
            let meal;
            if (currentCustomMealDayIndex !== null && currentCustomMealMealIndex !== null) {
                meal = currentPlan.days[currentCustomMealDayIndex].plan[currentCustomMealMealIndex];
            } else {
                meal = currentPlan.meals[currentCustomMealIndex];
            }

            // Save current meal state for undo
            const stateKey = currentCustomMealDayIndex !== null ? `${currentCustomMealDayIndex}-${currentCustomMealMealIndex}` : `${currentCustomMealIndex}`;
            previousMealStates[stateKey] = JSON.parse(JSON.stringify(meal));
            console.log(`üíæ Saved previous state for manual custom meal:`, previousMealStates[stateKey]);
            saveUndoStates(); // Persist to localStorage

            // Create the custom meal object
            const customMealData = {
                type: meal.type || 'meal',
                name: mealName,
                ingredients: [`${mealName} (manual entry)`],
                calories: calories,
                protein: protein,
                carbs: carbs,
                fat: fat,
                instructions: instructions,
                source: 'Manual Entry',
                isCustom: true
            };

            // Save to library if checkbox is checked
            const saveForLater = document.getElementById('saveManualForLater').checked;
            if (saveForLater) {
                saveMealToLibrary(customMealData);
            }

            // Save the custom meal
            if (currentCustomMealDayIndex !== null && currentCustomMealMealIndex !== null) {
                currentPlan.days[currentCustomMealDayIndex].plan[currentCustomMealMealIndex] = customMealData;
            } else {
                currentPlan.meals[currentCustomMealIndex] = customMealData;
            }
            localStorage.setItem('currentMealPlan', JSON.stringify(currentPlan));

            // Save to database
            await savePlanToDatabase();

            // Update day totals if multi-day
            if (currentCustomMealDayIndex !== null) {
                updateDayTotals(currentCustomMealDayIndex);
            }

            // Close modal and refresh display
            closeCustomMealModal();
            displayMealPlan();

            showNotification(`Custom meal created: ${calories} cal, ${protein}g protein`, 'success');
        }

        async function submitCalculatedMeal() {
            // Check if we have selected ingredients
            if (customMealSelectedIngredients.length === 0) {
                alert('Please search and add some ingredients first');
                return;
            }

            const index = currentCustomMealIndex;
            const dayIndex = currentCustomMealDayIndex;
            const mealIndex = currentCustomMealMealIndex;

            // Get the current meal for reference
            let meal;
            if (dayIndex !== null && mealIndex !== null) {
                meal = currentPlan.days[dayIndex].plan[mealIndex];
            } else {
                meal = currentPlan.meals[index];
            }

            // Save current meal state for undo
            const stateKey = dayIndex !== null ? `${dayIndex}-${mealIndex}` : `${index}`;
            previousMealStates[stateKey] = JSON.parse(JSON.stringify(meal));
            console.log(`üíæ Saved previous state for USDA custom meal:`, previousMealStates[stateKey]);
            saveUndoStates(); // Persist to localStorage

            // Calculate totals from selected ingredients
            let totalCal = 0, totalProtein = 0, totalCarbs = 0, totalFat = 0;
            const ingredients = [];

            customMealSelectedIngredients.forEach(ing => {
                // Use quantityGrams for accurate calculation
                const grams = ing.quantityGrams || ing.quantity;
                const multiplier = grams / 100;
                totalCal += ing.caloriesPer100g * multiplier;
                totalProtein += ing.proteinPer100g * multiplier;
                totalCarbs += ing.carbsPer100g * multiplier;
                totalFat += ing.fatPer100g * multiplier;

                // Format ingredient with unit (e.g., "Chicken (1 Cup)" or "Rice (150g)")
                const unitDisplay = ing.selectedUnit === 'g' ? `${Math.round(grams)}g` : `${ing.quantity} ${ing.selectedUnit}`;
                ingredients.push(`${ing.name} (${unitDisplay})`);
            });

            // Generate meal name - show ALL ingredients with servings
            // e.g., "200g Sirloin Steak, 1 Cup Brown Rice, 2 Tbsp Olive Oil"
            let mealName = document.getElementById('calculatedMealName').value.trim();
            if (!mealName) {
                const ingredientParts = customMealSelectedIngredients.map(ing => {
                    const grams = ing.quantityGrams || ing.quantity;
                    const shortName = ing.name.split(',')[0].trim();
                    const displayName = shortName;

                    if (ing.selectedUnit === 'g') {
                        return `${Math.round(grams)}g ${displayName}`;
                    } else {
                        return `${ing.quantity} ${ing.selectedUnit} ${displayName}`;
                    }
                });

                mealName = ingredientParts.join(', ');
            }

            // Get custom instructions from the textarea
            const customInstructions = document.getElementById('calculatedMealInstructions').value.trim() || 'Prepare as desired.';

            // Store full ingredient data for editing later (deep copy to avoid reference issues)
            const ingredientData = JSON.parse(JSON.stringify(customMealSelectedIngredients));

            // Create the custom meal object
            const customMealData = {
                type: meal.type || 'meal',
                name: mealName,
                ingredients: ingredients,
                ingredientData: ingredientData,  // Full ingredient objects for editing
                calories: Math.round(totalCal),
                protein: Math.round(totalProtein),
                carbs: Math.round(totalCarbs),
                fat: Math.round(totalFat),
                instructions: customInstructions,
                source: 'Food Database',
                isCustom: true
            };

            // Save to library if checkbox is checked
            const saveForLater = document.getElementById('saveCalculatedForLater').checked;
            if (saveForLater) {
                saveMealToLibrary(customMealData);
            }

            console.log('‚úÖ Custom meal created:', customMealData);

            // Save the custom meal
            if (dayIndex !== null && mealIndex !== null) {
                currentPlan.days[dayIndex].plan[mealIndex] = customMealData;
            } else {
                currentPlan.meals[index] = customMealData;
            }
            localStorage.setItem('currentMealPlan', JSON.stringify(currentPlan));

            // Close modal
            closeCustomMealModal();

            // Save to database
            await savePlanToDatabase();

            // Update day totals if multi-day
            if (dayIndex !== null) {
                updateDayTotals(dayIndex);
            }

            displayMealPlan();

            showNotification(`Custom meal created: ${customMealData.calories} cal, ${customMealData.protein}g protein`, 'success');
        }

        function displayMealPlan() {
            console.log('üìã displayMealPlan called, currentPlan:', currentPlan);

            // FIXED: Handle both multi-day and single-day plans
            let nutrition = currentPlan.nutrition || {};

            // Check if nutrition values are missing or zero
            if (!nutrition.calories && !nutrition.protein && !nutrition.carbs && !nutrition.fat) {
                console.warn('‚ö†Ô∏è Nutrition object empty or all zeros, calculating from plan...');

                // Calculate based on plan type
                if (currentPlan.multiDay && currentPlan.days && currentPlan.days.length > 0) {
                    // For multi-day, get from first day's targets
                    if (currentPlan.days[0].targets) {
                        nutrition = { ...currentPlan.days[0].targets };
                        console.log('‚úÖ Got nutrition from day 1 targets:', nutrition);
                    }
                } else if (currentPlan.meals && currentPlan.meals.length > 0) {
                    // For single-day, calculate totals from meals
                    nutrition = { calories: 0, protein: 0, carbs: 0, fat: 0 };
                    currentPlan.meals.forEach(meal => {
                        nutrition.calories += parseInt(meal.calories) || 0;
                        nutrition.protein += parseInt(meal.protein) || 0;
                        nutrition.carbs += parseInt(meal.carbs) || 0;
                        nutrition.fat += parseInt(meal.fat) || 0;
                    });
                    console.log('‚úÖ Calculated nutrition from meals:', nutrition);
                }

                currentPlan.nutrition = nutrition;
                localStorage.setItem('currentMealPlan', JSON.stringify(currentPlan));
            }

            console.log('üìä Displaying Daily Targets:', nutrition);

            // Display DAILY nutrition totals
            document.getElementById('totalCalories').textContent = nutrition.calories || 0;
            document.getElementById('totalProtein').textContent = (nutrition.protein || 0) + 'g';
            document.getElementById('totalCarbs').textContent = (nutrition.carbs || 0) + 'g';
            document.getElementById('totalFat').textContent = (nutrition.fat || 0) + 'g';

            // Display coach notes if present
            const existingNotesSection = document.getElementById('coachNotesSection');
            if (existingNotesSection) {
                existingNotesSection.remove();
            }

            if (currentPlan.coachNotes) {
                const notesSection = document.createElement('div');
                notesSection.id = 'coachNotesSection';
                notesSection.style.cssText = 'background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); padding: 20px; border-radius: 12px; margin-bottom: 20px; border: 1px solid #7dd3fc;';
                notesSection.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
                        <span style="font-size: 20px;">üìù</span>
                        <h3 style="margin: 0; color: #0369a1; font-size: 16px; font-weight: 600;">Message from Your Coach</h3>
                    </div>
                    <p style="margin: 0; color: #334155; font-size: 15px; line-height: 1.6; white-space: pre-wrap;">${linkifyText(currentPlan.coachNotes)}</p>
                `;
                document.getElementById('mealsContainer').parentNode.insertBefore(notesSection, document.getElementById('mealsContainer'));
            }

            // Display meals - FIXED for multi-day plans
            const container = document.getElementById('mealsContainer');
            container.innerHTML = '';

            // Helper function to get color class based on variance
            const getVarianceColor = (variancePercent) => {
                const abs = Math.abs(variancePercent);
                if (abs <= 10) return '#16a34a'; // green - within ¬±10%
                if (abs <= 20) return '#ca8a04'; // yellow - within ¬±20%
                return '#dc2626'; // red - over ¬±20%
            };

            // Helper function to format variance display
            const formatVariance = (actual, target, variancePercent) => {
                const diff = actual - target;
                const sign = diff >= 0 ? '+' : '';
                return `${sign}${diff} (${sign}${variancePercent.toFixed(1)}%)`;
            };

            if (currentPlan.multiDay && currentPlan.days) {
                // Multi-day plan: show days with separators
                currentPlan.days.forEach((dayData, dayIndex) => {
                    // Calculate per-day actual totals
                    let dayTotals = { calories: 0, protein: 0, carbs: 0, fat: 0 };
                    if (dayData.plan && Array.isArray(dayData.plan)) {
                        dayData.plan.forEach(meal => {
                            dayTotals.calories += parseInt(meal.calories) || 0;
                            dayTotals.protein += parseInt(meal.protein) || 0;
                            dayTotals.carbs += parseInt(meal.carbs) || 0;
                            dayTotals.fat += parseInt(meal.fat) || 0;
                        });
                    }

                    // Get targets (use day targets if available, otherwise use plan nutrition)
                    const targets = dayData.targets || nutrition;

                    // Calculate per-day variance
                    const dayVariance = {
                        calories: targets.calories ? ((dayTotals.calories - targets.calories) / targets.calories * 100) : 0,
                        protein: targets.protein ? ((dayTotals.protein - targets.protein) / targets.protein * 100) : 0,
                        carbs: targets.carbs ? ((dayTotals.carbs - targets.carbs) / targets.carbs * 100) : 0,
                        fat: targets.fat ? ((dayTotals.fat - targets.fat) / targets.fat * 100) : 0
                    };

                    // Day header with regenerate button
                    const dayHeader = document.createElement('div');
                    dayHeader.className = 'day-header';
                    dayHeader.style.cssText = 'background: linear-gradient(135deg, #0d9488 0%, #0284c7 100%); color: white; padding: 15px 20px; border-radius: 12px; margin: 20px 0 15px 0; font-weight: 700; font-size: 1.3em; display: flex; justify-content: space-between; align-items: center;';

                    // Check if client view - hide regenerate button for clients
                    const urlParams = new URLSearchParams(window.location.search);
                    const isClientView = urlParams.get('clientView') === 'true' || urlParams.get('share');

                    dayHeader.innerHTML = `
                        <span>Day ${dayData.day}</span>
                        ${!isClientView ? `<button onclick="regenerateDay(${dayIndex})" class="btn" style="background: rgba(255,255,255,0.2); color: white; border: 1px solid rgba(255,255,255,0.3); padding: 8px 16px; font-size: 0.8em;">üîÑ Regenerate Day</button>` : ''}
                    `;
                    container.appendChild(dayHeader);

                    // Calculate macro distribution percentages (% of total calories from each macro)
                    const macroPercent = {
                        protein: dayTotals.calories > 0 ? Math.round((dayTotals.protein * 4) / dayTotals.calories * 100) : 0,
                        carbs: dayTotals.calories > 0 ? Math.round((dayTotals.carbs * 4) / dayTotals.calories * 100) : 0,
                        fat: dayTotals.calories > 0 ? Math.round((dayTotals.fat * 9) / dayTotals.calories * 100) : 0
                    };

                    // Day totals section
                    const dayTotalsDiv = document.createElement('div');
                    dayTotalsDiv.id = `day-totals-${dayIndex}`;
                    dayTotalsDiv.style.cssText = 'background: #f8f9ff; padding: 15px; border-radius: 10px; margin-bottom: 15px; border: 1px solid #e0e7ff;';
                    dayTotalsDiv.innerHTML = `
                        <p style="font-size: 0.85em; font-weight: 600; color: #666; margin-bottom: 10px;">Day ${dayData.day} Totals:</p>
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; text-align: center;">
                            <div>
                                <p style="font-size: 0.75em; color: #888;">Calories</p>
                                <span style="font-weight: 700; color: ${getVarianceColor(dayVariance.calories)}">${dayTotals.calories}</span>
                                <p style="font-size: 0.7em; color: ${getVarianceColor(dayVariance.calories)}">${formatVariance(dayTotals.calories, targets.calories, dayVariance.calories)}</p>
                            </div>
                            <div>
                                <p style="font-size: 0.75em; color: #888;">Protein</p>
                                <span style="font-weight: 700; color: ${getVarianceColor(dayVariance.protein)}">${dayTotals.protein}g</span>
                                <span style="font-size: 0.7em; font-weight: 500; color: #10b981; display: block;">${macroPercent.protein}%</span>
                                <p style="font-size: 0.7em; color: ${getVarianceColor(dayVariance.protein)}">${formatVariance(dayTotals.protein, targets.protein, dayVariance.protein)}</p>
                            </div>
                            <div>
                                <p style="font-size: 0.75em; color: #888;">Carbs</p>
                                <span style="font-weight: 700; color: ${getVarianceColor(dayVariance.carbs)}">${dayTotals.carbs}g</span>
                                <span style="font-size: 0.7em; font-weight: 500; color: #f59e0b; display: block;">${macroPercent.carbs}%</span>
                                <p style="font-size: 0.7em; color: ${getVarianceColor(dayVariance.carbs)}">${formatVariance(dayTotals.carbs, targets.carbs, dayVariance.carbs)}</p>
                            </div>
                            <div>
                                <p style="font-size: 0.75em; color: #888;">Fat</p>
                                <span style="font-weight: 700; color: ${getVarianceColor(dayVariance.fat)}">${dayTotals.fat}g</span>
                                <span style="font-size: 0.7em; font-weight: 500; color: #3b82f6; display: block;">${macroPercent.fat}%</span>
                                <p style="font-size: 0.7em; color: ${getVarianceColor(dayVariance.fat)}">${formatVariance(dayTotals.fat, targets.fat, dayVariance.fat)}</p>
                            </div>
                        </div>
                        <div style="margin-top: 8px; text-align: center; font-size: 0.7em; color: #888;">
                            <span style="color: #16a34a;">‚óè</span> Within ¬±10% |
                            <span style="color: #ca8a04;">‚óè</span> Within ¬±20% |
                            <span style="color: #dc2626;">‚óè</span> Over ¬±20%
                        </div>
                    `;
                    container.appendChild(dayTotalsDiv);

                    // Meals for this day
                    if (dayData.plan && Array.isArray(dayData.plan)) {
                        dayData.plan.forEach((meal, mealIndex) => {
                            const mealCard = createMealCard(meal, `${dayIndex}-${mealIndex}`, dayIndex, mealIndex);
                            container.appendChild(mealCard);
                        });
                    }
                });
            } else if (currentPlan.meals) {
                // Single-day plan: show meals directly
                currentPlan.meals.forEach((meal, index) => {
                    const mealCard = createMealCard(meal, index);
                    container.appendChild(mealCard);
                });
            }
        }

        function createMealCard(meal, index, dayIndex = null, mealIndex = null) {
            const card = document.createElement('div');
            card.className = 'meal-card';
            card.id = `meal-${index}`;

            // For multi-day plans, pass both indices; for single-day, pass just the index
            const changeParam = dayIndex !== null ? `'${index}', ${dayIndex}, ${mealIndex}` : index;
            const reviseParam = dayIndex !== null ? `'${index}', ${dayIndex}, ${mealIndex}` : index;

            // Check if client view
            const urlParams = new URLSearchParams(window.location.search);
            const isClientView = urlParams.get('clientView') === 'true' || urlParams.get('share');

            // Check if meal is already favorited
            const isFavorited = clientFavorites.some(f => f.meal_name === meal.name);
            const favoriteClass = isFavorited ? 'active' : '';
            const favoriteIcon = isFavorited ? '‚ù§Ô∏è' : 'ü§ç';

            // Escape meal name for use in onclick
            const escapedMealName = meal.name.replace(/'/g, "\\'").replace(/"/g, '\\"');

            // Get existing note for this meal
            const mealNote = meal.coach_note || '';

            // Build notes section based on view type
            let notesSection = '';
            if (isClientView) {
                // Client view: show note if exists (read-only)
                if (mealNote) {
                    notesSection = `
                        <div class="meal-note-display" style="background: #fef3c7; border-left: 4px solid #f59e0b; padding: 12px 15px; margin-top: 15px; border-radius: 0 8px 8px 0;">
                            <div style="font-weight: 600; color: #92400e; font-size: 0.85em; margin-bottom: 6px;">üìù Coach Note:</div>
                            <div style="color: #78350f; font-size: 0.95em; line-height: 1.5; white-space: pre-wrap;">${linkifyText(mealNote)}</div>
                        </div>
                    `;
                }
            } else {
                // Coach view: show editable note field
                notesSection = `
                    <div class="meal-note-section" style="margin-top: 15px; background: #f0f9ff; padding: 12px; border-radius: 8px; border: 1px solid #bae6fd;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <span style="font-weight: 600; color: #0369a1; font-size: 0.85em;">üìù Note for Client:</span>
                            <button class="btn" onclick="saveMealNote('${index}', ${dayIndex}, ${mealIndex})" style="background: #0284c7; color: white; padding: 4px 12px; font-size: 0.8em; border-radius: 4px;">Save Note</button>
                        </div>
                        <textarea id="meal-note-${index}" style="width: 100%; min-height: 60px; padding: 8px; border: 1px solid #7dd3fc; border-radius: 6px; font-size: 0.9em; resize: vertical;" placeholder="Add a note for your client about this meal...">${mealNote}</textarea>
                    </div>
                `;
            }

            // Build action buttons - clients can also change/revise meals
            // Check if there's a previous state for undo
            const undoStateKey = dayIndex !== null ? `${dayIndex}-${mealIndex}` : `${index}`;
            const hasUndoState = previousMealStates[undoStateKey] !== undefined;
            const undoButton = hasUndoState
                ? `<button class="btn btn-undo" onclick="undoRevision(${changeParam})" title="Undo last revision">‚Ü©Ô∏è Undo</button>`
                : '';

            // Different buttons for custom vs AI-generated meals
            const isCustomMeal = meal.isCustom === true;

            // Edit button for custom meals, Revise button for AI meals
            // Only show if client has permission (or if coach view)
            let editOrReviseButton = '';
            if (!isClientView || clientPermissions.canReviseMeals) {
                editOrReviseButton = isCustomMeal
                    ? `<button class="btn btn-edit" onclick="editCustomMeal(${changeParam})" title="Edit this custom meal">‚úé Edit</button>`
                    : `<button class="btn btn-revise" onclick="reviseMeal(${changeParam})">‚úèÔ∏è Revise</button>`;
            }

            // Log to Diary button for clients only
            const logDiaryButton = isClientView
                ? `<button class="btn btn-log-diary" onclick="logMealToDiary('${escapedMealName}', '${meal.type || ''}', ${meal.calories || 0}, ${meal.protein || 0}, ${meal.carbs || 0}, ${meal.fat || 0})" title="Log this meal to your diary">üìã Log</button>`
                : '';

            // Change meal button (only if client has permission or coach view)
            const changeMealButton = (!isClientView || clientPermissions.canChangeMeals)
                ? `<button class="btn btn-change" onclick="changeMeal(${changeParam})">üîÑ Change</button>`
                : '';

            // Custom meal button (only if client has permission or coach view)
            const customMealButton = (!isClientView || clientPermissions.canCustomMeals)
                ? `<button class="btn btn-custom" onclick="customMeal(${changeParam})" title="Create exact meal from scratch">üéØ Custom</button>`
                : '';

            let actionButtons = `
                <button class="btn btn-favorite ${favoriteClass}" id="fav-${index}" onclick="toggleFavorite('${escapedMealName}', '${meal.type || ''}', ${meal.calories}, ${meal.protein}, ${meal.carbs}, ${meal.fat}, '${index}')" title="${isFavorited ? 'Remove from favorites' : 'Add to favorites'}">${favoriteIcon}</button>
                ${logDiaryButton}
                ${changeMealButton}
                ${editOrReviseButton}
                ${customMealButton}
                <button class="btn btn-recipe" onclick="getRecipe('${escapedMealName}')" title="Get cooking instructions">üìñ Recipe</button>
                ${undoButton}
            `;

            // Generate unique ID for meal image
            const mealImageId = `meal-img-${dayIndex !== null ? dayIndex + '-' + mealIndex : index}`;

            card.innerHTML = `
                <div class="meal-card-image-placeholder" id="${mealImageId}" data-meal-name="${escapedMealName}">
                    üçΩÔ∏è
                </div>
                <div class="meal-card-content">
                    <div class="meal-header">
                        <div class="meal-name">${meal.name}</div>
                        <div class="meal-actions">
                            ${actionButtons}
                        </div>
                    </div>
                    <div class="macro-grid">
                        <div class="macro-item">
                            <div class="macro-label">Calories</div>
                            <div class="macro-value">${meal.calories}</div>
                        </div>
                        <div class="macro-item">
                            <div class="macro-label">Protein</div>
                            <div class="macro-value">${meal.protein}g</div>
                        </div>
                        <div class="macro-item">
                            <div class="macro-label">Carbs</div>
                            <div class="macro-value">${meal.carbs}g</div>
                        </div>
                        <div class="macro-item">
                            <div class="macro-label">Fat</div>
                            <div class="macro-value">${meal.fat}g</div>
                        </div>
                    </div>
                    <div class="instructions">
                        <span class="instructions-label">üìù Instructions:</span>
                        ${meal.instructions}
                    </div>
                    ${notesSection}
                </div>
            `;
            return card;
        }

        // Update day totals after meal changes (undo, revise, change, custom)
        function updateDayTotals(dayIndex) {
            if (!currentPlan.multiDay || !currentPlan.days || !currentPlan.days[dayIndex]) {
                console.log('‚ö†Ô∏è updateDayTotals: Not a multi-day plan or invalid dayIndex');
                return;
            }

            const dayData = currentPlan.days[dayIndex];
            const dayTotalsDiv = document.getElementById(`day-totals-${dayIndex}`);

            if (!dayTotalsDiv) {
                console.log('‚ö†Ô∏è updateDayTotals: Could not find day-totals div for day', dayIndex);
                return;
            }

            // Recalculate totals from meals
            let dayTotals = { calories: 0, protein: 0, carbs: 0, fat: 0 };
            if (dayData.plan && Array.isArray(dayData.plan)) {
                dayData.plan.forEach(meal => {
                    dayTotals.calories += parseInt(meal.calories) || 0;
                    dayTotals.protein += parseInt(meal.protein) || 0;
                    dayTotals.carbs += parseInt(meal.carbs) || 0;
                    dayTotals.fat += parseInt(meal.fat) || 0;
                });
            }

            // Get targets (use day targets if available, otherwise use plan nutrition)
            const nutrition = currentPlan.nutrition || {};
            const targets = dayData.targets || nutrition;

            // Calculate variance
            const dayVariance = {
                calories: targets.calories ? ((dayTotals.calories - targets.calories) / targets.calories * 100) : 0,
                protein: targets.protein ? ((dayTotals.protein - targets.protein) / targets.protein * 100) : 0,
                carbs: targets.carbs ? ((dayTotals.carbs - targets.carbs) / targets.carbs * 100) : 0,
                fat: targets.fat ? ((dayTotals.fat - targets.fat) / targets.fat * 100) : 0
            };

            // Calculate macro distribution percentages
            const macroPercent = {
                protein: dayTotals.calories > 0 ? Math.round((dayTotals.protein * 4) / dayTotals.calories * 100) : 0,
                carbs: dayTotals.calories > 0 ? Math.round((dayTotals.carbs * 4) / dayTotals.calories * 100) : 0,
                fat: dayTotals.calories > 0 ? Math.round((dayTotals.fat * 9) / dayTotals.calories * 100) : 0
            };

            // Helper functions for display
            const getVarianceColor = (variancePercent) => {
                const abs = Math.abs(variancePercent);
                if (abs <= 10) return '#16a34a'; // green - within ¬±10%
                if (abs <= 20) return '#ca8a04'; // yellow - within ¬±20%
                return '#dc2626'; // red - over ¬±20%
            };

            const formatVariance = (actual, target, variancePercent) => {
                const diff = actual - target;
                const sign = diff >= 0 ? '+' : '';
                return `${sign}${diff} (${sign}${variancePercent.toFixed(1)}%)`;
            };

            // Update the day totals div
            dayTotalsDiv.innerHTML = `
                <p style="font-size: 0.85em; font-weight: 600; color: #666; margin-bottom: 10px;">Day ${dayData.day} Totals:</p>
                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; text-align: center;">
                    <div>
                        <p style="font-size: 0.75em; color: #888;">Calories</p>
                        <span style="font-weight: 700; color: ${getVarianceColor(dayVariance.calories)}">${dayTotals.calories}</span>
                        <p style="font-size: 0.7em; color: ${getVarianceColor(dayVariance.calories)}">${formatVariance(dayTotals.calories, targets.calories, dayVariance.calories)}</p>
                    </div>
                    <div>
                        <p style="font-size: 0.75em; color: #888;">Protein</p>
                        <span style="font-weight: 700; color: ${getVarianceColor(dayVariance.protein)}">${dayTotals.protein}g</span>
                        <span style="font-size: 0.7em; font-weight: 500; color: #10b981; display: block;">${macroPercent.protein}%</span>
                        <p style="font-size: 0.7em; color: ${getVarianceColor(dayVariance.protein)}">${formatVariance(dayTotals.protein, targets.protein, dayVariance.protein)}</p>
                    </div>
                    <div>
                        <p style="font-size: 0.75em; color: #888;">Carbs</p>
                        <span style="font-weight: 700; color: ${getVarianceColor(dayVariance.carbs)}">${dayTotals.carbs}g</span>
                        <span style="font-size: 0.7em; font-weight: 500; color: #f59e0b; display: block;">${macroPercent.carbs}%</span>
                        <p style="font-size: 0.7em; color: ${getVarianceColor(dayVariance.carbs)}">${formatVariance(dayTotals.carbs, targets.carbs, dayVariance.carbs)}</p>
                    </div>
                    <div>
                        <p style="font-size: 0.75em; color: #888;">Fat</p>
                        <span style="font-weight: 700; color: ${getVarianceColor(dayVariance.fat)}">${dayTotals.fat}g</span>
                        <span style="font-size: 0.7em; font-weight: 500; color: #3b82f6; display: block;">${macroPercent.fat}%</span>
                        <p style="font-size: 0.7em; color: ${getVarianceColor(dayVariance.fat)}">${formatVariance(dayTotals.fat, targets.fat, dayVariance.fat)}</p>
                    </div>
                </div>
                <div style="margin-top: 8px; text-align: center; font-size: 0.7em; color: #888;">
                    <span style="color: #16a34a;">‚óè</span> Within ¬±10% |
                    <span style="color: #ca8a04;">‚óè</span> Within ¬±20% |
                    <span style="color: #dc2626;">‚óè</span> Over ¬±20%
                </div>
            `;

            console.log(`‚úÖ Updated day ${dayIndex} totals:`, dayTotals);
        }

        async function undoRevision(index, dayIndex = null, mealIndex = null) {
            // Get the state key
            const stateKey = dayIndex !== null ? `${dayIndex}-${mealIndex}` : `${index}`;
            const previousState = previousMealStates[stateKey];

            if (!previousState) {
                alert('No previous state to undo');
                return;
            }

            console.log(`‚Ü©Ô∏è Undoing revision for meal ${stateKey}:`, previousState);

            // Restore the previous meal state
            if (dayIndex !== null && mealIndex !== null) {
                // Multi-day plan
                currentPlan.days[dayIndex].plan[mealIndex] = JSON.parse(JSON.stringify(previousState));
            } else {
                // Single-day plan
                currentPlan.meals[index] = JSON.parse(JSON.stringify(previousState));
            }

            // Remove the undo state (can only undo once)
            delete previousMealStates[stateKey];
            saveUndoStates(); // Persist to localStorage

            // Save to localStorage
            localStorage.setItem('currentMealPlan', JSON.stringify(currentPlan));

            // Save to database
            await savePlanToDatabase();

            // Re-render the FULL plan (like planner.html does)
            displayMealPlan();

            // Show success message
            alert('Undo successful! Meal restored to previous state.');
        }

        // ADJUST PORTIONS - Quick serving size adjustment with stepper
        let currentPortionMultiplier = 1.0;
        const PORTION_STEP = 0.25;
        const PORTION_MIN = 0.25;
        const PORTION_MAX = 3.0;

        function showPortionsDropdown(event, index, dayIndex = null, mealIndex = null) {
            // Remove any existing stepper/dropdown
            const existingStepper = document.querySelector('.portions-stepper');
            if (existingStepper) {
                existingStepper.remove();
            }
            const existingDropdown = document.querySelector('.portions-dropdown');
            if (existingDropdown) {
                existingDropdown.remove();
            }

            // Reset to 1.0x when opening
            currentPortionMultiplier = 1.0;

            const buttonElement = event.target;
            const stepper = document.createElement('div');
            stepper.className = 'portions-stepper';

            stepper.innerHTML = `
                <span class="portions-stepper-label">Adjust Portions</span>
                <div class="portions-stepper-controls">
                    <button class="portions-step-btn" id="portions-decrease" title="Decrease">‚àí</button>
                    <span class="portions-value" id="portions-value">1.0x</span>
                    <button class="portions-step-btn" id="portions-increase" title="Increase">+</button>
                </div>
                <div class="portions-presets">
                    <button class="portions-preset-btn" data-multiplier="0.5">¬Ω</button>
                    <button class="portions-preset-btn" data-multiplier="0.75">¬æ</button>
                    <button class="portions-preset-btn" data-multiplier="1.5">1.5x</button>
                    <button class="portions-preset-btn" data-multiplier="2">2x</button>
                </div>
                <button class="portions-stepper-apply" id="portions-apply">Apply</button>
            `;

            // Position the stepper below the button
            const rect = buttonElement.getBoundingClientRect();
            stepper.style.top = `${rect.bottom + 5}px`;
            stepper.style.left = `${rect.left}px`;

            document.body.appendChild(stepper);

            // Update display function
            const updateDisplay = () => {
                const valueEl = document.getElementById('portions-value');
                const decreaseBtn = document.getElementById('portions-decrease');
                const increaseBtn = document.getElementById('portions-increase');

                valueEl.textContent = `${currentPortionMultiplier.toFixed(2).replace(/\.?0+$/, '')}x`;
                decreaseBtn.disabled = currentPortionMultiplier <= PORTION_MIN;
                increaseBtn.disabled = currentPortionMultiplier >= PORTION_MAX;
            };

            // Decrease button
            document.getElementById('portions-decrease').onclick = (e) => {
                e.stopPropagation();
                if (currentPortionMultiplier > PORTION_MIN) {
                    currentPortionMultiplier = Math.max(PORTION_MIN, currentPortionMultiplier - PORTION_STEP);
                    updateDisplay();
                }
            };

            // Increase button
            document.getElementById('portions-increase').onclick = (e) => {
                e.stopPropagation();
                if (currentPortionMultiplier < PORTION_MAX) {
                    currentPortionMultiplier = Math.min(PORTION_MAX, currentPortionMultiplier + PORTION_STEP);
                    updateDisplay();
                }
            };

            // Preset buttons
            stepper.querySelectorAll('.portions-preset-btn').forEach(btn => {
                btn.onclick = (e) => {
                    e.stopPropagation();
                    currentPortionMultiplier = parseFloat(btn.dataset.multiplier);
                    updateDisplay();
                };
            });

            // Apply button
            document.getElementById('portions-apply').onclick = (e) => {
                e.stopPropagation();
                if (currentPortionMultiplier !== 1.0) {
                    adjustPortions(index, dayIndex, mealIndex, currentPortionMultiplier);
                }
                stepper.remove();
            };

            // Close stepper when clicking outside
            const closeStepper = (e) => {
                if (!stepper.contains(e.target) && e.target !== buttonElement) {
                    stepper.remove();
                    document.removeEventListener('click', closeStepper);
                }
            };
            setTimeout(() => document.addEventListener('click', closeStepper), 0);
        }

        /**
         * Scale ingredient amount string by multiplier
         * Examples: "Chicken Breast (200g)" √ó 1.5 ‚Üí "Chicken Breast (300g)"
         *           "Eggs (2 whole)" √ó 2 ‚Üí "Eggs (4 whole)"
         *           "Peanut Butter (1 tbsp)" √ó 1.5 ‚Üí "Peanut Butter (1.5 tbsp)"
         */
        function scaleIngredientAmount(ingredient, multiplier) {
            // Parse "Food Name (amount)" format
            const match = ingredient.match(/^(.+?)\s*\((.+?)\)$/);
            if (!match) return ingredient;

            const foodName = match[1];
            const amount = match[2];

            // Try to extract number from amount
            const numMatch = amount.match(/^([\d.]+(?:\/[\d]+)?)\s*(.*)$/);
            if (!numMatch) return ingredient;

            let number = numMatch[1];
            const unit = numMatch[2];

            // Handle fractions like "1/2"
            if (number.includes('/')) {
                const [num, denom] = number.split('/').map(parseFloat);
                number = num / denom;
            } else {
                number = parseFloat(number);
            }

            // Scale the number
            let scaledNumber = number * multiplier;

            // Round appropriately
            if (scaledNumber >= 10) {
                scaledNumber = Math.round(scaledNumber);
            } else if (scaledNumber >= 1) {
                scaledNumber = Math.round(scaledNumber * 10) / 10; // 1 decimal place
            } else {
                scaledNumber = Math.round(scaledNumber * 100) / 100; // 2 decimal places
            }

            // Ensure minimum of 1 for count-based units (eggs, slices, etc.)
            if (unit.match(/whole|slice|slices|tortilla|tortillas|egg|eggs|medium|large|small/i)) {
                if (scaledNumber < 1) scaledNumber = 1;
            }

            return `${foodName} (${scaledNumber} ${unit})`.trim();
        }

        async function adjustPortions(index, dayIndex, mealIndex, multiplier) {
            // Get the meal based on plan structure
            let meal;
            if (dayIndex !== null && mealIndex !== null) {
                // Multi-day plan
                meal = currentPlan.days[dayIndex].plan[mealIndex];
            } else {
                // Single-day plan
                meal = currentPlan.meals[index];
            }

            // Save current meal state for undo functionality
            const stateKey = dayIndex !== null ? `${dayIndex}-${mealIndex}` : `${index}`;
            previousMealStates[stateKey] = JSON.parse(JSON.stringify(meal));
            saveUndoStates();
            console.log(`üíæ Saved previous state for undo (portions):`, previousMealStates[stateKey]);

            // Scale macros proportionally
            meal.calories = Math.round(meal.calories * multiplier);
            meal.protein = Math.round(meal.protein * multiplier);
            meal.carbs = Math.round(meal.carbs * multiplier);
            meal.fat = Math.round(meal.fat * multiplier);

            // Scale ingredients array
            if (meal.ingredients && Array.isArray(meal.ingredients)) {
                meal.ingredients = meal.ingredients.map(ingredient => {
                    return scaleIngredientAmount(ingredient, multiplier);
                });
            }

            // Update meal name to reflect portion change
            const portionLabel = `${multiplier}x portion`;
            if (!meal.name.includes('portion')) {
                meal.name = `${meal.name} (${portionLabel})`;
            } else {
                // Replace existing portion label
                meal.name = meal.name.replace(/\s*\([0-9.]+x portion\)/, ` (${portionLabel})`);
            }

            // Save to localStorage
            localStorage.setItem('currentMealPlan', JSON.stringify(currentPlan));

            // Save to database
            await savePlanToDatabase();

            // Re-render the plan
            displayMealPlan();

            console.log(`‚öñÔ∏è Adjusted portions for ${meal.type}: ${multiplier}x`);
        }

        async function saveMealNote(index, dayIndex = null, mealIndex = null) {
            const textarea = document.getElementById(`meal-note-${index}`);
            const note = textarea.value.trim();
            const saveBtn = textarea.parentElement.querySelector('button');

            // Update the meal in currentPlan
            let meal;
            if (dayIndex !== null && mealIndex !== null) {
                // Multi-day plan
                meal = currentPlan.days[dayIndex].plan[mealIndex];
            } else if (currentPlan.meals) {
                // Single-day plan
                meal = currentPlan.meals[index];
            } else if (currentPlan.days) {
                // Fallback for days structure
                const parts = index.split('-');
                if (parts.length === 2) {
                    meal = currentPlan.days[parseInt(parts[0])].plan[parseInt(parts[1])];
                }
            }

            if (!meal) {
                alert('Error: Could not find meal to save note');
                return;
            }

            // Save the note to the meal
            meal.coach_note = note;

            // Show saving state
            const originalText = saveBtn.textContent;
            saveBtn.textContent = 'Saving...';
            saveBtn.disabled = true;

            try {
                // Get planId from URL
                const urlParams = new URLSearchParams(window.location.search);
                const planId = urlParams.get('planId');

                if (planId) {
                    // Save to database
                    const { error } = await supabaseClient
                        .from('coach_meal_plans')
                        .update({ plan_data: currentPlan })
                        .eq('id', planId);

                    if (error) throw error;
                }

                // Also update localStorage if available
                localStorage.setItem('currentMealPlan', JSON.stringify(currentPlan));

                saveBtn.textContent = 'Saved!';
                saveBtn.style.background = '#16a34a';

                setTimeout(() => {
                    saveBtn.textContent = originalText;
                    saveBtn.style.background = '#0284c7';
                    saveBtn.disabled = false;
                }, 2000);

            } catch (error) {
                console.error('Error saving note:', error);
                saveBtn.textContent = 'Error';
                saveBtn.style.background = '#dc2626';

                setTimeout(() => {
                    saveBtn.textContent = originalText;
                    saveBtn.style.background = '#0284c7';
                    saveBtn.disabled = false;
                }, 2000);
            }
        }

        async function reviseMeal(index, dayIndex = null, mealIndex = null) {
            // Get the meal based on plan structure
            let meal;
            if (dayIndex !== null && mealIndex !== null) {
                // Multi-day plan
                meal = currentPlan.days[dayIndex].plan[mealIndex];
            } else {
                // Single-day plan
                meal = currentPlan.meals[index];
            }

            // Use window.prompt() with comprehensive examples
            const revisionText = window.prompt(
`Revise "${meal.name}"?

Examples of what you can request:

üìä ADJUST PORTIONS:
‚Ä¢ "increase chicken to 250g"
‚Ä¢ "double the portion size"
‚Ä¢ "make this 800 calories"
‚Ä¢ "reduce carbs by 20g"

üîÑ SWAP INGREDIENTS:
‚Ä¢ "swap rice for sweet potato"
‚Ä¢ "replace chicken with salmon"
‚Ä¢ "use egg whites instead of whole eggs"

ü•ó DIETARY CHANGES:
‚Ä¢ "make it vegetarian"
‚Ä¢ "make it dairy-free"
‚Ä¢ "add more protein"

‚ú® OTHER:
‚Ä¢ "simplify - fewer ingredients"
‚Ä¢ "make it a smoothie instead"
‚Ä¢ "add avocado"

Enter your request:`,
                ''
            );

            if (!revisionText || !revisionText.trim()) {
                return; // User cancelled or entered empty string
            }

            const mealCard = document.getElementById(`meal-${index}`);

            // Save current meal state for undo functionality
            const stateKey = dayIndex !== null ? `${dayIndex}-${mealIndex}` : `${index}`;
            previousMealStates[stateKey] = JSON.parse(JSON.stringify(meal)); // Deep copy
            console.log(`üíæ Saved previous state for meal ${stateKey}:`, previousMealStates[stateKey]);
            saveUndoStates(); // Persist to localStorage

            // Show loading
            mealCard.innerHTML = '<div class="spinner"></div><p style="text-align:center;">Revising meal...</p>';

            try {
                // Use EXACT same prompt as planner.html for consistency
                const prompt = `Revise this meal based on user request: "${meal.name}" (${meal.type || 'meal'})

USER REQUEST: ${revisionText}

CURRENT MEAL:
- Calories: ${meal.calories}
- Protein: ${meal.protein}g
- Carbs: ${meal.carbs}g
- Fat: ${meal.fat}g
- Ingredients: ${meal.ingredients ? (Array.isArray(meal.ingredients) ? meal.ingredients.join(', ') : meal.ingredients) : 'N/A'}

REVISION RULES - Follow these carefully:

1. EXPLICIT AMOUNTS: If user specifies exact amount (e.g., "make salmon 200g", "use 2 eggs"),
   use EXACTLY that amount even if it changes the meal's total calories.

2. VAGUE INCREASE: If user says "increase salmon" or "more protein" (no specific amount),
   increase by a reasonable amount (~30-50%) AND reduce other ingredients to keep total calories similar.

3. SWAP INGREDIENT: If user says "swap salmon for chicken" or "replace rice with quinoa",
   calculate the NEW ingredient amount to match the CALORIES of the original ingredient.
   Example: 130g salmon (230 cal) ‚Üí ~140g chicken breast to match ~230 cal

4. ADD NEW INGREDIENT: If user says "add chicken" to a meal that has none,
   ADD it on top - the meal will be bigger. Don't reduce other ingredients.

5. COMPLETE REPLACEMENT: If user specifies a simple meal or uses words like
   "just", "only", "make it", "change to", or "replace with":
   - Return ONLY the EXACT ingredients they specify - NOTHING ELSE
   - Do NOT add milk, water, banana, oats, peanut butter or ANY other ingredients
   - Do NOT try to make it a "complete meal" or "balanced"
   - Example: "just protein shake 2 scoops" = {"ingredients": ["Whey Protein (2 scoops)"]} - ONLY ONE INGREDIENT
   - Example: "only eggs and toast" = {"ingredients": ["Eggs (2 whole)", "Whole Wheat Bread (2 slices)"]} - ONLY TWO INGREDIENTS
   - The user WANTS a simple/small meal - this is intentional, not a mistake

Diet: ${currentPlan.preferences?.dietType || 'any'}
${currentPlan.preferences?.allergies ? `Avoid: ${currentPlan.preferences.allergies}` : ''}

Use ONLY foods from USDA database - you can choose from 200+ foods including:
Proteins: Chicken Breast, Salmon, Ground Turkey, Eggs, Shrimp, Tofu, Greek Yogurt, Whey Protein
Carbs: Brown Rice, Quinoa, Sweet Potato, Oats, Whole Wheat Bread, Pasta
Fats: Olive Oil, Avocado, Almonds, Peanut Butter
Vegetables: Broccoli, Spinach, Bell Pepper, Asparagus, etc.

CRITICAL:
1. Return ingredients as ARRAY OF STRINGS with amounts in parentheses
2. DO NOT include calories/protein/carbs/fat - backend will calculate from database
MEAL NAME FORMAT: Include ALL key ingredient portions inline in parentheses

EXAMPLE FORMAT:
{"type":"${meal.type || 'meal'}","name":"Whey Protein Shake (2 scoops)","ingredients":["Whey Protein (2 scoops)"],"instructions":"Mix with water and consume."}

Return ONLY valid JSON. NO quotes in text - use apostrophes. Keep it brief.`;

                // Send isJson and targets, but skipAutoScale for revise (user controls portions)
                const response = await fetch(API_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt,
                        isJson: true,
                        skipAutoScale: true, // Don't auto-scale revisions - user controls the portions
                        targets: {
                            calories: meal.calories || 500,
                            protein: meal.protein || 30,
                            carbs: meal.carbs || 50,
                            fat: meal.fat || 15
                        },
                        mealsPerDay: 1
                    })
                });

                if (!response.ok) throw new Error('API request failed');

                const data = await response.json();

                let revisedMeal;
                // Handle new backend format (with USDA calculation)
                if (data.success && data.data) {
                    console.log('‚úÖ Using new format with USDA calculation');
                    revisedMeal = data.data;

                    // Validate that backend calculated macros
                    if (!revisedMeal.calories || revisedMeal.calories === 0) {
                        console.warn('‚ö†Ô∏è Backend returned zero calories - ingredients may not have matched');
                    }
                } else {
                    // FALLBACK: Old Gemini format (shouldn't happen with new code)
                    console.log('‚ö†Ô∏è Using old Gemini format - macros may be inaccurate');
                    let text = data.candidates[0].content.parts[0].text;
                    text = text.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim();
                    text = text.replace(/:\s*NaN/g, ': null');

                    const jsonMatch = text.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        text = jsonMatch[0];
                    }

                    revisedMeal = JSON.parse(text);
                }

                // Ensure meal has required fields
                revisedMeal.type = revisedMeal.type || meal.type || 'meal';
                revisedMeal.name = revisedMeal.name || 'Revised Meal';
                revisedMeal.instructions = revisedMeal.instructions || meal.instructions || '';

                // Use calculated macros - only fallback if truly undefined/null (not 0)
                // Note: 0 is a valid value if ingredient wasn't found, so log warning
                if (revisedMeal.calories === 0 || revisedMeal.calories === undefined || revisedMeal.calories === null) {
                    console.warn('‚ö†Ô∏è Backend returned 0/missing calories - ingredient may not be in database');
                }
                revisedMeal.calories = revisedMeal.calories !== undefined && revisedMeal.calories !== null ? revisedMeal.calories : meal.calories;
                revisedMeal.protein = revisedMeal.protein !== undefined && revisedMeal.protein !== null ? revisedMeal.protein : meal.protein;
                revisedMeal.carbs = revisedMeal.carbs !== undefined && revisedMeal.carbs !== null ? revisedMeal.carbs : meal.carbs;
                revisedMeal.fat = revisedMeal.fat !== undefined && revisedMeal.fat !== null ? revisedMeal.fat : meal.fat;

                // Save the revised meal to the correct location
                if (dayIndex !== null && mealIndex !== null) {
                    // Multi-day plan
                    currentPlan.days[dayIndex].plan[mealIndex] = revisedMeal;
                } else {
                    // Single-day plan
                    currentPlan.meals[index] = revisedMeal;
                }
                localStorage.setItem('currentMealPlan', JSON.stringify(currentPlan));

                // Save to database if viewing from database
                await savePlanToDatabase();

                // Refresh display
                displayMealPlan();

            } catch (error) {
                console.error('‚ùå Revision error:', error);
                alert('Failed to revise meal. Please try again.');
                displayMealPlan();
            }
        }

        // CUSTOM MEAL - Opens modal for custom meal creation
        function customMeal(index, dayIndex = null, mealIndex = null) {
            openCustomMealModal(index, dayIndex, mealIndex);
        }

        // EDIT CUSTOM MEAL - Opens modal pre-populated with existing meal data
        async function editCustomMeal(index, dayIndex = null, mealIndex = null) {
            // Get the existing meal data
            let meal;
            if (dayIndex !== null && mealIndex !== null) {
                meal = currentPlan.days[dayIndex].plan[mealIndex];
            } else {
                meal = currentPlan.meals[index];
            }

            if (!meal) {
                console.error('Could not find meal to edit');
                return;
            }

            // Open the modal first (this sets up the indices)
            openCustomMealModal(index, dayIndex, mealIndex);

            // Check if meal has full ingredient data (from Food Database)
            let ingredientData = meal.ingredientData;

            // If no ingredientData, try to parse and look up ingredients
            if ((!ingredientData || !Array.isArray(ingredientData) || ingredientData.length === 0) && meal.ingredients) {
                console.log('üîç No ingredientData found, attempting to parse ingredients...');
                ingredientData = await parseAndLookupIngredients(meal.ingredients);
            }

            if (ingredientData && Array.isArray(ingredientData) && ingredientData.length > 0) {
                // Load ingredients into Calculate tab
                customMealSelectedIngredients = JSON.parse(JSON.stringify(ingredientData));

                // Switch to calculate tab
                switchCustomMealTab('calculate');

                // Pre-populate meal name and instructions
                document.getElementById('calculatedMealName').value = meal.name || '';
                document.getElementById('calculatedMealInstructions').value = meal.instructions || '';

                // Render the ingredients and update totals
                renderCustomMealIngredients();
                updateCustomMealTotals();

                console.log('üìù Editing meal with ingredients:', customMealSelectedIngredients);
            } else {
                // Fall back to manual tab for meals without ingredient data
                switchCustomMealTab('manual');

                // Pre-populate the manual panel fields with existing meal data
                document.getElementById('customMealName').value = meal.name || '';
                document.getElementById('customMealCalories').value = meal.calories || '';
                document.getElementById('customMealProtein').value = meal.protein || '';
                document.getElementById('customMealCarbs').value = meal.carbs || '';
                document.getElementById('customMealFat').value = meal.fat || '';
                document.getElementById('customMealInstructions').value = meal.instructions || '';
            }
        }

        async function changeMeal(index, dayIndex = null, mealIndex = null) {
            // Get the meal based on plan structure
            let meal;
            let mealsPerDay = 1;
            let allMealNames = []; // Collect all meal names to avoid repetition

            if (dayIndex !== null && mealIndex !== null) {
                // Multi-day plan
                meal = currentPlan.days[dayIndex].plan[mealIndex];
                mealsPerDay = currentPlan.days[dayIndex].plan.length;
                // Collect ALL meal names from ALL days
                currentPlan.days.forEach(day => {
                    day.plan.forEach(m => {
                        if (m.name) allMealNames.push(m.name);
                    });
                });
            } else {
                // Single-day plan
                meal = currentPlan.meals[index];
                mealsPerDay = currentPlan.meals.length;
                // Collect all meal names
                currentPlan.meals.forEach(m => {
                    if (m.name) allMealNames.push(m.name);
                });
            }

            // Calculate per-meal targets based on MEAL TYPE (not equal distribution)
            // This ensures proper calorie distribution across the day
            const dailyNutrition = currentPlan.nutrition || {};
            const dailyCal = dailyNutrition.calories || 2000;
            const dailyProtein = dailyNutrition.protein || 150;
            const dailyCarbs = dailyNutrition.carbs || 200;
            const dailyFat = dailyNutrition.fat || 70;
            const mealType = meal.type?.toLowerCase() || 'meal';

            // Meal-type specific distribution percentages
            let calPercent = 0.25; // Default
            if (mealType === 'breakfast') calPercent = 0.27;
            else if (mealType === 'lunch') calPercent = 0.32;
            else if (mealType === 'dinner') calPercent = 0.28;
            else if (mealType === 'snack' || mealType === 'snack 1' || mealType === 'snack 2') calPercent = 0.13;

            const targetCalories = Math.round(dailyCal * calPercent);
            const targetProtein = Math.round(dailyProtein * calPercent);
            const targetCarbs = Math.round(dailyCarbs * calPercent);
            const targetFat = Math.round(dailyFat * calPercent);

            console.log(`üéØ Exchange targets for ${mealType} (${Math.round(calPercent * 100)}% of daily): ${targetCalories}cal, ${targetProtein}P, ${targetCarbs}C, ${targetFat}F`);
            console.log(`üö´ Meals to avoid (${allMealNames.length}):`, allMealNames);

            // Determine if high-protein strategy is needed
            const isHighProtein = targetProtein >= 40;
            const minIngredients = isHighProtein ? 4 : 3;

            // Build protein stacking guidance for high-protein meals
            let proteinStackingGuide = '';
            if (isHighProtein) {
                if (mealType === 'breakfast') {
                    proteinStackingGuide = `
PROTEIN STACKING (required for ${targetProtein}g protein):
Use 3-4 main ingredients with LARGER portions. Example: Eggs (3 whole) + Oats (60g dry) + Whey Protein (1 scoop) + Berries (100g) = ~45g protein
Keep it SIMPLE - fewer ingredients, bigger portions.`;
                } else {
                    proteinStackingGuide = `
PROTEIN STACKING (required for ${targetProtein}g protein):
Use 3-4 main ingredients with LARGER portions:
- Main protein: Chicken/Beef/Fish (150-200g) = 35-50g protein
- Carb: Rice/Potato (1 cup cooked or 150g)
- Vegetables: 1-2 cups (150-200g)
- Cooking fat: 1 tsp oil only (not 1 tbsp)
Keep it SIMPLE - fewer ingredients, bigger portions.`;
                }
            }

            const mealCard = document.getElementById(`meal-${index}`);

            // Save current meal state for undo functionality
            const stateKey = dayIndex !== null ? `${dayIndex}-${mealIndex}` : `${index}`;
            previousMealStates[stateKey] = JSON.parse(JSON.stringify(meal)); // Deep copy
            console.log(`üíæ Saved previous state for undo (change):`, previousMealStates[stateKey]);
            saveUndoStates(); // Persist to localStorage

            mealCard.innerHTML = '<div class="spinner"></div><p style="text-align:center;">Generating new meal...</p>';

            try {
                // Build the "avoid these meals" list for variety
                const avoidMealsList = allMealNames.length > 0
                    ? `\n\nNEVER generate any of these meals (they're already in the plan):\n${allMealNames.map(n => `- ${n}`).join('\n')}\n`
                    : '';

                // NEW: Prompt asks for ingredients array - backend will calculate macros from USDA database
                const variationSeed = Math.floor(Math.random() * 1000000);
                const prompt = `Generate a DIFFERENT ${meal.type || 'meal'} (not "${meal.name}").
[Variation: ${variationSeed}] - Generate something UNIQUE and CREATIVE.
${avoidMealsList}
STRICT Target Nutrition - the new meal MUST closely match these values:
- Calories: ${targetCalories} (stay within ¬±50 calories)
- Protein: ${targetProtein}g (stay within ¬±5g)
- Carbs: ${targetCarbs}g (stay within ¬±10g)
- Fat: ${targetFat}g (stay within ¬±5g)
${proteinStackingGuide}
Diet: ${currentPlan.preferences?.dietType || 'any'}
${currentPlan.preferences?.allergies ? `Avoid: ${currentPlan.preferences.allergies}` : ''}

IMPORTANT: Be CREATIVE and suggest a UNIQUE meal. Try different cuisines (Mexican, Asian, Mediterranean, American, Indian) and cooking styles.

Use ONLY foods from USDA database including:
Proteins: Chicken Breast, Salmon, Ground Turkey, Eggs, Egg Whites, Whey Protein, Shrimp, Tofu, Greek Yogurt, Tilapia, Cod, Tuna, Lean Beef, Pork Tenderloin
Carbs: Brown Rice, Quinoa, Sweet Potato, Oats, Whole Wheat Bread, Pasta, White Rice, Couscous, Black Beans, Chickpeas
Fats: Olive Oil, Avocado, Almonds, Peanut Butter, Walnuts, Cashews, Butter
Vegetables: Broccoli, Spinach, Bell Pepper, Asparagus, Zucchini, Mushrooms, Onions, Tomatoes, Carrots, Green Beans
Fruits: Blueberries, Strawberries, Banana, Apple, Orange

PORTION LIMITS (never exceed):
- Chicken/Fish: MAX 250g | Ground meat: MAX 200g | Eggs: MAX 4 whole
- Oats dry: MAX 80g | Rice/Pasta cooked: MAX 300g | Vegetables: MAX 200g

CRITICAL:
1. Return ingredients as ARRAY OF STRINGS with amounts in parentheses
2. DO NOT include calories/protein/carbs/fat values - the backend will calculate them
3. Use ${minIngredients}+ ingredients to hit targets - stack proteins if needed
4. Stay within portion limits - add more ingredients instead of exceeding limits
5. If original meal was small (under 400 cal), keep new meal small. If large (over 600 cal), keep it large.

Return ONLY valid JSON (NO markdown, NO backticks):
{
  "type": "${meal.type || 'meal'}",
  "name": "Meal Name (with key portions)",
  "ingredients": ["Ingredient 1 (amount)", "Ingredient 2 (amount)"],
  "instructions": "Cooking instructions"
}`;

                // NEW: Send isJson and targets to trigger backend USDA calculation
                const response = await fetch(API_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt,
                        isJson: true,
                        targets: {
                            calories: targetCalories,
                            protein: targetProtein,
                            carbs: targetCarbs,
                            fat: targetFat
                        },
                        mealsPerDay: 1
                    })
                });

                if (!response.ok) throw new Error('API request failed');

                const data = await response.json();

                let newMeal;
                // Handle new backend format (with USDA calculation)
                if (data.success && data.data) {
                    console.log('‚úÖ Using new format with USDA calculation');
                    newMeal = data.data;

                    // Validate that backend calculated macros
                    if (!newMeal.calories || newMeal.calories === 0) {
                        console.warn('‚ö†Ô∏è Backend returned zero calories - ingredients may not have matched');
                    }
                } else {
                    // FALLBACK: Old Gemini format
                    console.log('‚ö†Ô∏è Using old Gemini format - macros may be inaccurate');
                    let text = data.candidates[0].content.parts[0].text;
                    text = text.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim();
                    text = text.replace(/:\s*NaN/g, ': null');

                    const jsonMatch = text.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        text = jsonMatch[0];
                    }

                    newMeal = JSON.parse(text);
                }

                // Ensure meal has required fields
                newMeal.type = newMeal.type || meal.type || 'meal';
                newMeal.name = newMeal.name || 'New Meal';
                newMeal.instructions = newMeal.instructions || '';

                // Use calculated macros - only fallback if truly undefined/null (not 0)
                if (newMeal.calories === 0 || newMeal.calories === undefined || newMeal.calories === null) {
                    console.warn('‚ö†Ô∏è Backend returned 0/missing calories - ingredient may not be in database');
                }
                newMeal.calories = newMeal.calories !== undefined && newMeal.calories !== null ? newMeal.calories : meal.calories;
                newMeal.protein = newMeal.protein !== undefined && newMeal.protein !== null ? newMeal.protein : meal.protein;
                newMeal.carbs = newMeal.carbs !== undefined && newMeal.carbs !== null ? newMeal.carbs : meal.carbs;
                newMeal.fat = newMeal.fat !== undefined && newMeal.fat !== null ? newMeal.fat : meal.fat;

                // Save the new meal to the correct location
                if (dayIndex !== null && mealIndex !== null) {
                    // Multi-day plan
                    currentPlan.days[dayIndex].plan[mealIndex] = newMeal;
                } else {
                    // Single-day plan
                    currentPlan.meals[index] = newMeal;
                }
                localStorage.setItem('currentMealPlan', JSON.stringify(currentPlan));

                // Save to database if viewing from database
                await savePlanToDatabase();

                displayMealPlan();

            } catch (error) {
                console.error('‚ùå Change meal error:', error);
                alert('Failed to change meal. Please try again.');
                displayMealPlan();
            }
        }

        // REGENERATE ENTIRE DAY - Generate all new meals for a specific day
        async function regenerateDay(dayIndex) {
            if (!currentPlan.multiDay || !currentPlan.days || !currentPlan.days[dayIndex]) {
                alert('Cannot regenerate: Invalid day index');
                return;
            }

            const dayData = currentPlan.days[dayIndex];
            const dayNumber = dayData.day;
            const numMeals = dayData.plan.length;
            const targets = dayData.targets || currentPlan.nutrition;

            // Get meal structure from original day
            const mealTypes = dayData.plan.map(m => m.type || 'meal');

            // Build list of meals from other days to avoid repetition
            let otherDaysMeals = [];
            currentPlan.days.forEach((d, idx) => {
                if (idx !== dayIndex && d.plan) {
                    d.plan.forEach(meal => {
                        otherDaysMeals.push(meal.name);
                    });
                }
            });
            const avoidMealsText = otherDaysMeals.length > 0
                ? `\nDO NOT repeat these meals from other days: ${otherDaysMeals.slice(0, 10).join(', ')}`
                : '';

            // Show loading state on all meal cards for this day
            const container = document.getElementById('mealsContainer');
            const dayHeaders = container.querySelectorAll('.day-header');
            if (dayHeaders[dayIndex]) {
                let currentElement = dayHeaders[dayIndex].nextElementSibling;
                // Skip the day totals div
                if (currentElement) currentElement = currentElement.nextElementSibling;

                while (currentElement && !currentElement.classList.contains('day-header')) {
                    if (currentElement.classList.contains('meal-card')) {
                        currentElement.innerHTML = '<div class="spinner"></div><p style="text-align:center;">Regenerating day...</p>';
                    }
                    currentElement = currentElement.nextElementSibling;
                }
            }

            try {
                // Generate all meals for the day in one request
                // NEW: Ask for ingredients arrays - backend will calculate macros from USDA database
                const dailyCal = targets.calories || 2000;
                const variationSeed = Math.floor(Math.random() * 1000000);

                // Goal-based fat/oil guidance - STRICT LIMITS
                const userGoal = currentPlan.preferences?.goal || 'maintain';
                const dailyFat = targets.fat || 70;
                const fatPerMeal = Math.round(dailyFat / numMeals);
                const fatGuidance = userGoal === 'lose weight'
                    ? `üö® FAT RULES - STRICT LIMITS (${dailyFat}g daily = ~${fatPerMeal}g per meal):
- Nuts: MAX 28g per serving (NEVER 50g+!)
- Avocado: MAX 50g per meal
- DO NOT STACK fats: eggs OR nuts OR avocado - pick ONE per meal
- Eggs (3 whole) = 15g fat - no other fat needed

üç≥ BREAKFAST FAT STACKING - CRITICAL:
- Eggs + Ground Meat = ALREADY HIGH FAT ‚Üí NO butter/oil!
- Eggs (2) + Ground Turkey (100g) = 20g fat already
- If using eggs + meat: cook with spray, NOT butter/oil

üêü FATTY FISH STACKING - CRITICAL:
- Salmon, Mackerel, Sardines = HIGH FAT ‚Üí NO butter/oil!
- Salmon (150g) = 17g fat ‚Üí NO olive oil needed!
- ONLY add oil to LEAN fish: cod, tilapia, halibut, shrimp`
                    : `üö® FAT RULES - STRICT LIMITS (${dailyFat}g daily = ~${fatPerMeal}g per meal):
- Nuts: MAX 35g per serving (NEVER 50g+!)
- Avocado: MAX 75g per meal
- DO NOT STACK multiple fat sources in one meal
- ONE fat source per meal: eggs OR nuts OR avocado

üç≥ BREAKFAST FAT STACKING - CRITICAL:
- Eggs + Ground Meat = HIGH FAT COMBO ‚Üí skip butter/oil!
- Eggs (2) = 10g + Ground Turkey (100g) = 10g = 20g already
- Eggs (3) + Ground Beef (100g) = 25g fat ‚Üí NO room for oil
- If using eggs + any ground meat: use cooking spray, NOT butter

üêü FATTY FISH STACKING - CRITICAL:
- Salmon, Mackerel, Sardines = ALREADY HIGH FAT ‚Üí skip butter/oil!
- Salmon (150g) = 17g fat ‚Üí NO olive oil needed!
- Mackerel (150g) = 21g fat ‚Üí NO butter needed!
- LEAN fish (cod, tilapia, shrimp) = CAN add 1 tsp oil/butter`;

                const prompt = `Generate a COMPLETELY NEW ${numMeals}-meal plan for Day ${dayNumber}.
[Variation: ${variationSeed}] - Generate UNIQUE meals different from any previous generation.

Daily Nutrition Targets:
- Calories: ${dailyCal}
- Protein: ${targets.protein || 150}g
- Carbs: ${targets.carbs || 200}g
- Fat: ${targets.fat || 70}g

CRITICAL MEAL DISTRIBUTION - HARD LIMITS:
- BREAKFAST: ${Math.round(dailyCal * 0.25)}-${Math.round(dailyCal * 0.30)} calories (25-30% of daily)
- LUNCH: ${Math.round(dailyCal * 0.30)}-${Math.round(dailyCal * 0.35)} calories (30-35% of daily)
- DINNER: ${Math.round(dailyCal * 0.25)}-${Math.round(dailyCal * 0.30)} calories (25-30% of daily)
- SNACKS: ${Math.round(dailyCal * 0.10)}-${Math.round(dailyCal * 0.15)} calories each (10-15% of daily)
- ABSOLUTE MAXIMUM: No single meal can exceed ${Math.round(dailyCal * 0.40)} calories
- Violating these limits will cause errors

Required meal types (in order): ${mealTypes.join(', ')}

Diet: ${currentPlan.preferences?.dietType || 'any'}
${currentPlan.preferences?.allergies ? `Avoid: ${currentPlan.preferences.allergies}` : ''}${avoidMealsText}

${fatGuidance}

CRITICAL: Return ingredients as ARRAY OF STRINGS with amounts in parentheses for EACH meal.
DO NOT include calories/protein/carbs/fat values - the backend will calculate them from the USDA database.
Use common foods with specific amounts like: "Chicken Breast (150g)", "Brown Rice (1 cup cooked)", "Broccoli (150g)"
Keep meals SIMPLE: 3-4 main ingredients with LARGER portions. One protein + one carb + 1-2 vegetables.

üö® INSTRUCTION RULES:
- ONLY mention ingredients from your ingredients array - nothing else!
- Match EXACT quantities: "Eggs (2 whole)" in ingredients = "2 eggs" in instructions (NOT 3!)
- NO garnishes or toppings not in ingredients (no "top with almonds" unless almonds listed)
- Keep instructions simple - just cooking steps

Return ONLY a valid JSON array with ${numMeals} meal objects:
[
  {"type":"breakfast","name":"Meal Name (with portions)","ingredients":["Ingredient 1 (amount)","Ingredient 2 (amount)"],"instructions":"Cooking steps"},
  {"type":"lunch","name":"Another Meal (with portions)","ingredients":["Ingredient 1 (amount)","Ingredient 2 (amount)"],"instructions":"Steps"}
]

NO markdown, NO backticks, NO extra text. ONLY the JSON array.`;

                // NEW: Send isJson and targets to trigger backend USDA calculation
                const response = await fetch(API_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt,
                        isJson: true,
                        targets: {
                            calories: targets.calories || 2000,
                            protein: targets.protein || 150,
                            carbs: targets.carbs || 200,
                            fat: targets.fat || 70
                        },
                        mealsPerDay: numMeals
                    })
                });

                if (!response.ok) throw new Error('API request failed');

                const data = await response.json();

                let newMeals;
                // Handle new backend format (with Claude corrections)
                if (data.success && data.data) {
                    console.log('‚úÖ Using new format with Claude corrections');
                    newMeals = Array.isArray(data.data) ? data.data : [data.data];
                } else {
                    // FALLBACK: Old Gemini format
                    console.log('‚ö†Ô∏è Using old Gemini format');
                    let text = data.candidates[0].content.parts[0].text;
                    text = text.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim();
                    text = text.replace(/:\s*NaN/g, ': null');

                    // Extract JSON array
                    const jsonMatch = text.match(/\[[\s\S]*\]/);
                    if (jsonMatch) {
                        text = jsonMatch[0];
                    }
                    newMeals = JSON.parse(text);
                }

                // Validate and sanitize the meals
                if (!Array.isArray(newMeals) || newMeals.length === 0) {
                    throw new Error('Invalid response format');
                }

                // Sanitize and preserve all meal data including ingredients
                // Backend calculates macros from USDA database based on ingredients
                newMeals = newMeals.map((meal, i) => ({
                    type: meal.type || mealTypes[i] || 'meal',
                    name: meal.name || 'New Meal',
                    calories: parseInt(meal.calories) || Math.round(targets.calories / numMeals),
                    protein: parseInt(meal.protein) || Math.round(targets.protein / numMeals),
                    carbs: parseInt(meal.carbs) || Math.round(targets.carbs / numMeals),
                    fat: parseInt(meal.fat) || Math.round(targets.fat / numMeals),
                    ingredients: meal.ingredients || [],
                    instructions: meal.instructions || 'Follow recipe instructions.'
                }));

                // Update the day's meals
                currentPlan.days[dayIndex].plan = newMeals;
                localStorage.setItem('currentMealPlan', JSON.stringify(currentPlan));

                // Save to database if viewing from database
                await savePlanToDatabase();

                // Refresh the display
                displayMealPlan();

                console.log(`‚úÖ Day ${dayNumber} regenerated successfully`);

            } catch (error) {
                console.error('‚ùå Regenerate day error:', error);
                alert('Failed to regenerate day. Please try again.');
                displayMealPlan();
            }
        }

        // MEAL PREP GUIDE FUNCTIONS
        async function showMealPrepGuide() {
            const modal = document.getElementById('mealPrepModal');
            const content = document.getElementById('mealPrepContent');

            // Show modal with loading state
            modal.style.display = 'flex';
            content.innerHTML = `
                <div style="text-align: center; padding: 40px;">
                    <div class="loader" style="margin: 0 auto 20px; border: 4px solid #f3f3f3; border-top: 4px solid #0d9488; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite;"></div>
                    <p style="color: #666;">Generating your comprehensive meal prep guide...</p>
                </div>
            `;

            try {
                // Collect all meals from the plan (handle both single-day and multi-day)
                const allMeals = [];
                let numDays = 1;

                if (currentPlan.multiDay && currentPlan.days) {
                    // Multi-day plan: collect from all days
                    numDays = currentPlan.days.length;
                    currentPlan.days.forEach(dayData => {
                        if (dayData.plan && Array.isArray(dayData.plan)) {
                            dayData.plan.forEach(meal => {
                                allMeals.push({
                                    day: dayData.day,
                                    type: meal.type,
                                    name: meal.name,
                                    calories: meal.calories,
                                    protein: meal.protein,
                                    carbs: meal.carbs,
                                    fat: meal.fat
                                });
                            });
                        }
                    });
                } else if (currentPlan.meals && Array.isArray(currentPlan.meals)) {
                    // Single-day plan
                    currentPlan.meals.forEach(meal => {
                        allMeals.push({
                            type: meal.type,
                            name: meal.name,
                            calories: meal.calories,
                            protein: meal.protein,
                            carbs: meal.carbs,
                            fat: meal.fat
                        });
                    });
                }

                if (allMeals.length === 0) {
                    content.innerHTML = '<p style="text-align: center; color: #666;">No meal plan found.</p>';
                    return;
                }

                // Build meals list (include day number for multi-day plans)
                const mealsList = allMeals.map(m => {
                    if (m.day) {
                        return `Day ${m.day} ${m.type}: ${m.name}`;
                    }
                    return `${m.type}: ${m.name}`;
                }).join('\n');

                const prompt = `You are a professional meal prep consultant. Create a comprehensive meal prep guide for the following ${numDays}-day meal plan:

${mealsList}

Create a detailed, actionable meal prep guide with the following sections:

## üìù Shopping List Tips
Provide tips for efficient shopping based on this meal plan (best stores, what to buy in bulk, what to buy fresh, etc.)

## ‚è∞ Meal Prep Timeline
Provide a prep schedule (e.g., "Sunday: Cook all proteins", "Monday: Prep vegetables")
Include which meals to batch cook together
Suggest which components can be prepared ahead
Include estimated time for each prep session

## ü•° Storage Instructions
For EACH meal, specify:
- How long it keeps in the refrigerator (be specific: 3-4 days, 5-6 days, etc.)
- Whether it can be frozen and for how long
- Best storage containers (airtight, glass, etc.)
- Any special storage notes

## üî• Reheating Instructions
For EACH meal type, provide:
- Microwave instructions (time and power level)
- Oven/stovetop instructions if better quality
- Tips to maintain texture and flavor

## üí° Time-Saving Tips
- Batch cooking strategies (cook all chicken at once, prep all vegetables together, etc.)
- Make-ahead components (cook rice/grains in bulk, pre-chop vegetables, etc.)
- Kitchen shortcuts and efficiency tips
- Which meals taste better fresh vs reheated

Format the response in clean, readable markdown with clear headings and bullet points.
Be specific, practical, and actionable. Focus on making meal prep as easy and efficient as possible.`;

                const response = await callGeminiAPI(prompt);

                // Format the response nicely
                content.innerHTML = `<div style="line-height: 1.6;">${formatMarkdown(response)}</div>`;

            } catch (error) {
                console.error('Error generating meal prep guide:', error);
                content.innerHTML = `
                    <div style="text-align: center; color: #f44336; padding: 40px;">
                        <p style="font-weight: bold;">Error generating meal prep guide</p>
                        <p style="font-size: 14px; margin-top: 10px;">${escapeHtml(error.message)}</p>
                    </div>
                `;
            }
        }

        function closeMealPrepModal() {
            document.getElementById('mealPrepModal').style.display = 'none';
        }

        // Recipe Modal Functions
        async function getRecipe(mealName) {
            console.log('üìñ Getting recipe for:', mealName);
            const modal = document.getElementById('recipeModal');
            const content = document.getElementById('recipeContent');
            const title = document.getElementById('recipeTitle');

            if (!modal || !content) {
                console.error('‚ùå Recipe modal elements not found');
                alert('Error: Recipe modal not found. Please refresh the page.');
                return;
            }

            // Show modal with loading state
            title.textContent = 'üìñ ' + mealName;
            modal.style.display = 'flex';
            content.innerHTML = `
                <div style="text-align: center; padding: 40px;">
                    <div class="loader" style="margin: 0 auto 20px;"></div>
                    <p style="color: #666;">Generating recipe...</p>
                </div>
            `;

            try {
                const prompt = `Create a detailed recipe for "${mealName}".

Format with markdown:
### Ingredients
- List each ingredient with exact amounts

### Instructions
1. Step by step cooking instructions
2. Include cooking times and temperatures
3. Add any helpful tips

Keep it concise but complete.`;

                const response = await fetch('/.netlify/functions/generate-meal-plan', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt: prompt,
                        isRecipe: true
                    })
                });

                const data = await response.json();

                if (data.error) {
                    content.innerHTML = `<p style="color: #dc2626;">${escapeHtml(data.error)}</p>`;
                } else if (data.recipe || data.text || typeof data === 'string') {
                    const recipeText = data.recipe || data.text || data;
                    const html = formatMarkdown(recipeText);
                    content.innerHTML = `<div style="line-height: 1.6;">${html}</div>`;
                } else {
                    content.innerHTML = '<p style="color: #dc2626;">Error: Invalid recipe format received. Please try again.</p>';
                }
            } catch (error) {
                console.error('‚ùå Error generating recipe:', error);
                content.innerHTML = `<p style="color: #dc2626;">Error generating recipe: ${escapeHtml(error.message)}. Please try again.</p>`;
            }
        }

        function closeRecipeModal() {
            document.getElementById('recipeModal').style.display = 'none';
        }

        // ‚úÖ SECURITY: Escape HTML special characters to prevent XSS
        function escapeHtml(text) {
            if (!text || typeof text !== 'string') return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Simple markdown formatter (with XSS protection)
        function formatMarkdown(text) {
            if (!text || typeof text !== 'string') {
                console.error('formatMarkdown received invalid input:', text);
                throw new Error('Invalid response format from AI');
            }
            // First escape HTML to prevent XSS, then apply markdown formatting
            let escaped = escapeHtml(text);
            return escaped
                .replace(/^## (.+)$/gm, '<h2 style="font-size: 24px; font-weight: bold; margin: 30px 0 15px 0; color: #333;">$1</h2>')
                .replace(/^### (.+)$/gm, '<h3 style="font-size: 18px; font-weight: 600; margin: 20px 0 10px 0; color: #555;">$1</h3>')
                .replace(/^\* (.+)$/gm, '<li style="margin-left: 20px; margin-bottom: 8px;">$1</li>')
                .replace(/^- (.+)$/gm, '<li style="margin-left: 20px; margin-bottom: 8px;">$1</li>')
                .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                .replace(/\n\n/g, '</p><p style="margin: 12px 0;">')
                .replace(/^(?!<[hl]|<li)/gm, '<p style="margin: 12px 0;">')
                .replace(/<\/li>\n<li/g, '</li><li');
        }

        // API call to Gemini (reuse existing implementation if available, or add new one)
        async function callGeminiAPI(prompt) {
            const response = await fetch('/.netlify/functions/generate-meal-plan', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    prompt,
                    isJson: false // üÜï CRITICAL: This is a text-only request (markdown)
                })
            });

            if (!response.ok) {
                const errorText = await response.text();
                console.error('API Error:', errorText);
                throw new Error('Failed to generate meal prep guide');
            }

            const data = await response.json();
            console.log('API Response:', data);

            // NEW: Handle new backend format (with Claude corrections)
            if (data.success && data.data) {
                console.log('‚úÖ Using new format with Claude corrections');
                // Backend returns parsed data, convert to text if needed
                return typeof data.data === 'string' ? data.data : JSON.stringify(data.data);
            }

            // FALLBACK: Extract text from Gemini response structure
            if (data.candidates && data.candidates[0] && data.candidates[0].content) {
                console.log('‚ö†Ô∏è Using old Gemini format');
                const text = data.candidates[0].content.parts[0].text;
                if (!text) {
                    console.error('No text in response:', data);
                    throw new Error('Invalid response from AI service');
                }
                return text;
            }

            // Fallback: check for data.result (in case of different response format)
            if (data.result) {
                return data.result;
            }

            console.error('Unexpected response structure:', data);
            throw new Error('Invalid response from AI service');
        }

        async function downloadPDF() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();

            const margin = 15;
            const pageWidth = doc.internal.pageSize.getWidth();
            const maxWidth = pageWidth - (margin * 2);
            let y = 20;

            // === TITLE PAGE ===
            // Main Title with accent color
            doc.setFontSize(28);
            doc.setFont(undefined, 'bold');
            doc.setTextColor(102, 126, 234);
            doc.text('Personalized Meal Plan', margin, y);
            y += 4;

            // Decorative line under title
            doc.setDrawColor(102, 126, 234);
            doc.setLineWidth(1);
            doc.line(margin, y, margin + 85, y);
            y += 12;

            // Client Name (if available)
            if (currentPlan.clientName) {
                doc.setFontSize(14);
                doc.setFont(undefined, 'normal');
                doc.setTextColor(60, 60, 60);
                doc.text(`Prepared for: ${currentPlan.clientName}`, margin, y);
                y += 10;
            }

            // Daily Nutrition Summary Box
            const nutrition = currentPlan.nutrition;
            const boxY = y;
            const boxHeight = 28;

            // Background box
            doc.setFillColor(248, 249, 250);
            doc.setDrawColor(220, 220, 220);
            doc.setLineWidth(0.3);
            doc.roundedRect(margin, boxY, maxWidth, boxHeight, 3, 3, 'FD');

            // Box title
            y = boxY + 7;
            doc.setFontSize(11);
            doc.setFont(undefined, 'bold');
            doc.setTextColor(80, 80, 80);
            doc.text('Daily Nutrition Targets', margin + 5, y);
            y += 8;

            // Macro values in colored boxes
            const macros = [
                { label: 'Calories', value: String(nutrition.calories), color: { r: 231, g: 76, b: 60 } },
                { label: 'Protein', value: `${nutrition.protein}g`, color: { r: 46, g: 204, b: 113 } },
                { label: 'Carbs', value: `${nutrition.carbs}g`, color: { r: 241, g: 196, b: 15 } },
                { label: 'Fat', value: `${nutrition.fat}g`, color: { r: 230, g: 126, b: 34 } }
            ];

            let macroX = margin + 5;
            doc.setFontSize(10);
            macros.forEach((macro, i) => {
                // Colored dot
                doc.setFillColor(macro.color.r, macro.color.g, macro.color.b);
                doc.circle(macroX + 3, y - 2, 2, 'F');

                // Label and value
                doc.setFont(undefined, 'bold');
                doc.setTextColor(macro.color.r, macro.color.g, macro.color.b);
                doc.text(macro.value, macroX + 8, y);

                doc.setFont(undefined, 'normal');
                doc.setTextColor(100, 100, 100);
                const valueWidth = doc.getTextWidth(macro.value);
                doc.text(` ${macro.label}`, macroX + 8 + valueWidth, y);

                macroX += 45;
            });

            y = boxY + boxHeight + 12;

            // Collect all meals (handles both single-day and multi-day plans)
            let allMeals = [];
            if (currentPlan.multiDay && currentPlan.days) {
                // Multi-day plan: collect meals from all days
                currentPlan.days.forEach(dayData => {
                    if (dayData.plan && Array.isArray(dayData.plan)) {
                        dayData.plan.forEach(meal => {
                            allMeals.push({ ...meal, dayNumber: dayData.day });
                        });
                    }
                });
            } else if (currentPlan.meals) {
                // Single-day plan
                allMeals = currentPlan.meals;
            }

            // === MEALS SECTION ===
            allMeals.forEach((meal, index) => {
                // Add day header for multi-day plans
                if (meal.dayNumber && (index === 0 || meal.dayNumber !== allMeals[index - 1].dayNumber)) {
                    if (y > 250) {
                        doc.addPage();
                        y = 20;
                    }

                    // Day header with background
                    doc.setFillColor(102, 126, 234);
                    doc.roundedRect(margin, y - 5, 35, 10, 2, 2, 'F');
                    doc.setFontSize(14);
                    doc.setFont(undefined, 'bold');
                    doc.setTextColor(255, 255, 255);
                    doc.text(`Day ${meal.dayNumber}`, margin + 5, y + 2);
                    y += 12;
                }

                if (y > 220) {
                    doc.addPage();
                    y = 20;
                }

                // Meal card background
                const cardStartY = y - 3;

                // Meal Type Badge (if available)
                if (meal.type) {
                    // Use lowercase keys for case-insensitive matching
                    const typeColors = {
                        'breakfast': { r: 255, g: 152, b: 0 },    // Orange
                        'lunch': { r: 76, g: 175, b: 80 },        // Green
                        'dinner': { r: 63, g: 81, b: 181 },       // Indigo
                        'snack': { r: 156, g: 39, b: 176 },       // Purple
                        'pre-workout': { r: 244, g: 67, b: 54 },  // Red
                        'post-workout': { r: 0, g: 188, b: 212 }  // Cyan
                    };
                    const mealTypeLower = meal.type.toLowerCase();
                    const typeColor = typeColors[mealTypeLower] || { r: 96, g: 125, b: 139 };

                    // Display meal type with proper title case
                    const displayType = meal.type.charAt(0).toUpperCase() + meal.type.slice(1).toLowerCase();

                    doc.setFillColor(typeColor.r, typeColor.g, typeColor.b);
                    doc.setFontSize(8);
                    const badgeWidth = doc.getTextWidth(displayType) + 8;
                    doc.roundedRect(margin, y - 4, badgeWidth, 6, 1.5, 1.5, 'F');
                    doc.setFont(undefined, 'bold');
                    doc.setTextColor(255, 255, 255);
                    doc.text(displayType, margin + 4, y);
                    y += 6;
                }

                // Meal Name
                doc.setFontSize(13);
                doc.setFont(undefined, 'bold');
                doc.setTextColor(50, 50, 50);
                const mealNameLines = doc.splitTextToSize(meal.name, maxWidth);
                doc.text(mealNameLines, margin, y);
                y += mealNameLines.length * 5.5;

                // Macros inline with icons
                doc.setFontSize(9);
                doc.setFont(undefined, 'normal');
                const macroText = `${meal.calories} cal  |  ${meal.protein}g protein  |  ${meal.carbs}g carbs  |  ${meal.fat}g fat`;
                doc.setTextColor(120, 120, 120);
                doc.text(macroText, margin, y);
                y += 6;

                // Ingredients (if available)
                if (meal.ingredients && Array.isArray(meal.ingredients) && meal.ingredients.length > 0) {
                    doc.setFontSize(10);
                    doc.setTextColor(70, 70, 70);
                    doc.setFont(undefined, 'bold');
                    doc.text('Ingredients:', margin, y);
                    y += 5;
                    doc.setFont(undefined, 'normal');
                    doc.setFontSize(9);
                    doc.setTextColor(50, 50, 50);
                    meal.ingredients.forEach(ingredient => {
                        if (y > 270) {
                            doc.addPage();
                            y = 20;
                        }
                        const ingredientLines = doc.splitTextToSize(`‚Ä¢ ${ingredient}`, maxWidth - 5);
                        doc.text(ingredientLines, margin + 5, y);
                        y += ingredientLines.length * 4;
                    });
                    y += 2;
                }

                // Cooking Instructions
                if (meal.instructions) {
                    if (y > 255) {
                        doc.addPage();
                        y = 20;
                    }
                    doc.setFontSize(10);
                    doc.setFont(undefined, 'bold');
                    doc.setTextColor(70, 70, 70);
                    doc.text('Instructions:', margin, y);
                    y += 5;
                    doc.setFont(undefined, 'normal');
                    doc.setFontSize(9);
                    doc.setTextColor(50, 50, 50);
                    const instructionLines = doc.splitTextToSize(meal.instructions, maxWidth - 5);
                    doc.text(instructionLines, margin + 5, y);
                    y += instructionLines.length * 4;
                }

                // Separator line between meals
                y += 4;
                doc.setDrawColor(230, 230, 230);
                doc.setLineWidth(0.3);
                doc.line(margin, y, pageWidth - margin, y);
                y += 8;
            });

            // Grocery List - organized by category
            const groceryByCategory = aggregateGroceryListByCategory();
            const categoryOrder = ['proteins', 'carbs', 'vegetables', 'fruits', 'fats', 'dairy', 'condiments', 'other'];
            const categoryLabels = {
                proteins: 'PROTEINS',
                carbs: 'CARBS & GRAINS',
                vegetables: 'VEGETABLES',
                fruits: 'FRUITS',
                fats: 'FATS & NUTS',
                dairy: 'DAIRY',
                condiments: 'CONDIMENTS',
                other: 'OTHER'
            };

            const hasItems = Object.values(groceryByCategory).some(items => items && items.length > 0);
            if (hasItems) {
                doc.addPage();
                y = 20;

                // Shopping List Title with decorative styling
                doc.setFontSize(22);
                doc.setFont(undefined, 'bold');
                doc.setTextColor(102, 126, 234);
                doc.text('Shopping List', margin, y);
                y += 3;

                // Underline for title
                doc.setDrawColor(102, 126, 234);
                doc.setLineWidth(0.5);
                doc.line(margin, y, margin + 45, y);
                y += 12;

                // Category colors for visual distinction
                const categoryColors = {
                    proteins: { r: 231, g: 76, b: 60 },     // Red
                    carbs: { r: 241, g: 196, b: 15 },       // Yellow
                    vegetables: { r: 46, g: 204, b: 113 },  // Green
                    fruits: { r: 155, g: 89, b: 182 },      // Purple
                    fats: { r: 230, g: 126, b: 34 },        // Orange
                    dairy: { r: 52, g: 152, b: 219 },       // Blue
                    condiments: { r: 149, g: 165, b: 166 }, // Gray
                    other: { r: 127, g: 140, b: 141 }       // Dark gray
                };

                categoryOrder.forEach(category => {
                    const items = groceryByCategory[category];
                    if (!items || items.length === 0) return;

                    // Check if we need a new page
                    if (y > 245) {
                        doc.addPage();
                        y = 20;
                    }

                    // Category header with colored background
                    const color = categoryColors[category] || categoryColors.other;
                    const headerLabel = categoryLabels[category] || category.charAt(0).toUpperCase() + category.slice(1);

                    // Draw colored rectangle behind category name
                    doc.setFillColor(color.r, color.g, color.b);
                    const headerWidth = doc.getTextWidth(headerLabel) + 8;
                    doc.roundedRect(margin, y - 4, headerWidth, 7, 1, 1, 'F');

                    // Category text (white on colored background)
                    doc.setFontSize(11);
                    doc.setFont(undefined, 'bold');
                    doc.setTextColor(255, 255, 255);
                    doc.text(headerLabel, margin + 4, y);
                    y += 8;

                    // Items in this category
                    doc.setFontSize(10);
                    doc.setFont(undefined, 'normal');
                    doc.setTextColor(40, 40, 40);

                    items.forEach(item => {
                        if (y > 270) {
                            doc.addPage();
                            y = 20;
                        }
                        // Format quantity: whole numbers without decimal, small numbers with 1 decimal
                        let qty = item.quantity;
                        if (Number.isInteger(qty) || Math.abs(qty - Math.round(qty)) < 0.01) {
                            qty = Math.round(qty);
                        } else if (qty < 10) {
                            qty = qty.toFixed(1);
                        } else {
                            qty = Math.round(qty);
                        }

                        // Handle singular/plural for common units
                        let unit = item.unit;
                        if (qty == 1) {
                            // Singular forms
                            if (unit === 'slices') unit = 'slice';
                            if (unit === 'scoops') unit = 'scoop';
                        } else if (qty > 1) {
                            // Plural forms
                            if (unit === 'slice') unit = 'slices';
                            if (unit === 'scoop') unit = 'scoops';
                        }

                        // Format: checkbox + quantity + unit + name
                        const itemText = `[ ]  ${qty} ${unit} ${item.name}`;
                        doc.text(itemText, margin + 3, y);
                        y += 5.5;
                    });

                    y += 8; // Space between categories
                });
            }

            // Meal Prep Guide
            try {
                // Show loading indicator
                const loadingMsg = document.createElement('div');
                loadingMsg.id = 'pdf-loading';
                loadingMsg.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:white;padding:30px;border-radius:10px;box-shadow:0 4px 20px rgba(0,0,0,0.3);z-index:10001;text-align:center;';
                loadingMsg.innerHTML = '<div style="font-size:18px;font-weight:bold;margin-bottom:10px;">üìÑ Generating PDF...</div><div style="color:#666;">Adding meal prep guide</div>';
                document.body.appendChild(loadingMsg);

                // Generate meal prep guide
                const allMeals = [];
                let numDays = 1;

                if (currentPlan.multiDay && currentPlan.days) {
                    // Multi-day plan: collect from all days
                    numDays = currentPlan.days.length;
                    currentPlan.days.forEach(dayData => {
                        if (dayData.plan && Array.isArray(dayData.plan)) {
                            dayData.plan.forEach(meal => {
                                allMeals.push({
                                    day: dayData.day,
                                    type: meal.type,
                                    name: meal.name,
                                    calories: meal.calories,
                                    protein: meal.protein,
                                    carbs: meal.carbs,
                                    fat: meal.fat
                                });
                            });
                        }
                    });
                } else if (currentPlan.meals && Array.isArray(currentPlan.meals)) {
                    // Single-day plan
                    currentPlan.meals.forEach(meal => {
                        allMeals.push({
                            type: meal.type,
                            name: meal.name,
                            calories: meal.calories,
                            protein: meal.protein,
                            carbs: meal.carbs,
                            fat: meal.fat
                        });
                    });
                }

                // Build meals list (include day number for multi-day plans)
                const mealsList = allMeals.map(m => {
                    if (m.day) {
                        return `Day ${m.day} ${m.type}: ${m.name}`;
                    }
                    return `${m.type}: ${m.name}`;
                }).join('\n');

                const prompt = `You are a professional meal prep consultant. Create a comprehensive meal prep guide for the following ${numDays}-day meal plan:

${mealsList}

Create a detailed, actionable meal prep guide with the following sections:

## üìù Shopping List Tips
Provide tips for efficient shopping based on this meal plan (best stores, what to buy in bulk, what to buy fresh, etc.)

## ‚è∞ Meal Prep Timeline
Provide a day-by-day prep schedule (e.g., "Sunday: Cook all proteins", "Monday: Prep vegetables")
Include which meals to batch cook together
Suggest which components can be prepared ahead
Include estimated time for each prep session

## ü•° Storage Instructions
For EACH unique meal type, specify:
- How long it keeps in the refrigerator (be specific: 3-4 days, 5-6 days, etc.)
- Whether it can be frozen and for how long
- Best storage containers (airtight, glass, etc.)
- Any special storage notes

## üî• Reheating Instructions
For EACH unique meal type, provide:
- Microwave instructions (time and power level)
- Oven/stovetop instructions if better quality
- Tips to maintain texture and flavor

## üí° Time-Saving Tips
- Batch cooking strategies
- Make-ahead components
- Kitchen shortcuts and efficiency tips
- Which meals taste better fresh vs reheated

Format the response in clean, readable markdown with clear headings and bullet points.
Be specific, practical, and actionable. Keep it concise but comprehensive.`;

                const response = await callGeminiAPI(prompt);

                // Remove loading indicator
                document.body.removeChild(loadingMsg);

                // Add new page for meal prep guide
                doc.addPage();
                y = 20;

                // Title with decorative styling
                doc.setFontSize(22);
                doc.setFont(undefined, 'bold');
                doc.setTextColor(255, 107, 107);
                doc.text('Meal Prep Guide', margin, y);
                y += 3;

                // Decorative line under title
                doc.setDrawColor(255, 107, 107);
                doc.setLineWidth(0.5);
                doc.line(margin, y, margin + 50, y);
                y += 12;

                // Section icon colors for visual variety
                const sectionColors = {
                    'Shopping List Tips': { r: 46, g: 204, b: 113 },
                    'Meal Prep Timeline': { r: 52, g: 152, b: 219 },
                    'Storage Instructions': { r: 155, g: 89, b: 182 },
                    'Reheating Instructions': { r: 231, g: 76, b: 60 },
                    'Time-Saving Tips': { r: 241, g: 196, b: 15 }
                };

                // Parse and format the meal prep guide for PDF
                const lines = response.split('\n');
                doc.setTextColor(0, 0, 0);

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();

                    if (!line) {
                        y += 3; // Blank line spacing
                        continue;
                    }

                    // Check if we need a new page
                    if (y > 270) {
                        doc.addPage();
                        y = 20;
                    }

                    // Section headers (## )
                    if (line.startsWith('## ')) {
                        y += 6;
                        if (y > 260) {
                            doc.addPage();
                            y = 20;
                        }
                        const headerText = line.replace('## ', '').replace(/[üìù‚è∞ü•°üî•üí°]/g, '').trim();

                        // Get section color or use default
                        let sectionColor = { r: 102, g: 126, b: 234 };
                        for (const [key, color] of Object.entries(sectionColors)) {
                            if (headerText.toLowerCase().includes(key.toLowerCase().split(' ')[0])) {
                                sectionColor = color;
                                break;
                            }
                        }

                        // Colored accent bar
                        doc.setFillColor(sectionColor.r, sectionColor.g, sectionColor.b);
                        doc.rect(margin, y - 4, 3, 8, 'F');

                        doc.setFontSize(13);
                        doc.setFont(undefined, 'bold');
                        doc.setTextColor(sectionColor.r, sectionColor.g, sectionColor.b);
                        doc.text(headerText, margin + 6, y);
                        y += 8;
                        doc.setFont(undefined, 'normal');
                        doc.setTextColor(50, 50, 50);
                        continue;
                    }

                    // Subsection headers (### )
                    if (line.startsWith('### ')) {
                        y += 3;
                        if (y > 268) {
                            doc.addPage();
                            y = 20;
                        }
                        const subheaderText = line.replace('### ', '');
                        doc.setFontSize(10);
                        doc.setFont(undefined, 'bold');
                        doc.setTextColor(70, 70, 70);
                        doc.text(subheaderText, margin + 5, y);
                        y += 5;
                        doc.setFont(undefined, 'normal');
                        continue;
                    }

                    // Bullet points
                    if (line.startsWith('* ') || line.startsWith('- ')) {
                        doc.setFontSize(9);
                        doc.setTextColor(50, 50, 50);
                        const bulletText = line.replace(/^[*-] /, '').replace(/\*\*/g, '');
                        const bulletLines = doc.splitTextToSize(`‚Ä¢ ${bulletText}`, maxWidth - 15);

                        bulletLines.forEach((bulletLine, idx) => {
                            if (y > 275) {
                                doc.addPage();
                                y = 20;
                            }
                            doc.text(bulletLine, margin + (idx === 0 ? 6 : 10), y);
                            y += 4;
                        });
                        continue;
                    }

                    // Regular paragraph text
                    doc.setFontSize(9);
                    doc.setTextColor(50, 50, 50);
                    const textLines = doc.splitTextToSize(line, maxWidth - 5);
                    textLines.forEach(textLine => {
                        if (y > 275) {
                            doc.addPage();
                            y = 20;
                        }
                        doc.text(textLine, margin + 5, y);
                        y += 4;
                    });
                }

            } catch (error) {
                console.error('Error generating meal prep guide for PDF:', error);
                // Continue with PDF generation without meal prep guide
                const loadingEl = document.getElementById('pdf-loading');
                if (loadingEl) document.body.removeChild(loadingEl);
            }

            // Footer
            y += 10;
            if (y > 260) {
                doc.addPage();
                y = 20;
            }
            doc.setFontSize(8);
            doc.setTextColor(150, 150, 150);
            doc.text(`Generated on ${new Date().toLocaleDateString()}`, margin, y);

            doc.save('meal-plan.pdf');
        }

        // Helper functions for grocery list aggregation
        function parseIngredient(ingredient) {
            // Handle "FoodName (amount unit)" format - e.g., "Chicken Breast (122 g)"
            const parenMatch = ingredient.match(/^(.+?)\s*\((\d+(?:\.\d+)?)\s*([a-zA-Z]+(?:\s+[a-zA-Z]+)?)\)$/);
            if (parenMatch) {
                const name = parenMatch[1].trim();
                const quantity = parseFloat(parenMatch[2]);
                const unit = parenMatch[3].toLowerCase();
                return { quantity, unit, name };
            }

            // Handle "FoodName (count descriptor)" format - e.g., "Apple (2 medium)"
            const countMatch = ingredient.match(/^(.+?)\s*\((\d+)\s+([a-zA-Z]+)\)$/);
            if (countMatch) {
                const name = countMatch[1].trim();
                const quantity = parseInt(countMatch[2]);
                const unit = countMatch[3].toLowerCase();
                return { quantity, unit, name };
            }

            // Handle simple formats like "Olive Oil (1 tbsp)"
            const simpleMatch = ingredient.match(/^(.+?)\s*\((.+?)\)$/);
            if (simpleMatch) {
                const name = simpleMatch[1].trim();
                const amountStr = simpleMatch[2].trim();
                const amountParts = amountStr.match(/^(\d+(?:\.\d+)?)\s*(.*)$/);
                if (amountParts) {
                    return {
                        quantity: parseFloat(amountParts[1]),
                        unit: amountParts[2] || 'unit',
                        name
                    };
                }
                return { quantity: 1, unit: amountStr, name };
            }

            // Fallback for other formats
            return { quantity: 1, unit: 'unit', name: ingredient.trim() };
        }

        function normalizeUnit(quantity, unit) {
            // Strip "cooked", "dry", "raw" descriptors from unit
            // e.g., "g cooked" -> "g", "g dry" -> "g"
            let cleanUnit = unit.replace(/\s*(cooked|dry|raw)$/i, '').trim();

            // Only convert to larger units if quantity is large enough
            const conversions = {
                'tbsp': { base: 'tbsp', factor: 1 }, // Keep tbsp as-is for readability
                'tablespoon': { base: 'tbsp', factor: 1 },
                'tsp': { base: 'tsp', factor: 1 },
                'teaspoon': { base: 'tsp', factor: 1 },
                'oz': { base: 'oz', factor: 1 },
                'ounce': { base: 'oz', factor: 1 },
                'ml': { base: 'ml', factor: 1 },
                'milliliter': { base: 'ml', factor: 1 },
                // Normalize plural to singular for aggregation
                'slices': { base: 'slice', factor: 1 },
                'scoops': { base: 'scoop', factor: 1 },
                'cups': { base: 'cup', factor: 1 }
            };

            // For grams, only convert to kg if >= 1000g
            if ((cleanUnit === 'g' || cleanUnit === 'gram') && quantity >= 1000) {
                return { quantity: quantity / 1000, unit: 'kg' };
            }
            // Keep grams as grams
            if (cleanUnit === 'g' || cleanUnit === 'gram') {
                return { quantity, unit: 'g' };
            }

            if (conversions[cleanUnit]) {
                return {
                    quantity: quantity * conversions[cleanUnit].factor,
                    unit: conversions[cleanUnit].base
                };
            }

            return { quantity, unit: cleanUnit };
        }

        // Food category classification for organized shopping list
        // Order matters! More specific matches first
        const FOOD_CATEGORIES = {
            // Check vegetables FIRST to catch "green beans" before "beans"
            vegetables: ['green beans', 'broccoli', 'spinach', 'asparagus', 'zucchini', 'bell pepper', 'pepper', 'mushroom', 'onion', 'garlic', 'tomato', 'carrot', 'celery', 'lettuce', 'kale', 'cabbage', 'cauliflower', 'cucumber', 'eggplant'],
            proteins: ['chicken', 'turkey', 'beef', 'pork', 'steak', 'bison', 'lamb', 'cod', 'salmon', 'tilapia', 'tuna', 'shrimp', 'fish', 'mackerel', 'sardines', 'trout', 'halibut', 'mahi', 'sea bass', 'snapper', 'egg', 'greek yogurt', 'cottage cheese', 'whey protein', 'tofu', 'tempeh', 'lentils', 'beans', 'chickpeas', 'black beans'],
            carbs: ['rice', 'quinoa', 'oats', 'oatmeal', 'bread', 'pasta', 'potato', 'sweet potato', 'tortilla', 'couscous', 'barley', 'farro'],
            fruits: ['apple', 'banana', 'blueberr', 'strawberr', 'raspberr', 'blackberr', 'orange', 'grape', 'mango', 'pineapple', 'peach', 'pear', 'cherry', 'kiwi', 'watermelon', 'cantaloupe'],
            fats: ['olive oil', 'avocado oil', 'coconut oil', 'butter', 'ghee', 'peanut butter', 'almond butter', 'almonds', 'walnuts', 'cashews', 'pecans', 'pistachios', 'chia', 'flax', 'avocado', 'seeds'],
            dairy: ['milk', 'cheese', 'cream'],
            condiments: ['soy sauce', 'hot sauce', 'salsa', 'mustard', 'vinegar', 'honey', 'maple syrup', 'ketchup']
        };

        function categorizeFood(foodName) {
            const lower = foodName.toLowerCase();
            // Check in specific order: vegetables first to catch "green beans"
            const categoryOrder = ['vegetables', 'proteins', 'carbs', 'fruits', 'fats', 'dairy', 'condiments'];
            for (const category of categoryOrder) {
                for (const keyword of FOOD_CATEGORIES[category]) {
                    if (lower.includes(keyword)) {
                        return category;
                    }
                }
            }
            return 'other';
        }

        // Standardize food names for consistent aggregation
        function standardizeFoodName(name) {
            // First, convert underscores to spaces
            let std = name.trim().replace(/_/g, ' ');

            // Strip trailing "cooked", "dry", "raw" from name
            std = std.replace(/\s+(cooked|dry|raw)$/i, '');

            // Standardize common variations
            const replacements = {
                'bell peppers': 'Bell Pepper',
                'bell pepper': 'Bell Pepper',
                'green beans': 'Green Beans',
                'almonds': 'Almonds',
                'walnuts': 'Walnuts',
                'blueberries': 'Blueberries',
                'strawberries': 'Strawberries',
                'eggs': 'Eggs',
                'egg whites': 'Egg Whites',
                // Grains - all variations to base form
                'brown rice cooked': 'Brown Rice',
                'brown rice': 'Brown Rice',
                'quinoa cooked': 'Quinoa',
                'quinoa': 'Quinoa',
                'lentils cooked': 'Lentils',
                'lentils': 'Lentils',
                'oats': 'Oats',
                // Oils and sauces
                'olive oil': 'Olive Oil',
                'soy sauce': 'Soy Sauce',
                // Dairy
                'cottage cheese nonfat': 'Cottage Cheese Nonfat',
                'cottage cheese': 'Cottage Cheese',
                'greek yogurt nonfat': 'Greek Yogurt Nonfat',
                'greek yogurt': 'Greek Yogurt'
            };
            const lower = std.toLowerCase();
            if (replacements[lower]) {
                return replacements[lower];
            }
            // Title case the name
            return std.split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()).join(' ');
        }

        function aggregateGroceryList() {
            if (!currentPlan) return [];

            const aggregated = {};
            let allMeals = [];

            // Handle both multi-day and single-day plans
            if (currentPlan.multiDay && currentPlan.days) {
                // Multi-day plan: collect meals from all days
                currentPlan.days.forEach(dayData => {
                    if (dayData.plan && Array.isArray(dayData.plan)) {
                        allMeals = allMeals.concat(dayData.plan);
                    }
                });
            } else if (currentPlan.meals && Array.isArray(currentPlan.meals)) {
                // Single-day plan
                allMeals = currentPlan.meals;
            }

            // Aggregate ingredients from all meals
            allMeals.forEach(meal => {
                if (!meal.ingredients || !Array.isArray(meal.ingredients)) return;

                meal.ingredients.forEach(ingredient => {
                    const parsed = parseIngredient(ingredient);
                    const normalized = normalizeUnit(parsed.quantity, parsed.unit);
                    const stdName = standardizeFoodName(parsed.name);

                    const key = `${stdName.toLowerCase()}|${normalized.unit}`;
                    if (aggregated[key]) {
                        aggregated[key].quantity += normalized.quantity;
                    } else {
                        aggregated[key] = {
                            name: stdName,
                            quantity: normalized.quantity,
                            unit: normalized.unit,
                            category: categorizeFood(stdName)
                        };
                    }
                });
            });

            // Sort by category, then alphabetically within category
            const categoryOrder = ['proteins', 'carbs', 'vegetables', 'fruits', 'fats', 'dairy', 'condiments', 'other'];
            return Object.values(aggregated).sort((a, b) => {
                const catA = categoryOrder.indexOf(a.category);
                const catB = categoryOrder.indexOf(b.category);
                if (catA !== catB) return catA - catB;
                return a.name.localeCompare(b.name);
            });
        }

        function aggregateGroceryListByCategory() {
            const items = aggregateGroceryList();
            const byCategory = {};

            items.forEach(item => {
                const cat = item.category || 'other';
                if (!byCategory[cat]) byCategory[cat] = [];
                byCategory[cat].push(item);
            });

            return byCategory;
        }

        // ========== INTERACTIVE GROCERY LIST FUNCTIONS ==========

        // Get storage key for this plan's grocery checks
        function getGroceryStorageKey() {
            const planId = new URLSearchParams(window.location.search).get('planId') || 'default';
            return `grocery-checks-${planId}`;
        }

        // Load checked items from localStorage
        function loadGroceryChecks() {
            try {
                const stored = localStorage.getItem(getGroceryStorageKey());
                return stored ? JSON.parse(stored) : {};
            } catch (e) {
                return {};
            }
        }

        // Save checked items to localStorage
        function saveGroceryChecks(checks) {
            localStorage.setItem(getGroceryStorageKey(), JSON.stringify(checks));
        }

        // Category colors for visual distinction
        const CATEGORY_COLORS = {
            proteins: '#ef4444',
            carbs: '#eab308',
            vegetables: '#22c55e',
            fruits: '#a855f7',
            fats: '#f97316',
            dairy: '#3b82f6',
            condiments: '#6b7280',
            other: '#78716c'
        };

        const CATEGORY_LABELS = {
            proteins: 'Proteins',
            carbs: 'Carbs & Grains',
            vegetables: 'Vegetables',
            fruits: 'Fruits',
            fats: 'Fats & Nuts',
            dairy: 'Dairy',
            condiments: 'Condiments',
            other: 'Other'
        };

        // Show grocery list modal
        function showGroceryListModal() {
            const modal = document.getElementById('groceryListModal');
            const content = document.getElementById('groceryListContent');
            const progress = document.getElementById('groceryProgress');

            const groceryByCategory = aggregateGroceryListByCategory();
            const categoryOrder = ['proteins', 'carbs', 'vegetables', 'fruits', 'fats', 'dairy', 'condiments', 'other'];
            const checks = loadGroceryChecks();

            // Count total items
            let totalItems = 0;
            let checkedItems = 0;
            categoryOrder.forEach(cat => {
                const items = groceryByCategory[cat] || [];
                items.forEach(item => {
                    totalItems++;
                    const itemKey = `${cat}-${item.name}-${item.unit}`;
                    if (checks[itemKey]) checkedItems++;
                });
            });

            const hasItems = totalItems > 0;

            if (!hasItems) {
                content.innerHTML = `
                    <div class="grocery-empty">
                        <div class="grocery-empty-icon">üõí</div>
                        <p>No items in your shopping list.</p>
                        <p style="font-size: 0.9em; margin-top: 8px;">Add meals to your plan first.</p>
                    </div>
                `;
                progress.textContent = '0/0 items';
            } else {
                let html = '';

                categoryOrder.forEach(cat => {
                    const items = groceryByCategory[cat] || [];
                    if (items.length === 0) return;

                    const color = CATEGORY_COLORS[cat] || CATEGORY_COLORS.other;
                    const label = CATEGORY_LABELS[cat] || cat;

                    html += `
                        <div class="grocery-category">
                            <div class="grocery-category-header">
                                <span class="grocery-category-dot" style="background: ${color};"></span>
                                ${label} (${items.length})
                            </div>
                            <div class="grocery-items">
                    `;

                    items.forEach(item => {
                        const itemKey = `${cat}-${item.name}-${item.unit}`;
                        const isChecked = checks[itemKey];

                        // Format quantity
                        let qty = item.quantity;
                        if (Number.isInteger(qty) || Math.abs(qty - Math.round(qty)) < 0.01) {
                            qty = Math.round(qty);
                        } else if (qty < 10) {
                            qty = qty.toFixed(1);
                        } else {
                            qty = Math.round(qty);
                        }

                        html += `
                            <div class="grocery-item ${isChecked ? 'checked' : ''}" onclick="toggleGroceryItem(this, '${itemKey}')" data-key="${itemKey}">
                                <div class="grocery-checkbox">${isChecked ? '‚úì' : ''}</div>
                                <div class="grocery-item-text">
                                    <span class="grocery-item-qty">${qty} ${item.unit}</span> ${item.name}
                                </div>
                            </div>
                        `;
                    });

                    html += `
                            </div>
                        </div>
                    `;
                });

                content.innerHTML = html;
                progress.textContent = `${checkedItems}/${totalItems} items`;
            }

            modal.classList.add('show');
        }

        // Toggle a grocery item checkbox
        function toggleGroceryItem(element, itemKey) {
            const checks = loadGroceryChecks();
            const isNowChecked = !checks[itemKey];

            if (isNowChecked) {
                checks[itemKey] = true;
            } else {
                delete checks[itemKey];
            }

            saveGroceryChecks(checks);

            // Update UI
            element.classList.toggle('checked', isNowChecked);
            const checkbox = element.querySelector('.grocery-checkbox');
            checkbox.textContent = isNowChecked ? '‚úì' : '';

            // Update progress
            updateGroceryProgress();
        }

        // Update progress counter
        function updateGroceryProgress() {
            const checks = loadGroceryChecks();
            const groceryByCategory = aggregateGroceryListByCategory();
            const categoryOrder = ['proteins', 'carbs', 'vegetables', 'fruits', 'fats', 'dairy', 'condiments', 'other'];

            let totalItems = 0;
            let checkedItems = 0;

            categoryOrder.forEach(cat => {
                const items = groceryByCategory[cat] || [];
                items.forEach(item => {
                    totalItems++;
                    const itemKey = `${cat}-${item.name}-${item.unit}`;
                    if (checks[itemKey]) checkedItems++;
                });
            });

            document.getElementById('groceryProgress').textContent = `${checkedItems}/${totalItems} items`;
        }

        // Clear all checked items
        function clearGroceryChecks() {
            if (confirm('Clear all checked items?')) {
                localStorage.removeItem(getGroceryStorageKey());
                showGroceryListModal(); // Refresh the list
            }
        }

        // Close grocery list modal
        function closeGroceryListModal() {
            document.getElementById('groceryListModal').classList.remove('show');
        }

        // ========== FAVORITES FUNCTIONS ==========

        async function loadFavorites(clientId) {
            if (!clientId) return;

            try {
                const response = await fetch(`${TOGGLE_FAVORITE_ENDPOINT}?clientId=${clientId}`);
                if (response.ok) {
                    const data = await response.json();
                    clientFavorites = data.favorites || [];
                    console.log('Loaded favorites:', clientFavorites.length);
                }
            } catch (error) {
                console.error('Error loading favorites:', error);
            }
        }

        // Log meal to diary for clients
        async function logMealToDiary(mealName, mealType, calories, protein, carbs, fat) {
            // Ensure we have client context
            if (!currentClientId) {
                alert('Could not determine client. Please log in again.');
                return;
            }

            // Map meal type to diary meal type
            let diaryMealType = mealType.toLowerCase();
            if (diaryMealType === 'snacks' || diaryMealType === 'snack1' || diaryMealType === 'snack2') {
                diaryMealType = 'snack';
            }

            // Show loading feedback
            const btn = event.target;
            const originalContent = btn.innerHTML;
            btn.innerHTML = '...';
            btn.disabled = true;

            try {
                const response = await fetch('/.netlify/functions/food-diary', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        clientId: currentClientId,
                        coachId: currentCoachId,
                        entryDate: new Date().toISOString().split('T')[0], // Today's date
                        mealType: diaryMealType,
                        foodName: mealName,
                        servingSize: 1,
                        servingUnit: 'serving',
                        numberOfServings: 1,
                        calories: calories || 0,
                        protein: protein || 0,
                        carbs: carbs || 0,
                        fat: fat || 0,
                        foodSource: 'meal_plan',
                        notes: `From meal plan (${mealType})`
                    })
                });

                const data = await response.json();

                if (data.success) {
                    // Show success feedback
                    btn.innerHTML = '‚úì Logged';
                    btn.style.background = '#15803d';
                    setTimeout(() => {
                        btn.innerHTML = originalContent;
                        btn.style.background = '';
                        btn.disabled = false;
                    }, 2000);
                } else {
                    throw new Error(data.error || 'Failed to log meal');
                }
            } catch (error) {
                console.error('Error logging meal to diary:', error);
                btn.innerHTML = originalContent;
                btn.disabled = false;
                alert('Failed to log meal to diary. Please try again.');
            }
        }

        // Log entire meal plan to diary
        async function logEntirePlanToDiary() {
            // Ensure we have client context
            if (!currentClientId) {
                alert('Could not determine client. Please log in again.');
                return;
            }

            // Collect all meals from the plan
            let allMeals = [];

            if (currentPlan.multiDay && currentPlan.days) {
                // Multi-day plan: collect meals from all days
                currentPlan.days.forEach((dayData, dayIndex) => {
                    if (dayData.plan && Array.isArray(dayData.plan)) {
                        dayData.plan.forEach(meal => {
                            allMeals.push({
                                name: meal.name,
                                type: meal.type || '',
                                calories: meal.calories || 0,
                                protein: meal.protein || 0,
                                carbs: meal.carbs || 0,
                                fat: meal.fat || 0,
                                dayLabel: `Day ${dayData.day}`
                            });
                        });
                    }
                });
            } else if (currentPlan.meals) {
                // Single-day plan
                currentPlan.meals.forEach(meal => {
                    allMeals.push({
                        name: meal.name,
                        type: meal.type || '',
                        calories: meal.calories || 0,
                        protein: meal.protein || 0,
                        carbs: meal.carbs || 0,
                        fat: meal.fat || 0,
                        dayLabel: null
                    });
                });
            }

            if (allMeals.length === 0) {
                alert('No meals found in this plan to log.');
                return;
            }

            // Get button and section elements
            const btn = document.getElementById('logEntirePlanBtn');
            const section = document.getElementById('logEntirePlanSection');
            const hint = section.querySelector('.log-plan-hint');
            const originalBtnContent = btn.innerHTML;

            // Disable button and show progress
            btn.disabled = true;
            btn.innerHTML = `<span class="btn-icon">‚è≥</span><span class="btn-text">Logging 0/${allMeals.length}...</span>`;
            hint.innerHTML = '<span class="log-progress-text">Please wait while we log your meals...</span>';

            const today = new Date().toISOString().split('T')[0];
            let successCount = 0;
            let failCount = 0;

            // Log each meal
            for (let i = 0; i < allMeals.length; i++) {
                const meal = allMeals[i];

                // Update progress
                btn.innerHTML = `<span class="btn-icon">‚è≥</span><span class="btn-text">Logging ${i + 1}/${allMeals.length}...</span>`;

                // Normalize meal type
                let diaryMealType = meal.type.toLowerCase();
                if (diaryMealType === 'snacks' || diaryMealType === 'snack1' || diaryMealType === 'snack2') {
                    diaryMealType = 'snack';
                }
                if (!diaryMealType || diaryMealType === '') {
                    diaryMealType = 'snack'; // Default to snack if no type specified
                }

                // Build notes
                let notes = 'From meal plan';
                if (meal.dayLabel) {
                    notes = `From meal plan (${meal.dayLabel} - ${meal.type})`;
                } else if (meal.type) {
                    notes = `From meal plan (${meal.type})`;
                }

                try {
                    const response = await fetch('/.netlify/functions/food-diary', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            clientId: currentClientId,
                            coachId: currentCoachId,
                            entryDate: today,
                            mealType: diaryMealType,
                            foodName: meal.name,
                            servingSize: 1,
                            servingUnit: 'serving',
                            numberOfServings: 1,
                            calories: meal.calories,
                            protein: meal.protein,
                            carbs: meal.carbs,
                            fat: meal.fat,
                            foodSource: 'meal_plan',
                            notes: notes
                        })
                    });

                    const data = await response.json();

                    if (data.success) {
                        successCount++;
                    } else {
                        failCount++;
                        console.error('Failed to log meal:', meal.name, data.error);
                    }
                } catch (error) {
                    failCount++;
                    console.error('Error logging meal:', meal.name, error);
                }
            }

            // Show final result
            if (failCount === 0) {
                btn.innerHTML = `<span class="btn-icon">‚úì</span><span class="btn-text">All ${successCount} Meals Logged!</span>`;
                btn.style.background = 'linear-gradient(135deg, #15803d 0%, #166534 100%)';
                hint.innerHTML = `<span class="log-progress-text" style="color: #15803d;">‚úì Successfully logged all meals to today's diary. <a href="client-diary.html" style="color: #0369a1; font-weight: 600;">View Diary ‚Üí</a></span>`;
            } else {
                btn.innerHTML = `<span class="btn-icon">‚ö†Ô∏è</span><span class="btn-text">${successCount} Logged, ${failCount} Failed</span>`;
                btn.style.background = 'linear-gradient(135deg, #ca8a04 0%, #a16207 100%)';
                hint.innerHTML = `<span class="log-progress-text" style="color: #ca8a04;">Some meals could not be logged. Please try again or log them individually.</span>`;
            }

            // Reset button after delay
            setTimeout(() => {
                btn.innerHTML = originalBtnContent;
                btn.style.background = '';
                btn.disabled = false;
                hint.textContent = 'Log all meals from this plan to today\'s food diary';
            }, 5000);
        }

        async function toggleFavorite(mealName, mealType, calories, protein, carbs, fat, index) {
            // Get client ID from current context
            let clientId = null;
            let coachId = null;

            // Check URL params for client view
            const urlParams = new URLSearchParams(window.location.search);
            const isClientView = urlParams.get('clientView') === 'true';

            if (isClientView) {
                // Get client ID from session
                const { data: { session } } = await supabaseClient.auth.getSession();
                if (session) {
                    const { data: clientData } = await supabaseClient
                        .from('clients')
                        .select('id, coach_id')
                        .eq('user_id', session.user.id)
                        .single();

                    if (clientData) {
                        clientId = clientData.id;
                        coachId = clientData.coach_id;
                    }
                }
            }

            if (!clientId) {
                alert('Could not determine client. Please log in again.');
                return;
            }

            const btn = document.getElementById(`fav-${index}`);
            const originalContent = btn.innerHTML;
            btn.innerHTML = '...';
            btn.disabled = true;

            try {
                const response = await fetch(TOGGLE_FAVORITE_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        clientId,
                        coachId,
                        mealName,
                        mealType,
                        calories,
                        protein,
                        carbs,
                        fat
                    })
                });

                if (!response.ok) throw new Error('Failed to toggle favorite');

                const data = await response.json();

                if (data.action === 'added') {
                    btn.innerHTML = '‚ù§Ô∏è';
                    btn.classList.add('active');
                    btn.title = 'Remove from favorites';
                    clientFavorites.push({ meal_name: mealName });
                } else {
                    btn.innerHTML = 'ü§ç';
                    btn.classList.remove('active');
                    btn.title = 'Add to favorites';
                    clientFavorites = clientFavorites.filter(f => f.meal_name !== mealName);
                }

            } catch (error) {
                console.error('Error toggling favorite:', error);
                btn.innerHTML = originalContent;
            }

            btn.disabled = false;
        }

        // ============ SUPPLEMENT PROTOCOL FUNCTIONS ============

        let clientProtocols = [];
        let protocolSectionExpanded = true;

        async function loadClientProtocols(clientId, coachId) {
            if (!clientId || !coachId) {
                console.log('Missing clientId or coachId for loading protocols');
                return;
            }

            try {
                const response = await fetch(`${CLIENT_PROTOCOLS_ENDPOINT}?clientId=${clientId}&coachId=${coachId}`);

                if (!response.ok) {
                    throw new Error('Failed to fetch protocols');
                }

                const data = await response.json();
                clientProtocols = data.protocols || [];

                if (clientProtocols.length > 0) {
                    renderClientProtocols();
                    document.getElementById('protocolSection').style.display = 'block';
                }
            } catch (error) {
                console.error('Error loading protocols:', error);
            }
        }

        function renderClientProtocols() {
            const container = document.getElementById('protocolsList');
            if (!container) return;

            if (clientProtocols.length === 0) {
                container.innerHTML = '<p style="color: #999;">No supplements or protocols assigned yet.</p>';
                return;
            }

            const timingLabels = {
                'morning': 'Morning',
                'pre_workout': 'Pre-Workout',
                'post_workout': 'Post-Workout',
                'bedtime': 'Bedtime',
                'with_meals': 'With Meals',
                'custom': 'Custom'
            };

            const timingIcons = {
                'morning': 'üåÖ',
                'pre_workout': 'üí™',
                'post_workout': 'üèãÔ∏è',
                'bedtime': 'üåô',
                'with_meals': 'üçΩÔ∏è',
                'custom': '‚è∞'
            };

            let html = '<div style="display: flex; flex-direction: column; gap: 15px;">';

            clientProtocols.forEach(protocol => {
                const icon = timingIcons[protocol.timing] || 'üíä';
                const timingText = protocol.timing === 'custom' && protocol.timing_custom
                    ? protocol.timing_custom
                    : timingLabels[protocol.timing] || protocol.timing;

                html += `
                    <div style="background: white; border: 2px solid #e0e7ff; border-radius: 12px; padding: 15px;">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                            <div style="flex: 1;">
                                <div style="font-weight: 700; color: #0d9488; font-size: 1.1em; margin-bottom: 8px;">
                                    ${icon} ${protocol.name}
                                </div>
                                <div style="color: #666; font-size: 0.9em; margin-bottom: 5px;">
                                    <strong>Timing:</strong> ${timingText}
                                </div>`;

                // Show dose or schedule
                if (protocol.has_schedule && protocol.schedule && protocol.schedule.length > 0) {
                    html += `
                                <div style="color: #666; font-size: 0.9em; margin-bottom: 5px;">
                                    <strong>üìÖ Scheduled:</strong>
                                    <ul style="margin: 5px 0 0 20px; padding: 0;">`;
                    protocol.schedule.forEach(phase => {
                        html += `<li style="color: #7c3aed;">Week ${phase.weekStart}-${phase.weekEnd}: ${phase.dose}</li>`;
                    });
                    html += `</ul>`;
                    if (protocol.start_date) {
                        const startDate = new Date(protocol.start_date).toLocaleDateString();
                        html += `<div style="margin-top: 5px;"><strong>Start Date:</strong> ${startDate}</div>`;
                    }
                    html += `</div>`;
                } else if (protocol.dose) {
                    html += `
                                <div style="color: #666; font-size: 0.9em;">
                                    <strong>Dose:</strong> ${protocol.dose}
                                </div>`;
                }

                // Show public notes (not private_notes)
                if (protocol.notes) {
                    html += `
                                <div style="margin-top: 10px; padding: 10px; background: #f0fdf4; border-radius: 8px; color: #166534; font-size: 0.9em;">
                                    üìù ${protocol.notes}
                                </div>`;
                }

                html += `
                            </div>
                        </div>
                    </div>`;
            });

            html += '</div>';
            container.innerHTML = html;
        }

        function toggleProtocolSection() {
            const content = document.getElementById('protocolContent');
            const icon = document.getElementById('protocolToggleIcon');

            protocolSectionExpanded = !protocolSectionExpanded;

            if (protocolSectionExpanded) {
                content.style.display = 'block';
                icon.textContent = '‚ñº';
            } else {
                content.style.display = 'none';
                icon.textContent = '‚ñ∂';
            }
        }

        // ============================================
        // MEAL IMAGE LOADING (Optimized with batch + cache)
        // ============================================
        const MEAL_IMAGE_BATCH_ENDPOINT = '/.netlify/functions/meal-image-batch';
        const IMAGE_CACHE_KEY = 'mealImageCache';
        const IMAGE_CACHE_EXPIRY = 24 * 60 * 60 * 1000; // 24 hours

        // Get cached images from localStorage
        function getImageCache() {
            try {
                const cached = localStorage.getItem(IMAGE_CACHE_KEY);
                if (!cached) return {};
                const { data, timestamp } = JSON.parse(cached);
                if (Date.now() - timestamp > IMAGE_CACHE_EXPIRY) {
                    localStorage.removeItem(IMAGE_CACHE_KEY);
                    return {};
                }
                return data || {};
            } catch (e) {
                return {};
            }
        }

        // Save images to localStorage cache
        function saveImageCache(newImages) {
            try {
                const existing = getImageCache();
                const merged = { ...existing, ...newImages };
                localStorage.setItem(IMAGE_CACHE_KEY, JSON.stringify({
                    data: merged,
                    timestamp: Date.now()
                }));
            } catch (e) {
                console.warn('Failed to cache images:', e);
            }
        }

        // Apply image to container with smooth fade-in
        function applyImageToContainer(container, imageUrl, mealName) {
            if (!container || !container.classList.contains('meal-card-image-placeholder')) return;

            const img = document.createElement('img');
            img.src = imageUrl;
            img.alt = mealName;
            img.className = 'meal-card-image';
            img.id = container.id;
            img.dataset.mealName = mealName;
            img.loading = 'lazy';
            img.decoding = 'async'; // Non-blocking decode

            // Smooth fade-in when image loads
            img.onload = () => {
                img.classList.add('loaded');
            };

            img.onerror = () => {
                const placeholder = document.createElement('div');
                placeholder.className = 'meal-card-image-placeholder';
                placeholder.id = img.id;
                placeholder.dataset.mealName = mealName;
                placeholder.innerHTML = 'üçΩÔ∏è';
                placeholder.title = 'Image unavailable';
                placeholder.style.animation = 'none'; // Stop shimmer on error
                if (img.parentNode) {
                    img.parentNode.replaceChild(placeholder, img);
                }
            };

            container.replaceWith(img);
        }

        // Load cached meal images using batch endpoint
        async function loadCachedMealImages() {
            console.log('üñºÔ∏è Loading meal images...');
            const imageContainers = document.querySelectorAll('.meal-card-image-placeholder[data-meal-name]');

            if (imageContainers.length === 0) return;

            const containerMap = {};
            const mealNames = [];
            const localCache = getImageCache();
            const needsFetch = [];

            imageContainers.forEach(container => {
                const mealName = container.dataset.mealName;
                if (!mealName) return;

                containerMap[mealName] = containerMap[mealName] || [];
                containerMap[mealName].push(container);

                if (localCache[mealName]) {
                    applyImageToContainer(container, localCache[mealName], mealName);
                } else if (!mealNames.includes(mealName)) {
                    mealNames.push(mealName);
                    needsFetch.push(mealName);
                }
            });

            console.log(`üì¶ ${Object.keys(localCache).length} cached, ${needsFetch.length} need fetch`);

            if (needsFetch.length === 0) {
                console.log('üñºÔ∏è All images loaded from cache!');
                return;
            }

            try {
                const response = await fetch(MEAL_IMAGE_BATCH_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mealNames: needsFetch })
                });

                if (!response.ok) throw new Error('Batch fetch failed');

                const data = await response.json();
                const newImages = {};

                Object.entries(data.images || {}).forEach(([mealName, imageUrl]) => {
                    if (imageUrl) {
                        newImages[mealName] = imageUrl;
                        const containers = containerMap[mealName] || [];
                        containers.forEach(container => {
                            applyImageToContainer(container, imageUrl, mealName);
                        });
                    }
                });

                if (Object.keys(newImages).length > 0) {
                    saveImageCache(newImages);
                }

                console.log(`üñºÔ∏è Loaded ${Object.keys(newImages).length} new images`);

            } catch (error) {
                console.error('Batch image fetch error:', error);
            }
        }

        // Load images after plan is displayed (reduced delay)
        const originalDisplayMealPlan = displayMealPlan;
        displayMealPlan = function() {
            originalDisplayMealPlan();
            setTimeout(loadCachedMealImages, 100);
        };
    </script>

    <!-- PWA Service Worker Registration -->
    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then(reg => console.log('SW registered:', reg.scope))
                    .catch(err => console.log('SW registration failed:', err));
            });
        }
    </script>

    <!-- Bottom Navigation (Client only) -->
    <nav class="bottom-nav" id="clientBottomNav" style="display: none;">
        <a href="client-dashboard.html" class="bottom-nav-item">
            <div class="nav-icon">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" width="24" height="24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"/>
                </svg>
            </div>
            <span class="nav-label">Home</span>
        </a>
        <a href="client-diary.html" class="bottom-nav-item">
            <div class="nav-icon">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" width="24" height="24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2"/>
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6M9 16h6"/>
                </svg>
            </div>
            <span class="nav-label">Diary</span>
        </a>
        <a href="client-plans.html" class="bottom-nav-item active">
            <div class="nav-icon">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" width="24" height="24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01"/>
                </svg>
            </div>
            <span class="nav-label">Plans</span>
        </a>
        <a href="client-settings.html" class="bottom-nav-item">
            <div class="nav-icon">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24" width="24" height="24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"/>
                </svg>
            </div>
            <span class="nav-label">Profile</span>
        </a>
    </nav>
    <script>
        // Show bottom nav only for clients viewing their plan
        (function() {
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('clientView') === 'true') {
                document.getElementById('clientBottomNav').style.display = 'flex';
                // Add padding to container for bottom nav
                document.querySelector('.container').style.paddingBottom = '100px';
            }
        })();
    </script>
</body>
</html>
