<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Your Meal Plan - Zique Fitness Nutrition</title>
    <!-- Prevent caching to avoid stale data on back navigation -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0d9488 0%, #0284c7 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .header h1 {
            color: #0d9488;
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .back-btn:hover {
            color: #0284c7;
        }

        .client-info {
            background: #f8f9ff;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 30px;
        }

        .section-title {
            color: #0d9488;
            font-weight: 700;
            font-size: 1.1em;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e0e7ff;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .info-item {
            padding: 15px;
            background: white;
            border-radius: 10px;
            border: 2px solid #e0e7ff;
        }

        .info-label {
            color: #0d9488;
            font-weight: 600;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .info-value {
            color: #333;
            font-size: 1.2em;
            font-weight: 700;
        }

        .meal-card {
            background: #f8f9ff;
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 25px;
            border: 2px solid #e0e7ff;
        }

        .meal-header {
            display: flex;
            flex-direction: column;
            margin-bottom: 20px;
            gap: 15px;
        }

        .meal-name {
            color: #0d9488;
            font-size: 1.8em;
            font-weight: 700;
            word-wrap: break-word;
            overflow-wrap: break-word;
            flex: 1;
            min-width: 0;
        }

        .meal-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9em;
        }

        .btn-change {
            background: #0d9488;
            color: white;
        }

        .btn-change:hover {
            background: #5568d3;
            transform: translateY(-2px);
        }

        .btn-revise {
            background: #0284c7;
            color: white;
        }

        .btn-revise:hover {
            background: #653a8a;
            transform: translateY(-2px);
        }

        .btn-undo {
            background: #dc2626;
            color: white;
        }

        .btn-undo:hover {
            background: #b91c1c;
            transform: translateY(-2px);
        }

        .btn-custom {
            background: #7c3aed;
            color: white;
        }

        .btn-custom:hover {
            background: #6d28d9;
            transform: translateY(-2px);
        }

        .btn-portions {
            background: #0891b2;
            color: white;
        }

        .btn-portions:hover {
            background: #0e7490;
            transform: translateY(-2px);
        }

        .portions-dropdown {
            position: absolute;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            min-width: 120px;
            overflow: hidden;
        }

        .portions-dropdown button {
            display: block;
            width: 100%;
            padding: 10px 16px;
            text-align: left;
            border: none;
            background: white;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        .portions-dropdown button:hover {
            background: #f0f9ff;
        }

        .btn-favorite {
            background: transparent;
            color: #e53e3e;
            border: 2px solid #fed7d7;
            padding: 8px 14px;
            font-size: 1.1em;
        }

        .btn-favorite:hover {
            background: #fed7d7;
            transform: translateY(-2px);
        }

        .btn-favorite.active {
            background: #fed7d7;
            color: #c53030;
        }

        .modified-badge {
            display: inline-block;
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: white;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.7em;
            font-weight: 600;
            margin-left: 10px;
            vertical-align: middle;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .btn-reset {
            background: linear-gradient(135deg, #6b7280, #4b5563);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            margin-left: 10px;
        }

        .btn-reset:hover {
            background: linear-gradient(135deg, #4b5563, #374151);
            transform: translateY(-1px);
        }

        .modified-notice {
            background: linear-gradient(135deg, #fef3c7, #fde68a);
            border-left: 4px solid #f59e0b;
            padding: 12px 16px;
            margin-bottom: 20px;
            border-radius: 0 8px 8px 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .modified-notice p {
            margin: 0;
            color: #92400e;
            font-size: 0.9em;
        }

        .macro-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .macro-item {
            background: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid #e0e7ff;
        }

        .macro-label {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .macro-value {
            color: #0d9488;
            font-size: 1.5em;
            font-weight: 700;
        }

        .instructions {
            background: #fff4e6;
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #ffa726;
            margin-top: 15px;
        }

        .instructions-label {
            color: #e65100;
            font-weight: 600;
            margin-bottom: 8px;
            display: block;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            margin-top: 40px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn-primary {
            background: linear-gradient(135deg, #0d9488 0%, #0284c7 100%);
            color: white;
            padding: 15px 40px;
            font-size: 1.1em;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
            padding: 15px 40px;
            font-size: 1.1em;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .revise-section {
            margin-top: 15px;
            padding: 15px;
            background: white;
            border-radius: 10px;
        }

        .revise-input {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #0d9488;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 10px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes slideIn {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @keyframes slideOut {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 20px;
            padding: 40px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            box-sizing: border-box;
            overflow: hidden;
        }

        .modal-header {
            text-align: center;
            margin-bottom: 25px;
        }

        .modal-header h2 {
            color: #0d9488;
            font-size: 1.8em;
            margin-bottom: 10px;
        }

        .share-link-container {
            background: #f8f9ff;
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #e0e7ff;
            margin-bottom: 20px;
            word-break: break-all;
        }

        .share-link {
            color: #0d9488;
            font-weight: 600;
            font-size: 0.95em;
        }

        .btn-copy {
            background: #0d9488;
            color: white;
            width: 100%;
            padding: 15px;
            font-size: 1.1em;
        }

        .btn-copy:hover {
            background: #5568d3;
        }

        .btn-close-modal {
            background: #6c757d;
            color: white;
            width: 100%;
            padding: 15px;
            font-size: 1.1em;
            margin-top: 10px;
        }

        .btn-close-modal:hover {
            background: #5a6268;
        }

        /* Custom Meal Modal Styles */
        .custom-meal-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .custom-meal-tab {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #e0e7ff;
            border-radius: 10px;
            background: #f8f9ff;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }

        .custom-meal-tab:hover {
            border-color: #0d9488;
        }

        .custom-meal-tab.active {
            background: #0d9488;
            color: white;
            border-color: #0d9488;
        }

        .custom-meal-tab-icon {
            font-size: 1.5em;
            display: block;
            margin-bottom: 5px;
        }

        .custom-meal-tab-label {
            font-size: 0.85em;
            font-weight: 600;
        }

        .custom-meal-panel {
            display: none;
        }

        .custom-meal-panel.active {
            display: block;
        }

        .custom-meal-input {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e0e7ff;
            border-radius: 10px;
            font-size: 1em;
            margin-bottom: 15px;
            box-sizing: border-box;
        }

        .custom-meal-input:focus {
            outline: none;
            border-color: #0d9488;
        }

        .custom-meal-textarea {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e0e7ff;
            border-radius: 10px;
            font-size: 1em;
            margin-bottom: 15px;
            min-height: 100px;
            resize: vertical;
            box-sizing: border-box;
            font-family: inherit;
        }

        .custom-meal-textarea:focus {
            outline: none;
            border-color: #0d9488;
        }

        .macro-inputs {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .macro-input-group {
            display: flex;
            flex-direction: column;
        }

        .macro-input-group label {
            font-size: 0.85em;
            color: #666;
            margin-bottom: 5px;
            font-weight: 600;
        }

        .macro-input-group input {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #e0e7ff;
            border-radius: 8px;
            font-size: 1em;
            text-align: center;
            box-sizing: border-box;
        }

        .macro-input-group input:focus {
            outline: none;
            border-color: #0d9488;
        }

        .custom-meal-hint {
            font-size: 0.8em;
            color: #888;
            margin-bottom: 15px;
            padding: 10px;
            background: #f8f9ff;
            border-radius: 8px;
        }

        .btn-submit-custom {
            background: #0d9488;
            color: white;
            width: 100%;
            padding: 15px;
            font-size: 1.1em;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
        }

        .btn-submit-custom:hover {
            background: #0b7a6e;
        }

        .btn-submit-custom:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        /* Food Search Styles - synced with planner.html */
        .food-search-container {
            position: relative;
            margin-bottom: 15px;
        }

        .food-search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #e0e7ff;
            border-top: none;
            border-radius: 0 0 10px 10px;
            max-height: 250px;
            overflow-y: auto;
            z-index: 100;
            display: none;
        }

        .food-search-results.active {
            display: block;
        }

        .food-search-item {
            padding: 10px 12px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
        }

        .food-search-item:hover {
            background: #f0fdf4;
        }

        .food-search-item:last-child {
            border-bottom: none;
        }

        .food-name {
            font-weight: 600;
            color: #333;
            margin-bottom: 2px;
        }

        .food-macros {
            font-size: 0.8em;
            color: #666;
        }

        .food-search-loading, .food-search-empty {
            padding: 15px;
            text-align: center;
            color: #888;
        }

        /* Selected Ingredients Styles - synced with planner.html */
        .selected-ingredients {
            margin-bottom: 15px;
        }

        .selected-ingredients-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #e0e7ff;
            margin-bottom: 10px;
            font-weight: 600;
            color: #333;
        }

        .ingredients-list {
            max-height: 150px;
            overflow-y: auto;
        }

        .ingredient-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: #f8fafc;
            border-radius: 8px;
            margin-bottom: 6px;
        }

        .ingredient-name {
            flex: 1;
            font-size: 0.9em;
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: normal;
        }

        .ingredient-qty {
            width: 60px;
            padding: 4px 8px;
            border: 1px solid #e0e7ff;
            border-radius: 6px;
            text-align: center;
            font-size: 0.9em;
            -moz-appearance: textfield;
        }

        .ingredient-qty::-webkit-outer-spin-button,
        .ingredient-qty::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .qty-stepper {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .qty-step-btn {
            width: 28px;
            height: 28px;
            border: 1px solid #e0e7ff;
            border-radius: 6px;
            background: white;
            color: #6366f1;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
            user-select: none;
        }

        .qty-step-btn:hover {
            background: #6366f1;
            color: white;
            border-color: #6366f1;
        }

        .qty-step-btn:active {
            transform: scale(0.95);
        }

        .qty-step-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .ingredient-unit {
            font-size: 0.85em;
            color: #666;
        }

        .ingredient-unit-select {
            padding: 4px 6px;
            border: 1px solid #e0e7ff;
            border-radius: 6px;
            font-size: 0.8em;
            background: white;
            cursor: pointer;
            max-width: 90px;
        }

        .ingredient-unit-select:focus {
            outline: none;
            border-color: #6366f1;
        }

        .ingredient-remove {
            background: #fee2e2;
            border: none;
            color: #dc2626;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            font-weight: bold;
        }

        .no-ingredients {
            text-align: center;
            color: #888;
            padding: 15px;
            font-style: italic;
        }

        /* Calculated Totals Styles - synced with planner.html */
        .calculated-totals {
            background: linear-gradient(135deg, #ecfdf5 0%, #d1fae5 100%);
            border: 2px solid #10b981;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .totals-header {
            font-weight: 700;
            color: #065f46;
            margin-bottom: 10px;
            font-size: 0.9em;
        }

        .totals-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            text-align: center;
        }

        .total-item {
            background: white;
            padding: 8px;
            border-radius: 8px;
        }

        .total-value {
            font-weight: 700;
            color: #0d9488;
            font-size: 1.1em;
        }

        .total-label {
            font-size: 0.75em;
            color: #666;
        }

        .btn-share {
            background: #28a745;
            color: white;
            padding: 15px 40px;
            font-size: 1.1em;
        }

        .btn-share:hover {
            background: #218838;
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(40, 167, 69, 0.4);
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }

            .header h1 {
                font-size: 1.8em;
            }

            .macro-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .modal-content {
                padding: 25px;
            }
        }

        /* Saved Meals Styles */
        .saved-meals-list {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 15px;
        }

        .saved-meal-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            margin-bottom: 8px;
            background: #fafafa;
        }

        .saved-meal-item:hover {
            background: #f0fdf4;
            border-color: #86efac;
        }

        .saved-meal-info {
            flex: 1;
            min-width: 0;
        }

        .saved-meal-name {
            font-weight: 600;
            color: #1f2937;
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: normal;
        }

        .saved-meal-macros {
            font-size: 0.8em;
            color: #6b7280;
            margin-top: 2px;
        }

        .saved-meal-actions {
            display: flex;
            gap: 8px;
            margin-left: 10px;
        }

        .btn-use-saved {
            padding: 6px 12px;
            background: linear-gradient(135deg, #0d9488 0%, #0891b2 100%);
            border: none;
            border-radius: 6px;
            color: white;
            font-size: 0.85em;
            cursor: pointer;
        }

        .btn-delete-saved {
            padding: 6px 10px;
            background: #fee2e2;
            border: none;
            border-radius: 6px;
            color: #dc2626;
            font-size: 0.85em;
            cursor: pointer;
        }

        .btn-delete-saved:hover {
            background: #fecaca;
        }

        .no-saved-meals {
            text-align: center;
            padding: 30px;
            color: #9ca3af;
        }

        .save-for-later-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 15px 0;
            padding: 10px;
            background: #fffbeb;
            border: 1px solid #fcd34d;
            border-radius: 8px;
        }

        .save-for-later-row input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .save-for-later-row label {
            font-size: 0.9em;
            color: #92400e;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header" style="position: relative;">
            <a href="#" id="backButton" class="back-btn" style="position: absolute; left: 0; top: 50%; transform: translateY(-50%); display: flex; align-items: center; gap: 6px; color: #0d9488; text-decoration: none; font-weight: 600; font-size: 0.95em;">
                <span style="font-size: 1.2em;">‚Üê</span> Back
            </a>
            <h1 id="planHeader">Your Meal Plan</h1>
            <button id="resetToOriginalBtn" class="btn-reset" onclick="resetToOriginal()" style="display: none;">‚Ü∫ Reset to Original</button>
        </div>

        <div class="client-info">
            <div class="section-title">Your Daily Targets</div>
            <div class="info-grid">
                <div class="info-item">
                    <div class="info-label">Calories</div>
                    <div class="info-value" id="totalCalories">Loading...</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Protein</div>
                    <div class="info-value" id="totalProtein">Loading...</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Carbs</div>
                    <div class="info-value" id="totalCarbs">Loading...</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Fat</div>
                    <div class="info-value" id="totalFat">Loading...</div>
                </div>
            </div>
        </div>

        <div id="mealsContainer"></div>

        <div class="action-buttons">
            <button class="btn btn-primary" onclick="showMealPrepGuide()" style="background:#ff6b6b;">üìã Meal Prep Guide</button>
            <button class="btn btn-primary" onclick="downloadPDF()">üì• Download PDF</button>
            <button id="sharePlanBtn" class="btn btn-share" onclick="generateShareLink()" style="display: none;">üîó Share Plan Link</button>
            <button id="generateNewBtn" class="btn btn-secondary" onclick="window.location.href='planner.html'" style="display: none;">‚Üê Generate New Plan</button>
        </div>
    </div>

    <!-- Meal Prep Guide Modal -->
    <div id="mealPrepModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 900px; max-height: 85vh; overflow-y: auto;">
            <div class="modal-header">
                <h2>üìã Meal Prep Guide</h2>
                <button class="close-btn" onclick="closeMealPrepModal()">&times;</button>
            </div>
            <div id="mealPrepContent" style="padding: 20px;">
                <div style="text-align: center; padding: 40px;">
                    <div class="loader" style="margin: 0 auto 20px;"></div>
                    <p style="color: #666;">Generating your comprehensive meal prep guide...</p>
                </div>
            </div>
            <div style="padding: 20px; border-top: 1px solid #ddd; text-align: right;">
                <button class="btn btn-secondary" onclick="closeMealPrepModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Share Modal -->
    <div id="shareModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üîó Share Your Meal Plan</h2>
                <p style="color: #666;">Share this link with your client</p>
            </div>
            <div class="share-link-container">
                <div class="share-link" id="shareLinkText">Generating link...</div>
            </div>
            <button class="btn btn-copy" onclick="copyShareLink()">üìã Copy Link</button>
            <button class="btn btn-close-modal" onclick="closeShareModal()">Close</button>
        </div>
    </div>

    <!-- Custom Meal Modal -->
    <div id="customMealModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 450px; max-height: 90vh; overflow-y: auto;">
            <div class="modal-header">
                <h2>üéØ Custom Meal</h2>
                <p style="color: #666;">Create your own meal</p>
            </div>

            <!-- Tabs -->
            <div class="custom-meal-tabs">
                <div class="custom-meal-tab active" onclick="switchCustomMealTab('calculate')">
                    <span class="custom-meal-tab-icon">üßÆ</span>
                    <span class="custom-meal-tab-label">Calculate</span>
                </div>
                <div class="custom-meal-tab" onclick="switchCustomMealTab('manual')">
                    <span class="custom-meal-tab-icon">‚úèÔ∏è</span>
                    <span class="custom-meal-tab-label">Manual</span>
                </div>
                <div class="custom-meal-tab" onclick="switchCustomMealTab('saved')">
                    <span class="custom-meal-tab-icon">üìö</span>
                    <span class="custom-meal-tab-label">My Saved</span>
                </div>
            </div>

            <!-- Calculate Panel -->
            <div id="calculatePanel" class="custom-meal-panel active">
                <div class="custom-meal-hint">
                    üí° Search our food database for ingredients. Add them with quantities to calculate macros.
                </div>

                <!-- Food Search Input -->
                <div class="food-search-container">
                    <input
                        type="text"
                        id="foodSearchInput"
                        class="custom-meal-input"
                        placeholder="Search foods (e.g., chicken breast, rice, Quest bar)..."
                        oninput="handleFoodSearch(this.value)"
                        autocomplete="off"
                        style="margin-bottom: 0;"
                    >
                    <div id="foodSearchResults" class="food-search-results"></div>
                </div>

                <!-- Selected Ingredients List -->
                <div class="selected-ingredients">
                    <div class="selected-ingredients-header">
                        <span>Selected Ingredients</span>
                        <span id="ingredientCount">(0)</span>
                    </div>
                    <div id="ingredientsList" class="ingredients-list">
                        <div class="no-ingredients">No ingredients added yet</div>
                    </div>
                </div>

                <!-- Calculated Totals -->
                <div class="calculated-totals">
                    <div class="totals-header">üìä Calculated Totals</div>
                    <div class="totals-grid">
                        <div class="total-item">
                            <div class="total-value" id="calcTotalCalories">0</div>
                            <div class="total-label">Calories</div>
                        </div>
                        <div class="total-item">
                            <div class="total-value" id="calcTotalProtein">0g</div>
                            <div class="total-label">Protein</div>
                        </div>
                        <div class="total-item">
                            <div class="total-value" id="calcTotalCarbs">0g</div>
                            <div class="total-label">Carbs</div>
                        </div>
                        <div class="total-item">
                            <div class="total-value" id="calcTotalFat">0g</div>
                            <div class="total-label">Fat</div>
                        </div>
                    </div>
                </div>

                <!-- Meal Name -->
                <input
                    type="text"
                    id="calculatedMealName"
                    class="custom-meal-input"
                    placeholder="Meal name (optional - auto-generated if blank)"
                >

                <div class="save-for-later-row">
                    <input type="checkbox" id="saveCalculatedForLater">
                    <label for="saveCalculatedForLater">üíæ Save this meal for future use</label>
                </div>

                <button class="btn-submit-custom" onclick="submitCalculatedMeal()" id="createCalculatedMealBtn" disabled>
                    üßÆ Create Meal
                </button>
            </div>

            <!-- Manual Panel -->
            <div id="manualPanel" class="custom-meal-panel">
                <div class="custom-meal-hint">
                    üí° Enter the meal name and macros directly. Use nutrition labels or apps like MyFitnessPal.
                </div>
                <input
                    type="text"
                    id="customMealName"
                    class="custom-meal-input"
                    placeholder="Meal name (e.g., Protein Shake, Chipotle Bowl)"
                >
                <div class="macro-inputs">
                    <div class="macro-input-group">
                        <label>Calories</label>
                        <input type="number" id="customMealCalories" placeholder="0">
                    </div>
                    <div class="macro-input-group">
                        <label>Protein (g)</label>
                        <input type="number" id="customMealProtein" placeholder="0">
                    </div>
                    <div class="macro-input-group">
                        <label>Carbs (g)</label>
                        <input type="number" id="customMealCarbs" placeholder="0">
                    </div>
                    <div class="macro-input-group">
                        <label>Fat (g)</label>
                        <input type="number" id="customMealFat" placeholder="0">
                    </div>
                </div>
                <input
                    type="text"
                    id="customMealInstructions"
                    class="custom-meal-input"
                    placeholder="Instructions (optional)"
                >

                <div class="save-for-later-row">
                    <input type="checkbox" id="saveManualForLater">
                    <label for="saveManualForLater">üíæ Save this meal for future use</label>
                </div>

                <button class="btn-submit-custom" onclick="submitManualMeal()">
                    ‚úÖ Create Meal
                </button>
            </div>

            <!-- Saved Meals Panel -->
            <div id="savedPanel" class="custom-meal-panel">
                <div class="custom-meal-hint">
                    üìö Your saved custom meals. Click "Use" to add to your plan.
                </div>
                <div id="savedMealsList" class="saved-meals-list">
                    <div class="no-saved-meals">No saved meals yet. Create a meal and check "Save for future use" to add it here.</div>
                </div>
            </div>

            <button class="btn btn-close-modal" onclick="closeCustomMealModal()" style="margin-top: 15px;">Cancel</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
        // Initialize Supabase client
        const SUPABASE_URL = 'https://qewqcjzlfqamqwbccapr.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFld3FjanpsZnFhbXF3YmNjYXByIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM2OTg0NzAsImV4cCI6MjA3OTI3NDQ3MH0.mQnMC33O88oLkLLGWD2oG-oaSHGI-NfHmtQCZxnxSLs';

        const { createClient } = supabase;
        const supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        const API_ENDPOINT = '/.netlify/functions/generate-meal-plan';
        const SAVE_PLAN_ENDPOINT = '/.netlify/functions/save-shared-plan';
        const GET_PLAN_ENDPOINT = '/.netlify/functions/get-shared-plan';
        const TOGGLE_FAVORITE_ENDPOINT = '/.netlify/functions/toggle-favorite';
        const SAVE_CLIENT_MODIFICATION_ENDPOINT = '/.netlify/functions/save-client-modification';
        const RESET_CLIENT_MODIFICATION_ENDPOINT = '/.netlify/functions/reset-client-modification';
        let currentPlan = null;
        let clientFavorites = [];
        let currentShareUrl = '';
        let realtimeChannel = null;
        let currentPlanId = null;
        let currentClientId = null; // Track client ID for saving modifications
        let currentCoachId = null; // Track coach ID for coach view
        let isClientModified = false; // Track if client has modified the plan
        let isClientView = false; // Track if viewing as client

        // Store previous meal states for undo functionality - persisted to localStorage
        // Use same key as planner.html so undo states are shared between pages
        const UNDO_STATES_KEY = 'plannerUndoStates';
        let previousMealStates = {};

        // Load undo states from localStorage
        function loadUndoStates() {
            try {
                const stored = localStorage.getItem(UNDO_STATES_KEY);
                if (stored) {
                    previousMealStates = JSON.parse(stored);
                    console.log('üìÇ Loaded undo states from localStorage');
                }
            } catch (e) {
                console.error('Error loading undo states:', e);
            }
        }

        // Save undo states to localStorage
        function saveUndoStates() {
            try {
                localStorage.setItem(UNDO_STATES_KEY, JSON.stringify(previousMealStates));
            } catch (e) {
                console.error('Error saving undo states:', e);
            }
        }

        // Load undo states on page load
        loadUndoStates();

        // Custom meal modal state
        let currentCustomMealIndex = null;
        let currentCustomMealDayIndex = null;
        let currentCustomMealMealIndex = null;

        // Food search state - synced with planner.html
        const FOOD_SEARCH_ENDPOINT = '/.netlify/functions/usda-search';
        let customMealSelectedIngredients = [];
        let foodSearchTimeout = null;
        let foodSearchResults = [];

        // Simple notification function
        function showNotification(message, type = 'info') {
            // Create notification element
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 15px 25px;
                border-radius: 8px;
                color: white;
                font-weight: 500;
                z-index: 10000;
                animation: slideIn 0.3s ease;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            `;
            notification.style.background = type === 'success' ? '#10b981' : type === 'error' ? '#ef4444' : '#3b82f6';
            notification.textContent = message;
            document.body.appendChild(notification);

            // Auto-remove after 3 seconds
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        // Helper function to escape HTML and convert URLs to clickable links
        function linkifyText(text) {
            if (!text) return '';

            // First escape HTML to prevent XSS
            const escaped = text
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#039;');

            // URL regex pattern - matches http, https, and www URLs
            const urlPattern = /(\b(https?:\/\/|www\.)[^\s<]+[^\s<.,;:!?"'\])}>])/gi;

            // Convert URLs to clickable links
            return escaped.replace(urlPattern, (url) => {
                let href = url;
                // Add https:// if URL starts with www.
                if (url.toLowerCase().startsWith('www.')) {
                    href = 'https://' + url;
                }
                return `<a href="${href}" target="_blank" rel="noopener noreferrer" style="color: #0284c7; text-decoration: underline;">${url}</a>`;
            });
        }

        // Detect if page was loaded from back/forward cache and force reload
        window.addEventListener('pageshow', function(event) {
            if (event.persisted) {
                // Page was loaded from bfcache (back/forward cache)
                console.log('Page loaded from cache, forcing reload...');
                window.location.reload();
            }
        });

        // Load meal plan
        document.addEventListener('DOMContentLoaded', async function() {
            // Check URL parameters
            const urlParams = new URLSearchParams(window.location.search);
            const shareId = urlParams.get('share');
            const planId = urlParams.get('planId');
            const clientView = urlParams.get('clientView') === 'true';
            const fromClientId = urlParams.get('fromClient');

            // Set back button URL based on view type
            const backButton = document.getElementById('backButton');
            if (fromClientId) {
                // Coach viewing from client profile - go back to client profile
                backButton.href = `client-profile.html?clientId=${fromClientId}`;
            } else if (clientView || shareId) {
                backButton.href = 'client-dashboard.html';
            } else {
                backButton.href = 'dashboard.html';
            }

            if (shareId) {
                // Load shared plan from database (client view)
                loadSharedPlan(shareId);
            } else if (planId) {
                // Load plan from database by ID (coach or client viewing)
                await loadCoachPlan(planId, clientView);
            } else {
                // Load from localStorage (newly generated plan)
                const planData = localStorage.getItem('currentMealPlan');

                if (!planData) {
                    alert('No meal plan found. Redirecting...');
                    window.location.href = 'planner.html';
                    return;
                }

                try {
                    currentPlan = JSON.parse(planData);
                    console.log('Loaded plan from localStorage:', currentPlan);

                    // Show coach-only buttons
                    document.getElementById('sharePlanBtn').style.display = 'inline-block';
                    document.getElementById('generateNewBtn').style.display = 'inline-block';

                    displayMealPlan();
                } catch (error) {
                    console.error('Error loading plan:', error);
                    alert('Error loading plan. Please generate a new one.');
                    window.location.href = 'planner.html';
                }
            }
        });

        // Load shared plan from database
        async function loadSharedPlan(shareId) {
            try {
                console.log('üì• Loading shared plan:', shareId);

                const response = await fetch(`${GET_PLAN_ENDPOINT}?shareId=${shareId}`);

                if (!response.ok) {
                    throw new Error('Failed to load shared plan');
                }

                const data = await response.json();
                currentPlan = data.planData;

                console.log('‚úÖ Loaded shared plan:', currentPlan);

                // Also save to localStorage for offline access
                localStorage.setItem('currentMealPlan', JSON.stringify(currentPlan));

                displayMealPlan();

                // Update header with client name
                const clientName = currentPlan.clientName || 'Client';
                const mealCount = currentPlan.meals ? currentPlan.meals.length : 0;
                const planText = mealCount > 1 ? 'Meal Plans' : 'Meal Plan';
                document.getElementById('planHeader').textContent = `üî• ${clientName}'s ${planText}`;

            } catch (error) {
                console.error('‚ùå Error loading shared plan:', error);
                alert('Failed to load shared plan. The link may be invalid or expired.');
                window.location.href = 'planner.html';
            }
        }

        // Load coach plan from database by ID
        async function loadCoachPlan(planId, clientView = false) {
            // Store in global variable
            isClientView = clientView;

            try {
                console.log('Loading plan:', planId, 'Client view:', isClientView);

                // Clear any cached session data to force fresh fetch
                await supabaseClient.auth.refreshSession();

                // Check if user is logged in
                const { data: { session }, error: sessionError } = await supabaseClient.auth.getSession();

                if (sessionError || !session) {
                    alert('Please log in to view this plan.');
                    const redirectUrl = isClientView ? 'client-login.html' : 'index.html';
                    window.location.href = redirectUrl;
                    return;
                }

                const currentUser = session.user;
                let query = supabaseClient
                    .from('coach_meal_plans')
                    .select('*')
                    .eq('id', planId);

                if (isClientView) {
                    // For client view, verify the client owns this plan
                    const { data: clientData, error: clientError } = await supabaseClient
                        .from('clients')
                        .select('id')
                        .eq('user_id', currentUser.id)
                        .single();

                    if (clientError || !clientData) {
                        alert('Client account not found. Please contact your coach.');
                        window.location.href = 'client-login.html';
                        return;
                    }

                    // Store client ID for saving modifications later
                    currentClientId = clientData.id;

                    // Load favorites for the client
                    await loadFavorites(clientData.id);

                    // Load saved meals for the client
                    await loadSavedMeals();

                    query = query.eq('client_id', clientData.id);
                } else {
                    // For coach view, verify the coach owns this plan
                    currentCoachId = currentUser.id;

                    // Load saved meals for the coach
                    await loadSavedMeals();

                    query = query.eq('coach_id', currentUser.id);
                }

                const { data, error } = await query.single();

                if (error) {
                    console.error('Supabase error:', error);
                    throw new Error('Failed to load plan');
                }

                if (!data) {
                    throw new Error('Plan not found');
                }

                console.log('Loaded plan:', data);
                currentPlanId = planId;

                // For client view: Use client_modified_data if it exists (client's personalized version)
                // Otherwise use plan_data (coach's original)
                let planData;
                console.log('üîç Plan data check:', {
                    isClientView: isClientView,
                    hasClientModifiedData: !!data.client_modified_data,
                    clientModifiedDataType: typeof data.client_modified_data
                });
                if (isClientView && data.client_modified_data) {
                    console.log('üìù Loading CLIENT MODIFIED version of plan');
                    planData = data.client_modified_data;
                    isClientModified = true;
                } else {
                    console.log('üìã Loading ORIGINAL coach plan');
                    planData = data.plan_data;
                    isClientModified = false;
                }

                // FIXED: Store multi-day structure instead of flattening
                if (planData.currentPlan && Array.isArray(planData.currentPlan)) {
                    // Multi-day plan structure - keep it organized by day
                    // Get nutrition from top-level OR from first day's targets
                    const dayTargets = planData.currentPlan[0]?.targets || {};
                    const nutrition = {
                        calories: planData.calories || dayTargets.calories || 0,
                        protein: planData.protein || dayTargets.protein || 0,
                        carbs: planData.carbs || dayTargets.carbs || 0,
                        fat: planData.fat || dayTargets.fat || 0
                    };
                    console.log('üìä Extracted nutrition for Daily Targets:', nutrition);

                    currentPlan = {
                        planId: data.id, // Store the coach plan ID for linking shared plans
                        clientName: planData.clientName || data.client_name,
                        preferences: planData.preferences || {},
                        multiDay: true,
                        days: planData.currentPlan, // Store all days with structure
                        nutrition: nutrition,
                        coachNotes: data.coach_notes || null
                    };
                } else {
                    // Fallback for old single-day format
                    currentPlan = {
                        planId: data.id, // Store the coach plan ID for linking shared plans
                        clientName: planData.clientName || data.client_name,
                        preferences: planData.preferences || {},
                        meals: planData.meals || [],
                        nutrition: planData.nutrition || {},
                        coachNotes: data.coach_notes || null
                    };
                }

                console.log('Transformed plan:', currentPlan);

                // Show coach-only buttons (only for coach view)
                if (!isClientView) {
                    document.getElementById('sharePlanBtn').style.display = 'inline-block';
                    document.getElementById('generateNewBtn').style.display = 'inline-block';
                }

                displayMealPlan();

                // Show modified indicator and reset button if client has modified the plan
                if (isClientModified) {
                    updateModifiedIndicator();
                    document.getElementById('resetToOriginalBtn').style.display = 'inline-block';
                }

                // Update header with client name
                const clientName = currentPlan.clientName || 'Client';
                const mealCount = currentPlan.meals ? currentPlan.meals.length : 0;
                const planText = mealCount > 1 ? 'Meal Plans' : 'Meal Plan';
                if (isClientView) {
                    document.getElementById('planHeader').textContent = `Your ${planText}`;
                } else {
                    document.getElementById('planHeader').textContent = `${clientName}'s ${planText}`;
                }

                // Set up real-time subscription for automatic updates
                setupRealtimeSubscription(planId, isClientView);

            } catch (error) {
                console.error('Error loading plan:', error);
                alert('Failed to load plan. Please try again.');
                const redirectUrl = isClientView ? 'client-dashboard.html' : 'dashboard.html';
                window.location.href = redirectUrl;
            }
        }

        function setupRealtimeSubscription(planId, isClientView) {
            // Clean up existing subscription if any
            if (realtimeChannel) {
                supabaseClient.removeChannel(realtimeChannel);
            }

            // Subscribe to changes for this specific plan
            realtimeChannel = supabaseClient
                .channel(`plan_${planId}`)
                .on(
                    'postgres_changes',
                    {
                        event: '*', // Listen to all events (INSERT, UPDATE, DELETE)
                        schema: 'public',
                        table: 'coach_meal_plans',
                        filter: `id=eq.${planId}`
                    },
                    (payload) => {
                        console.log('Real-time update received:', payload);
                        handlePlanUpdate(payload, isClientView);
                    }
                )
                .subscribe((status) => {
                    console.log('Realtime subscription status:', status);
                });
        }

        async function handlePlanUpdate(payload, isClientView) {
            const { eventType, new: newRecord } = payload;

            if (eventType === 'DELETE') {
                // Plan was deleted by coach
                console.log('Plan deleted');
                alert('This meal plan has been removed by your coach.');
                const redirectUrl = isClientView ? 'client-dashboard.html' : 'dashboard.html';
                window.location.href = redirectUrl;
            } else if (eventType === 'UPDATE') {
                // Plan was updated - reload and display
                console.log('Plan updated:', newRecord);

                const planData = newRecord.plan_data;

                // Update the currentPlan with new data
                if (planData.currentPlan && Array.isArray(planData.currentPlan)) {
                    // Get nutrition from top-level OR from first day's targets
                    const dayTargets = planData.currentPlan[0]?.targets || {};
                    const nutrition = {
                        calories: planData.calories || dayTargets.calories || 0,
                        protein: planData.protein || dayTargets.protein || 0,
                        carbs: planData.carbs || dayTargets.carbs || 0,
                        fat: planData.fat || dayTargets.fat || 0
                    };
                    currentPlan = {
                        planId: newRecord.id,
                        clientName: planData.clientName || newRecord.client_name,
                        preferences: planData.preferences || {},
                        multiDay: true,
                        days: planData.currentPlan,
                        nutrition: nutrition
                    };
                } else {
                    currentPlan = {
                        planId: newRecord.id,
                        clientName: planData.clientName || newRecord.client_name,
                        preferences: planData.preferences || {},
                        meals: planData.meals || [],
                        nutrition: planData.nutrition || {}
                    };
                }

                // Refresh the display with updated data
                displayMealPlan();

                console.log('Plan display refreshed with updated data');
            }
        }

        // Clean up subscription when page unloads
        window.addEventListener('beforeunload', function() {
            if (realtimeChannel) {
                supabaseClient.removeChannel(realtimeChannel);
            }
        });

        // Save current plan back to database if viewing from database
        async function savePlanToDatabase() {
            if (!currentPlanId) {
                console.log('‚è≠Ô∏è Skipping database save - no planId (viewing from localStorage)');
                return;
            }

            try {
                // Prepare the plan data in the format the database expects
                const planData = {
                    clientName: currentPlan.clientName,
                    preferences: currentPlan.preferences || {},
                    nutrition: currentPlan.nutrition
                };

                // Add the plan structure based on type
                if (currentPlan.multiDay && currentPlan.days) {
                    planData.currentPlan = currentPlan.days;
                    planData.calories = currentPlan.nutrition.calories;
                    planData.protein = currentPlan.nutrition.protein;
                    planData.carbs = currentPlan.nutrition.carbs;
                    planData.fat = currentPlan.nutrition.fat;
                } else if (currentPlan.meals) {
                    planData.meals = currentPlan.meals;
                }

                // CLIENT VIEW: Save to client_modified_data (preserves coach's original)
                if (isClientView && currentClientId) {
                    console.log('üíæ Saving CLIENT modifications to database...', currentPlanId);

                    const response = await fetch(SAVE_CLIENT_MODIFICATION_ENDPOINT, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            planId: currentPlanId,
                            clientId: currentClientId,
                            modifiedPlanData: planData
                        })
                    });

                    const result = await response.json();

                    if (!response.ok) {
                        console.error('‚ùå Client modification save error:', result);
                        throw new Error(result.error || 'Failed to save modifications');
                    }

                    // Mark as modified
                    isClientModified = true;
                    console.log('‚úÖ Client modifications saved to database');

                    // Update UI to show modified indicator and reset button
                    updateModifiedIndicator();
                    document.getElementById('resetToOriginalBtn').style.display = 'inline-block';
                    return;
                }

                // COACH VIEW: Save directly to plan_data
                console.log('üíæ Saving plan changes to database...', currentPlanId);

                const { error } = await supabaseClient
                    .from('coach_meal_plans')
                    .update({ plan_data: planData })
                    .eq('id', currentPlanId);

                if (error) {
                    console.error('‚ùå Database save error:', error);
                    throw error;
                }

                console.log('‚úÖ Plan saved to database successfully');
            } catch (error) {
                console.error('‚ùå Failed to save plan to database:', error);
                alert('Warning: Changes saved locally but failed to sync to database.');
            }
        }

        // Update UI to show that client has modified the plan
        function updateModifiedIndicator() {
            const header = document.getElementById('planHeader');
            if (header && isClientModified && !header.innerHTML.includes('modified-badge')) {
                header.innerHTML += ' <span class="modified-badge">Modified</span>';
            }
        }

        // Reset to coach's original plan (remove client modifications)
        async function resetToOriginal() {
            if (!currentPlanId || !currentClientId) {
                alert('Cannot reset: Plan information not available');
                return;
            }

            if (!confirm('Are you sure you want to reset to the original plan from your coach? All your modifications will be lost.')) {
                return;
            }

            try {
                console.log('üîÑ Resetting to original plan...', { planId: currentPlanId, clientId: currentClientId });

                // Use backend function to reset (bypasses RLS)
                const response = await fetch(RESET_CLIENT_MODIFICATION_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        planId: currentPlanId,
                        clientId: currentClientId
                    })
                });

                const result = await response.json();

                if (!response.ok) {
                    console.error('‚ùå Reset error:', result);
                    throw new Error(result.error || 'Failed to reset plan');
                }

                console.log('‚úÖ Plan reset to original:', result);

                // Verify the reset worked by checking returned data
                if (result.plan) {
                    console.log('üìã Returned plan client_modified_data:', result.plan.client_modified_data);
                    if (result.plan.client_modified_data !== null) {
                        console.error('‚ö†Ô∏è WARNING: client_modified_data was not cleared!');
                    }
                }

                if (result.alreadyOriginal) {
                    alert('Plan is already at the original version.');
                    return;
                }

                alert('Plan has been reset to the original version from your coach.');

                // Force a hard reload with cache busting to ensure fresh data
                const url = new URL(window.location.href);
                url.searchParams.set('_reset', Date.now());
                window.location.href = url.toString();

            } catch (error) {
                console.error('Error resetting plan:', error);
                alert('Failed to reset plan. Please try again.');
            }
        }

        // Generate and save share link
        async function generateShareLink() {
            if (!currentPlan) {
                alert('No meal plan to share');
                return;
            }

            // Show modal with loading state
            const modal = document.getElementById('shareModal');
            const linkText = document.getElementById('shareLinkText');
            linkText.textContent = 'Generating share link...';
            modal.classList.add('show');

            try {
                console.log('üì§ Saving plan for sharing...');

                // Prepare request body
                const requestBody = { planData: currentPlan };

                // If this plan was loaded from database (has planId), include it
                // This links the shared plan to the coach plan for cascade deletion
                if (currentPlan.planId) {
                    requestBody.coachPlanId = currentPlan.planId;
                    console.log('Linking shared plan to coach plan:', currentPlan.planId);
                }

                const response = await fetch(SAVE_PLAN_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    throw new Error('Failed to generate share link');
                }

                const data = await response.json();
                currentShareUrl = data.shareUrl;

                console.log('‚úÖ Share link generated:', currentShareUrl);

                linkText.textContent = currentShareUrl;

            } catch (error) {
                console.error('‚ùå Error generating share link:', error);
                linkText.textContent = 'Failed to generate link. Please try again.';
                alert('Failed to generate share link. Please try again.');
            }
        }

        // Copy share link to clipboard
        async function copyShareLink() {
            if (!currentShareUrl) {
                alert('No share link available');
                return;
            }

            try {
                await navigator.clipboard.writeText(currentShareUrl);

                // Update button text temporarily
                const copyBtn = event.target;
                const originalText = copyBtn.textContent;
                copyBtn.textContent = '‚úÖ Copied!';
                copyBtn.style.background = '#28a745';

                setTimeout(() => {
                    copyBtn.textContent = originalText;
                    copyBtn.style.background = '';
                }, 2000);

            } catch (error) {
                console.error('‚ùå Copy error:', error);
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = currentShareUrl;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                alert('Link copied to clipboard!');
            }
        }

        // Close share modal
        function closeShareModal() {
            const modal = document.getElementById('shareModal');
            modal.classList.remove('show');
        }

        // ===== CUSTOM MEAL MODAL FUNCTIONS =====

        function openCustomMealModal(index, dayIndex = null, mealIndex = null) {
            // Store the current meal context
            currentCustomMealIndex = index;
            currentCustomMealDayIndex = dayIndex;
            currentCustomMealMealIndex = mealIndex;

            // Reset manual panel form
            document.getElementById('customMealName').value = '';
            document.getElementById('customMealCalories').value = '';
            document.getElementById('customMealProtein').value = '';
            document.getElementById('customMealCarbs').value = '';
            document.getElementById('customMealFat').value = '';
            document.getElementById('customMealInstructions').value = '';

            // Reset USDA search/calculate panel
            document.getElementById('foodSearchInput').value = '';
            document.getElementById('foodSearchResults').classList.remove('active');
            document.getElementById('foodSearchResults').innerHTML = '';
            document.getElementById('calculatedMealName').value = '';
            customMealSelectedIngredients = [];
            renderCustomMealIngredients();
            updateCustomMealTotals();

            // Reset to calculate tab
            switchCustomMealTab('calculate');

            // Show modal
            document.getElementById('customMealModal').classList.add('show');
        }

        function closeCustomMealModal() {
            document.getElementById('customMealModal').classList.remove('show');
            currentCustomMealIndex = null;
            currentCustomMealDayIndex = null;
            currentCustomMealMealIndex = null;

            // Reset form fields
            document.getElementById('foodSearchInput').value = '';
            document.getElementById('foodSearchResults').classList.remove('active');
            document.getElementById('calculatedMealName').value = '';
            document.getElementById('customMealName').value = '';
            document.getElementById('customMealCalories').value = '';
            document.getElementById('customMealProtein').value = '';
            document.getElementById('customMealCarbs').value = '';
            document.getElementById('customMealFat').value = '';
            document.getElementById('customMealInstructions').value = '';

            // Reset save for later checkboxes
            document.getElementById('saveCalculatedForLater').checked = false;
            document.getElementById('saveManualForLater').checked = false;

            // Reset to first tab
            switchCustomMealTab('calculate');
        }

        function switchCustomMealTab(tab) {
            // Update tab styles
            const tabs = document.querySelectorAll('.custom-meal-tab');
            tabs.forEach(t => t.classList.remove('active'));

            // Update panel visibility
            document.getElementById('calculatePanel').classList.remove('active');
            document.getElementById('manualPanel').classList.remove('active');
            document.getElementById('savedPanel').classList.remove('active');

            if (tab === 'calculate') {
                tabs[0].classList.add('active');
                document.getElementById('calculatePanel').classList.add('active');
            } else if (tab === 'manual') {
                tabs[1].classList.add('active');
                document.getElementById('manualPanel').classList.add('active');
            } else if (tab === 'saved') {
                tabs[2].classList.add('active');
                document.getElementById('savedPanel').classList.add('active');
                renderSavedMeals();
            }
        }

        // ===== SAVED MEALS FUNCTIONS (Database backed - per account) =====
        const SAVED_MEALS_ENDPOINT = '/.netlify/functions/saved-meals';
        let savedMealsCache = []; // In-memory cache of saved meals

        async function loadSavedMeals() {
            // Determine which ID to use based on view type
            const queryParam = currentClientId
                ? `clientId=${currentClientId}`
                : currentCoachId
                    ? `coachId=${currentCoachId}`
                    : null;

            if (!queryParam) {
                console.log('‚ö†Ô∏è Cannot load saved meals - no user ID');
                savedMealsCache = [];
                return [];
            }

            try {
                const response = await fetch(`${SAVED_MEALS_ENDPOINT}?${queryParam}`);
                const data = await response.json();

                if (data.meals) {
                    // Transform database format to match expected format
                    savedMealsCache = data.meals.map(m => ({
                        id: m.id.toString(),
                        savedAt: m.created_at,
                        ...m.meal_data
                    }));
                    console.log(`üìö Loaded ${savedMealsCache.length} saved meals from database`);
                } else {
                    savedMealsCache = [];
                }
                return savedMealsCache;
            } catch (error) {
                console.error('Error loading saved meals:', error);
                savedMealsCache = [];
                return [];
            }
        }

        function getSavedMeals() {
            return savedMealsCache;
        }

        async function saveMealToLibrary(meal) {
            // Determine which ID to use based on view type
            const payload = currentClientId
                ? { clientId: currentClientId, mealData: meal }
                : currentCoachId
                    ? { coachId: currentCoachId, mealData: meal }
                    : null;

            if (!payload) {
                alert('Cannot save meal - not logged in');
                return null;
            }

            try {
                const response = await fetch(SAVED_MEALS_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const data = await response.json();

                if (data.success && data.meal) {
                    // Add to cache
                    const newMeal = {
                        id: data.meal.id.toString(),
                        savedAt: data.meal.created_at,
                        ...data.meal.meal_data
                    };
                    savedMealsCache.unshift(newMeal);
                    console.log('üíæ Meal saved to library:', newMeal.name);
                    return newMeal;
                } else {
                    throw new Error(data.error || 'Failed to save meal');
                }
            } catch (error) {
                console.error('Error saving meal to library:', error);
                alert('Failed to save meal to library. Please try again.');
                return null;
            }
        }

        async function deleteSavedMeal(mealId) {
            // Determine which ID to use based on view type
            const queryParam = currentClientId
                ? `clientId=${currentClientId}`
                : currentCoachId
                    ? `coachId=${currentCoachId}`
                    : null;

            if (!queryParam) {
                alert('Cannot delete meal - not logged in');
                return;
            }

            try {
                const response = await fetch(`${SAVED_MEALS_ENDPOINT}?mealId=${mealId}&${queryParam}`, {
                    method: 'DELETE'
                });

                const data = await response.json();

                if (data.success) {
                    // Remove from cache
                    savedMealsCache = savedMealsCache.filter(m => m.id !== mealId);
                    renderSavedMeals();
                    console.log('üóëÔ∏è Meal deleted from library:', mealId);
                } else {
                    throw new Error(data.error || 'Failed to delete meal');
                }
            } catch (error) {
                console.error('Error deleting saved meal:', error);
                alert('Failed to delete meal. Please try again.');
            }
        }

        function useSavedMeal(mealId) {
            const savedMeals = getSavedMeals();
            const meal = savedMeals.find(m => m.id === mealId);
            if (!meal) {
                alert('Meal not found');
                return;
            }

            // Get meal type and index info
            const mealType = currentPlan.multiDay
                ? currentPlan.days[currentCustomMealDayIndex].plan[currentCustomMealMealIndex]?.type || 'meal'
                : currentPlan.meals[currentCustomMealIndex]?.type || 'meal';

            // Create the meal
            const newMeal = {
                type: mealType,
                name: meal.name,
                ingredients: meal.ingredients,
                calories: meal.calories,
                protein: meal.protein,
                carbs: meal.carbs,
                fat: meal.fat,
                instructions: meal.instructions || 'Prepare as desired.',
                source: meal.source || 'Saved Meal',
                isCustom: true
            };

            // Update the meal in the plan
            if (currentPlan.multiDay) {
                currentPlan.days[currentCustomMealDayIndex].plan[currentCustomMealMealIndex] = newMeal;
            } else {
                currentPlan.meals[currentCustomMealIndex] = newMeal;
            }

            // Save changes
            localStorage.setItem('currentMealPlan', JSON.stringify(currentPlan));
            savePlanToDatabase();

            // Close modal and refresh display
            closeCustomMealModal();
            displayMealPlan();
            console.log('‚úÖ Used saved meal:', newMeal.name);
        }

        function renderSavedMeals() {
            const container = document.getElementById('savedMealsList');
            const savedMeals = getSavedMeals();

            if (savedMeals.length === 0) {
                container.innerHTML = '<div class="no-saved-meals">No saved meals yet. Create a meal and check "Save for future use" to add it here.</div>';
                return;
            }

            container.innerHTML = savedMeals.map(meal => `
                <div class="saved-meal-item">
                    <div class="saved-meal-info">
                        <div class="saved-meal-name">${escapeHtml(meal.name)}</div>
                        <div class="saved-meal-macros">${meal.calories} cal | ${meal.protein}g P | ${meal.carbs}g C | ${meal.fat}g F</div>
                    </div>
                    <div class="saved-meal-actions">
                        <button class="btn-use-saved" onclick="useSavedMeal('${meal.id}')">Use</button>
                        <button class="btn-delete-saved" onclick="deleteSavedMeal('${meal.id}')">üóëÔ∏è</button>
                    </div>
                </div>
            `).join('');
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ===== FOOD SEARCH FUNCTIONS - synced with planner.html =====

        function handleFoodSearch(query) {
            const resultsDiv = document.getElementById('foodSearchResults');

            if (foodSearchTimeout) {
                clearTimeout(foodSearchTimeout);
            }

            if (!query || query.trim().length < 2) {
                resultsDiv.classList.remove('active');
                resultsDiv.innerHTML = '';
                foodSearchResults = [];
                return;
            }

            // Show loading state
            resultsDiv.classList.add('active');
            resultsDiv.innerHTML = '<div class="food-search-loading">Searching foods...</div>';

            // Debounce the search
            foodSearchTimeout = setTimeout(async () => {
                try {
                    const response = await fetch(`${FOOD_SEARCH_ENDPOINT}?query=${encodeURIComponent(query)}`);
                    const data = await response.json();

                    if (!response.ok) {
                        throw new Error(data.error || 'Search failed');
                    }

                    if (data.foods && data.foods.length > 0) {
                        foodSearchResults = data.foods;

                        resultsDiv.innerHTML = data.foods.map((food, index) => {
                            let macroDisplay;
                            if (food.servingSize && food.caloriesPerServing !== undefined) {
                                macroDisplay = `${escapeHtmlCustomMeal(food.servingSize)}: ${food.caloriesPerServing} cal | ${food.proteinPerServing}g P | ${food.carbsPerServing}g C | ${food.fatPerServing}g F`;
                            } else {
                                macroDisplay = `Per 100g: ${food.caloriesPer100g} cal | ${food.proteinPer100g}g P | ${food.carbsPer100g}g C | ${food.fatPer100g}g F`;
                            }

                            return `
                            <div class="food-search-item" onclick="selectFoodItem(${index})">
                                <div class="food-name">${escapeHtmlCustomMeal(food.name)}${food.brand ? ` <span style="color: #888; font-size: 12px;">(${escapeHtmlCustomMeal(food.brand)})</span>` : ''}</div>
                                <div class="food-macros">${macroDisplay}</div>
                            </div>
                        `}).join('');
                    } else {
                        foodSearchResults = [];
                        resultsDiv.innerHTML = '<div class="food-search-empty">No foods found. Try a different search term.</div>';
                    }
                } catch (error) {
                    console.error('Food search error:', error);
                    foodSearchResults = [];
                    resultsDiv.innerHTML = '<div class="food-search-empty">Search failed. Please try again.</div>';
                }
            }, 300);
        }

        function escapeHtmlCustomMeal(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function selectFoodItem(index) {
            const food = foodSearchResults[index];
            if (!food) return;

            // Build measures array - always include grams as default
            let measures = [{ label: 'g', weight: 1, isGrams: true }];

            // Add measures from API if available
            if (food.measures && food.measures.length > 0) {
                food.measures.forEach(m => {
                    if (m.label && m.weight && m.label.toLowerCase() !== 'gram') {
                        measures.push({
                            label: m.label,
                            weight: m.weight,
                            isGrams: false
                        });
                    }
                });
            }

            // Use first non-gram serving as default if available, otherwise 100g
            const defaultMeasure = measures.length > 1 ? measures[1] : measures[0];
            const defaultQty = defaultMeasure.isGrams ? 100 : 1;
            const defaultGrams = defaultMeasure.isGrams ? 100 : defaultMeasure.weight;

            customMealSelectedIngredients.push({
                fdcId: food.fdcId,
                name: food.name,
                quantity: defaultQty,
                quantityGrams: defaultGrams,
                selectedUnit: defaultMeasure.label,
                measures: measures,
                caloriesPer100g: food.caloriesPer100g,
                proteinPer100g: food.proteinPer100g,
                carbsPer100g: food.carbsPer100g,
                fatPer100g: food.fatPer100g
            });

            // Clear search
            document.getElementById('foodSearchInput').value = '';
            document.getElementById('foodSearchResults').classList.remove('active');
            document.getElementById('foodSearchResults').innerHTML = '';

            // Update UI
            renderCustomMealIngredients();
            updateCustomMealTotals();
        }

        function removeCustomMealIngredient(index) {
            customMealSelectedIngredients.splice(index, 1);
            renderCustomMealIngredients();
            updateCustomMealTotals();
        }

        function updateCustomMealIngredientQty(index, quantity) {
            const qty = parseFloat(quantity) || 0;
            const ing = customMealSelectedIngredients[index];
            ing.quantity = qty;

            // Recalculate grams based on current unit
            const measure = ing.measures.find(m => m.label === ing.selectedUnit);
            if (measure) {
                ing.quantityGrams = measure.isGrams ? qty : qty * measure.weight;
            }

            updateCustomMealTotals();
        }

        // Step ingredient quantity up or down with +/- buttons
        function stepIngredientQty(index, direction) {
            const ing = customMealSelectedIngredients[index];
            if (!ing) return;

            const isGrams = ing.selectedUnit === 'g';
            const stepAmount = isGrams ? 10 : 0.5; // 10g for grams, 0.5 for servings

            let newQty = ing.quantity + (stepAmount * direction);

            // Minimum value
            if (newQty < 0.1) newQty = 0.1;

            // Round appropriately
            if (isGrams) {
                newQty = Math.round(newQty);
            } else {
                newQty = Math.round(newQty * 10) / 10;
            }

            ing.quantity = newQty;

            // Recalculate grams
            const measure = ing.measures.find(m => m.label === ing.selectedUnit);
            if (measure) {
                ing.quantityGrams = measure.isGrams ? newQty : newQty * measure.weight;
            }

            // Re-render to update the input field and update totals
            renderCustomMealIngredients();
            updateCustomMealTotals();
        }

        function updateCustomMealIngredientUnit(index, unitLabel) {
            const ing = customMealSelectedIngredients[index];
            const newMeasure = ing.measures.find(m => m.label === unitLabel);

            if (!newMeasure) return;

            // Convert current grams to new unit quantity
            if (newMeasure.isGrams) {
                // Switching to grams - quantity becomes the gram value
                ing.quantity = Math.round(ing.quantityGrams);
            } else {
                // Switching to a serving unit - calculate how many servings
                ing.quantity = Math.round((ing.quantityGrams / newMeasure.weight) * 10) / 10;
                if (ing.quantity < 0.1) ing.quantity = 0.1;
            }

            ing.selectedUnit = unitLabel;

            // Recalculate grams to ensure consistency
            ing.quantityGrams = newMeasure.isGrams ? ing.quantity : ing.quantity * newMeasure.weight;

            renderCustomMealIngredients();
            updateCustomMealTotals();
        }

        function renderCustomMealIngredients() {
            const listDiv = document.getElementById('ingredientsList');
            const countSpan = document.getElementById('ingredientCount');

            countSpan.textContent = `(${customMealSelectedIngredients.length})`;

            if (customMealSelectedIngredients.length === 0) {
                listDiv.innerHTML = '<div class="no-ingredients">No ingredients added yet</div>';
                return;
            }

            listDiv.innerHTML = customMealSelectedIngredients.map((ing, index) => {
                const displayName = ing.name;
                const gramsInfo = ing.selectedUnit !== 'g' ? ` (${Math.round(ing.quantityGrams)}g)` : '';
                const titleText = `${escapeHtmlCustomMeal(ing.name)}${gramsInfo}`;

                // Build unit dropdown options
                const unitOptions = ing.measures.map(m => {
                    const selected = m.label === ing.selectedUnit ? 'selected' : '';
                    const weightInfo = m.isGrams ? '' : ` (${m.weight}g)`;
                    return `<option value="${escapeHtmlCustomMeal(m.label)}" ${selected}>${escapeHtmlCustomMeal(m.label)}${weightInfo}</option>`;
                }).join('');

                const isGrams = ing.selectedUnit === 'g';
                const stepAmount = isGrams ? 10 : 0.5;

                return `
                <div class="ingredient-item">
                    <span class="ingredient-name" title="${titleText}">${escapeHtmlCustomMeal(displayName)}</span>
                    <div class="qty-stepper">
                        <button class="qty-step-btn" onclick="stepIngredientQty(${index}, -1)" title="Decrease">‚àí</button>
                        <input type="number" class="ingredient-qty" value="${ing.quantity}" min="0.1" step="${stepAmount}"
                               onchange="updateCustomMealIngredientQty(${index}, this.value)"
                               oninput="updateCustomMealIngredientQty(${index}, this.value)"
                               onclick="event.stopPropagation()">
                        <button class="qty-step-btn" onclick="stepIngredientQty(${index}, 1)" title="Increase">+</button>
                    </div>
                    <select class="ingredient-unit-select" onchange="updateCustomMealIngredientUnit(${index}, this.value)">
                        ${unitOptions}
                    </select>
                    <button class="ingredient-remove" onclick="removeCustomMealIngredient(${index})" title="Remove">√ó</button>
                </div>
            `}).join('');
        }

        function updateCustomMealTotals() {
            let totalCal = 0, totalProtein = 0, totalCarbs = 0, totalFat = 0;

            customMealSelectedIngredients.forEach(ing => {
                // Use quantityGrams for accurate calculation
                const grams = ing.quantityGrams || ing.quantity;
                const factor = grams / 100;
                totalCal += ing.caloriesPer100g * factor;
                totalProtein += ing.proteinPer100g * factor;
                totalCarbs += ing.carbsPer100g * factor;
                totalFat += ing.fatPer100g * factor;
            });

            document.getElementById('calcTotalCalories').textContent = Math.round(totalCal);
            document.getElementById('calcTotalProtein').textContent = Math.round(totalProtein) + 'g';
            document.getElementById('calcTotalCarbs').textContent = Math.round(totalCarbs) + 'g';
            document.getElementById('calcTotalFat').textContent = Math.round(totalFat) + 'g';

            // Update meal name placeholder with auto-generated name
            const mealNameInput = document.getElementById('calculatedMealName');
            if (customMealSelectedIngredients.length > 0) {
                const autoName = customMealSelectedIngredients.map(ing => {
                    const grams = ing.quantityGrams || ing.quantity;
                    const shortName = ing.name.split(',')[0].trim();
                    if (ing.selectedUnit === 'g') {
                        return `${Math.round(grams)}g ${shortName}`;
                    } else {
                        return `${ing.quantity} ${ing.selectedUnit} ${shortName}`;
                    }
                }).join(', ');
                mealNameInput.placeholder = autoName;
            } else {
                mealNameInput.placeholder = 'Meal name (optional - auto-generated if blank)';
            }

            // Enable/disable create button
            const createBtn = document.getElementById('createCalculatedMealBtn');
            createBtn.disabled = customMealSelectedIngredients.length === 0;
        }

        async function submitManualMeal() {
            const mealName = document.getElementById('customMealName').value.trim();
            const calories = parseInt(document.getElementById('customMealCalories').value) || 0;
            const protein = parseInt(document.getElementById('customMealProtein').value) || 0;
            const carbs = parseInt(document.getElementById('customMealCarbs').value) || 0;
            const fat = parseInt(document.getElementById('customMealFat').value) || 0;
            const instructions = document.getElementById('customMealInstructions').value.trim() || 'Prepare as desired.';

            if (!mealName) {
                alert('Please enter a meal name');
                return;
            }

            if (calories === 0 && protein === 0 && carbs === 0 && fat === 0) {
                alert('Please enter at least some macro values');
                return;
            }

            // Validate macro math (calories should roughly equal P*4 + C*4 + F*9)
            if (calories > 0 && (protein > 0 || carbs > 0 || fat > 0)) {
                const calculatedCal = (protein * 4) + (carbs * 4) + (fat * 9);
                const variance = Math.abs(calories - calculatedCal);
                const variancePercent = (variance / calories) * 100;

                if (variancePercent > 25) {
                    const proceed = confirm(
                        `‚ö†Ô∏è Macro Math Check\n\n` +
                        `Entered: ${calories} calories\n` +
                        `Calculated from macros: ${calculatedCal} cal\n` +
                        `(Protein√ó4 + Carbs√ó4 + Fat√ó9)\n\n` +
                        `Difference: ${variance} cal (${Math.round(variancePercent)}%)\n\n` +
                        `This seems off. Continue anyway?`
                    );
                    if (!proceed) return;
                }
            }

            // Get the current meal for type reference
            let meal;
            if (currentCustomMealDayIndex !== null && currentCustomMealMealIndex !== null) {
                meal = currentPlan.days[currentCustomMealDayIndex].plan[currentCustomMealMealIndex];
            } else {
                meal = currentPlan.meals[currentCustomMealIndex];
            }

            // Save current meal state for undo
            const stateKey = currentCustomMealDayIndex !== null ? `${currentCustomMealDayIndex}-${currentCustomMealMealIndex}` : `${currentCustomMealIndex}`;
            previousMealStates[stateKey] = JSON.parse(JSON.stringify(meal));
            console.log(`üíæ Saved previous state for manual custom meal:`, previousMealStates[stateKey]);
            saveUndoStates(); // Persist to localStorage

            // Create the custom meal object
            const customMealData = {
                type: meal.type || 'meal',
                name: mealName,
                ingredients: [`${mealName} (manual entry)`],
                calories: calories,
                protein: protein,
                carbs: carbs,
                fat: fat,
                instructions: instructions,
                source: 'Manual Entry',
                isCustom: true
            };

            // Save to library if checkbox is checked
            const saveForLater = document.getElementById('saveManualForLater').checked;
            if (saveForLater) {
                saveMealToLibrary(customMealData);
            }

            // Save the custom meal
            if (currentCustomMealDayIndex !== null && currentCustomMealMealIndex !== null) {
                currentPlan.days[currentCustomMealDayIndex].plan[currentCustomMealMealIndex] = customMealData;
            } else {
                currentPlan.meals[currentCustomMealIndex] = customMealData;
            }
            localStorage.setItem('currentMealPlan', JSON.stringify(currentPlan));

            // Save to database
            await savePlanToDatabase();

            // Update day totals if multi-day
            if (currentCustomMealDayIndex !== null) {
                updateDayTotals(currentCustomMealDayIndex);
            }

            // Close modal and refresh display
            closeCustomMealModal();
            displayMealPlan();

            showNotification(`Custom meal created: ${calories} cal, ${protein}g protein`, 'success');
        }

        async function submitCalculatedMeal() {
            // Check if we have selected ingredients
            if (customMealSelectedIngredients.length === 0) {
                alert('Please search and add some ingredients first');
                return;
            }

            const index = currentCustomMealIndex;
            const dayIndex = currentCustomMealDayIndex;
            const mealIndex = currentCustomMealMealIndex;

            // Get the current meal for reference
            let meal;
            if (dayIndex !== null && mealIndex !== null) {
                meal = currentPlan.days[dayIndex].plan[mealIndex];
            } else {
                meal = currentPlan.meals[index];
            }

            // Save current meal state for undo
            const stateKey = dayIndex !== null ? `${dayIndex}-${mealIndex}` : `${index}`;
            previousMealStates[stateKey] = JSON.parse(JSON.stringify(meal));
            console.log(`üíæ Saved previous state for USDA custom meal:`, previousMealStates[stateKey]);
            saveUndoStates(); // Persist to localStorage

            // Calculate totals from selected ingredients
            let totalCal = 0, totalProtein = 0, totalCarbs = 0, totalFat = 0;
            const ingredients = [];

            customMealSelectedIngredients.forEach(ing => {
                // Use quantityGrams for accurate calculation
                const grams = ing.quantityGrams || ing.quantity;
                const multiplier = grams / 100;
                totalCal += ing.caloriesPer100g * multiplier;
                totalProtein += ing.proteinPer100g * multiplier;
                totalCarbs += ing.carbsPer100g * multiplier;
                totalFat += ing.fatPer100g * multiplier;

                // Format ingredient with unit (e.g., "Chicken (1 Cup)" or "Rice (150g)")
                const unitDisplay = ing.selectedUnit === 'g' ? `${Math.round(grams)}g` : `${ing.quantity} ${ing.selectedUnit}`;
                ingredients.push(`${ing.name} (${unitDisplay})`);
            });

            // Generate meal name - show ALL ingredients with servings
            // e.g., "200g Sirloin Steak, 1 Cup Brown Rice, 2 Tbsp Olive Oil"
            let mealName = document.getElementById('calculatedMealName').value.trim();
            if (!mealName) {
                const ingredientParts = customMealSelectedIngredients.map(ing => {
                    const grams = ing.quantityGrams || ing.quantity;
                    const shortName = ing.name.split(',')[0].trim();
                    const displayName = shortName;

                    if (ing.selectedUnit === 'g') {
                        return `${Math.round(grams)}g ${displayName}`;
                    } else {
                        return `${ing.quantity} ${ing.selectedUnit} ${displayName}`;
                    }
                });

                mealName = ingredientParts.join(', ');
            }

            // Create the custom meal object
            const customMealData = {
                type: meal.type || 'meal',
                name: mealName,
                ingredients: ingredients,
                calories: Math.round(totalCal),
                protein: Math.round(totalProtein),
                carbs: Math.round(totalCarbs),
                fat: Math.round(totalFat),
                instructions: 'Prepare as desired.',
                source: 'Food Database',
                isCustom: true
            };

            // Save to library if checkbox is checked
            const saveForLater = document.getElementById('saveCalculatedForLater').checked;
            if (saveForLater) {
                saveMealToLibrary(customMealData);
            }

            console.log('‚úÖ Custom meal created:', customMealData);

            // Save the custom meal
            if (dayIndex !== null && mealIndex !== null) {
                currentPlan.days[dayIndex].plan[mealIndex] = customMealData;
            } else {
                currentPlan.meals[index] = customMealData;
            }
            localStorage.setItem('currentMealPlan', JSON.stringify(currentPlan));

            // Close modal
            closeCustomMealModal();

            // Save to database
            await savePlanToDatabase();

            // Update day totals if multi-day
            if (dayIndex !== null) {
                updateDayTotals(dayIndex);
            }

            displayMealPlan();

            showNotification(`Custom meal created: ${customMealData.calories} cal, ${customMealData.protein}g protein`, 'success');
        }

        function displayMealPlan() {
            console.log('üìã displayMealPlan called, currentPlan:', currentPlan);

            // FIXED: Handle both multi-day and single-day plans
            let nutrition = currentPlan.nutrition || {};

            // Check if nutrition values are missing or zero
            if (!nutrition.calories && !nutrition.protein && !nutrition.carbs && !nutrition.fat) {
                console.warn('‚ö†Ô∏è Nutrition object empty or all zeros, calculating from plan...');

                // Calculate based on plan type
                if (currentPlan.multiDay && currentPlan.days && currentPlan.days.length > 0) {
                    // For multi-day, get from first day's targets
                    if (currentPlan.days[0].targets) {
                        nutrition = { ...currentPlan.days[0].targets };
                        console.log('‚úÖ Got nutrition from day 1 targets:', nutrition);
                    }
                } else if (currentPlan.meals && currentPlan.meals.length > 0) {
                    // For single-day, calculate totals from meals
                    nutrition = { calories: 0, protein: 0, carbs: 0, fat: 0 };
                    currentPlan.meals.forEach(meal => {
                        nutrition.calories += parseInt(meal.calories) || 0;
                        nutrition.protein += parseInt(meal.protein) || 0;
                        nutrition.carbs += parseInt(meal.carbs) || 0;
                        nutrition.fat += parseInt(meal.fat) || 0;
                    });
                    console.log('‚úÖ Calculated nutrition from meals:', nutrition);
                }

                currentPlan.nutrition = nutrition;
                localStorage.setItem('currentMealPlan', JSON.stringify(currentPlan));
            }

            console.log('üìä Displaying Daily Targets:', nutrition);

            // Display DAILY nutrition totals
            document.getElementById('totalCalories').textContent = nutrition.calories || 0;
            document.getElementById('totalProtein').textContent = (nutrition.protein || 0) + 'g';
            document.getElementById('totalCarbs').textContent = (nutrition.carbs || 0) + 'g';
            document.getElementById('totalFat').textContent = (nutrition.fat || 0) + 'g';

            // Display coach notes if present
            const existingNotesSection = document.getElementById('coachNotesSection');
            if (existingNotesSection) {
                existingNotesSection.remove();
            }

            if (currentPlan.coachNotes) {
                const notesSection = document.createElement('div');
                notesSection.id = 'coachNotesSection';
                notesSection.style.cssText = 'background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); padding: 20px; border-radius: 12px; margin-bottom: 20px; border: 1px solid #7dd3fc;';
                notesSection.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
                        <span style="font-size: 20px;">üìù</span>
                        <h3 style="margin: 0; color: #0369a1; font-size: 16px; font-weight: 600;">Message from Your Coach</h3>
                    </div>
                    <p style="margin: 0; color: #334155; font-size: 15px; line-height: 1.6; white-space: pre-wrap;">${linkifyText(currentPlan.coachNotes)}</p>
                `;
                document.getElementById('mealsContainer').parentNode.insertBefore(notesSection, document.getElementById('mealsContainer'));
            }

            // Display meals - FIXED for multi-day plans
            const container = document.getElementById('mealsContainer');
            container.innerHTML = '';

            // Helper function to get color class based on variance
            const getVarianceColor = (variancePercent) => {
                const abs = Math.abs(variancePercent);
                if (abs <= 10) return '#16a34a'; // green - within ¬±10%
                if (abs <= 20) return '#ca8a04'; // yellow - within ¬±20%
                return '#dc2626'; // red - over ¬±20%
            };

            // Helper function to format variance display
            const formatVariance = (actual, target, variancePercent) => {
                const diff = actual - target;
                const sign = diff >= 0 ? '+' : '';
                return `${sign}${diff} (${sign}${variancePercent.toFixed(1)}%)`;
            };

            if (currentPlan.multiDay && currentPlan.days) {
                // Multi-day plan: show days with separators
                currentPlan.days.forEach((dayData, dayIndex) => {
                    // Calculate per-day actual totals
                    let dayTotals = { calories: 0, protein: 0, carbs: 0, fat: 0 };
                    if (dayData.plan && Array.isArray(dayData.plan)) {
                        dayData.plan.forEach(meal => {
                            dayTotals.calories += parseInt(meal.calories) || 0;
                            dayTotals.protein += parseInt(meal.protein) || 0;
                            dayTotals.carbs += parseInt(meal.carbs) || 0;
                            dayTotals.fat += parseInt(meal.fat) || 0;
                        });
                    }

                    // Get targets (use day targets if available, otherwise use plan nutrition)
                    const targets = dayData.targets || nutrition;

                    // Calculate per-day variance
                    const dayVariance = {
                        calories: targets.calories ? ((dayTotals.calories - targets.calories) / targets.calories * 100) : 0,
                        protein: targets.protein ? ((dayTotals.protein - targets.protein) / targets.protein * 100) : 0,
                        carbs: targets.carbs ? ((dayTotals.carbs - targets.carbs) / targets.carbs * 100) : 0,
                        fat: targets.fat ? ((dayTotals.fat - targets.fat) / targets.fat * 100) : 0
                    };

                    // Day header with regenerate button
                    const dayHeader = document.createElement('div');
                    dayHeader.className = 'day-header';
                    dayHeader.style.cssText = 'background: linear-gradient(135deg, #0d9488 0%, #0284c7 100%); color: white; padding: 15px 20px; border-radius: 12px; margin: 20px 0 15px 0; font-weight: 700; font-size: 1.3em; display: flex; justify-content: space-between; align-items: center;';

                    // Check if client view - hide regenerate button for clients
                    const urlParams = new URLSearchParams(window.location.search);
                    const isClientView = urlParams.get('clientView') === 'true';

                    dayHeader.innerHTML = `
                        <span>Day ${dayData.day}</span>
                        ${!isClientView ? `<button onclick="regenerateDay(${dayIndex})" class="btn" style="background: rgba(255,255,255,0.2); color: white; border: 1px solid rgba(255,255,255,0.3); padding: 8px 16px; font-size: 0.8em;">üîÑ Regenerate Day</button>` : ''}
                    `;
                    container.appendChild(dayHeader);

                    // Calculate macro distribution percentages (% of total calories from each macro)
                    const macroPercent = {
                        protein: dayTotals.calories > 0 ? Math.round((dayTotals.protein * 4) / dayTotals.calories * 100) : 0,
                        carbs: dayTotals.calories > 0 ? Math.round((dayTotals.carbs * 4) / dayTotals.calories * 100) : 0,
                        fat: dayTotals.calories > 0 ? Math.round((dayTotals.fat * 9) / dayTotals.calories * 100) : 0
                    };

                    // Day totals section
                    const dayTotalsDiv = document.createElement('div');
                    dayTotalsDiv.id = `day-totals-${dayIndex}`;
                    dayTotalsDiv.style.cssText = 'background: #f8f9ff; padding: 15px; border-radius: 10px; margin-bottom: 15px; border: 1px solid #e0e7ff;';
                    dayTotalsDiv.innerHTML = `
                        <p style="font-size: 0.85em; font-weight: 600; color: #666; margin-bottom: 10px;">Day ${dayData.day} Totals:</p>
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; text-align: center;">
                            <div>
                                <p style="font-size: 0.75em; color: #888;">Calories</p>
                                <span style="font-weight: 700; color: ${getVarianceColor(dayVariance.calories)}">${dayTotals.calories}</span>
                                <p style="font-size: 0.7em; color: ${getVarianceColor(dayVariance.calories)}">${formatVariance(dayTotals.calories, targets.calories, dayVariance.calories)}</p>
                            </div>
                            <div>
                                <p style="font-size: 0.75em; color: #888;">Protein</p>
                                <span style="font-weight: 700; color: ${getVarianceColor(dayVariance.protein)}">${dayTotals.protein}g</span>
                                <span style="font-size: 0.7em; font-weight: 500; color: #10b981; display: block;">${macroPercent.protein}%</span>
                                <p style="font-size: 0.7em; color: ${getVarianceColor(dayVariance.protein)}">${formatVariance(dayTotals.protein, targets.protein, dayVariance.protein)}</p>
                            </div>
                            <div>
                                <p style="font-size: 0.75em; color: #888;">Carbs</p>
                                <span style="font-weight: 700; color: ${getVarianceColor(dayVariance.carbs)}">${dayTotals.carbs}g</span>
                                <span style="font-size: 0.7em; font-weight: 500; color: #f59e0b; display: block;">${macroPercent.carbs}%</span>
                                <p style="font-size: 0.7em; color: ${getVarianceColor(dayVariance.carbs)}">${formatVariance(dayTotals.carbs, targets.carbs, dayVariance.carbs)}</p>
                            </div>
                            <div>
                                <p style="font-size: 0.75em; color: #888;">Fat</p>
                                <span style="font-weight: 700; color: ${getVarianceColor(dayVariance.fat)}">${dayTotals.fat}g</span>
                                <span style="font-size: 0.7em; font-weight: 500; color: #3b82f6; display: block;">${macroPercent.fat}%</span>
                                <p style="font-size: 0.7em; color: ${getVarianceColor(dayVariance.fat)}">${formatVariance(dayTotals.fat, targets.fat, dayVariance.fat)}</p>
                            </div>
                        </div>
                        <div style="margin-top: 8px; text-align: center; font-size: 0.7em; color: #888;">
                            <span style="color: #16a34a;">‚óè</span> Within ¬±10% |
                            <span style="color: #ca8a04;">‚óè</span> Within ¬±20% |
                            <span style="color: #dc2626;">‚óè</span> Over ¬±20%
                        </div>
                    `;
                    container.appendChild(dayTotalsDiv);

                    // Meals for this day
                    if (dayData.plan && Array.isArray(dayData.plan)) {
                        dayData.plan.forEach((meal, mealIndex) => {
                            const mealCard = createMealCard(meal, `${dayIndex}-${mealIndex}`, dayIndex, mealIndex);
                            container.appendChild(mealCard);
                        });
                    }
                });
            } else if (currentPlan.meals) {
                // Single-day plan: show meals directly
                currentPlan.meals.forEach((meal, index) => {
                    const mealCard = createMealCard(meal, index);
                    container.appendChild(mealCard);
                });
            }
        }

        function createMealCard(meal, index, dayIndex = null, mealIndex = null) {
            const card = document.createElement('div');
            card.className = 'meal-card';
            card.id = `meal-${index}`;

            // For multi-day plans, pass both indices; for single-day, pass just the index
            const changeParam = dayIndex !== null ? `'${index}', ${dayIndex}, ${mealIndex}` : index;
            const reviseParam = dayIndex !== null ? `'${index}', ${dayIndex}, ${mealIndex}` : index;

            // Check if client view
            const urlParams = new URLSearchParams(window.location.search);
            const isClientView = urlParams.get('clientView') === 'true' || urlParams.get('share');

            // Check if meal is already favorited
            const isFavorited = clientFavorites.some(f => f.meal_name === meal.name);
            const favoriteClass = isFavorited ? 'active' : '';
            const favoriteIcon = isFavorited ? '‚ù§Ô∏è' : 'ü§ç';

            // Escape meal name for use in onclick
            const escapedMealName = meal.name.replace(/'/g, "\\'").replace(/"/g, '\\"');

            // Get existing note for this meal
            const mealNote = meal.coach_note || '';

            // Build notes section based on view type
            let notesSection = '';
            if (isClientView) {
                // Client view: show note if exists (read-only)
                if (mealNote) {
                    notesSection = `
                        <div class="meal-note-display" style="background: #fef3c7; border-left: 4px solid #f59e0b; padding: 12px 15px; margin-top: 15px; border-radius: 0 8px 8px 0;">
                            <div style="font-weight: 600; color: #92400e; font-size: 0.85em; margin-bottom: 6px;">üìù Coach Note:</div>
                            <div style="color: #78350f; font-size: 0.95em; line-height: 1.5; white-space: pre-wrap;">${linkifyText(mealNote)}</div>
                        </div>
                    `;
                }
            } else {
                // Coach view: show editable note field
                notesSection = `
                    <div class="meal-note-section" style="margin-top: 15px; background: #f0f9ff; padding: 12px; border-radius: 8px; border: 1px solid #bae6fd;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <span style="font-weight: 600; color: #0369a1; font-size: 0.85em;">üìù Note for Client:</span>
                            <button class="btn" onclick="saveMealNote('${index}', ${dayIndex}, ${mealIndex})" style="background: #0284c7; color: white; padding: 4px 12px; font-size: 0.8em; border-radius: 4px;">Save Note</button>
                        </div>
                        <textarea id="meal-note-${index}" style="width: 100%; min-height: 60px; padding: 8px; border: 1px solid #7dd3fc; border-radius: 6px; font-size: 0.9em; resize: vertical;" placeholder="Add a note for your client about this meal...">${mealNote}</textarea>
                    </div>
                `;
            }

            // Build action buttons - clients can also change/revise meals
            // Check if there's a previous state for undo
            const undoStateKey = dayIndex !== null ? `${dayIndex}-${mealIndex}` : `${index}`;
            const hasUndoState = previousMealStates[undoStateKey] !== undefined;
            const undoButton = hasUndoState
                ? `<button class="btn btn-undo" onclick="undoRevision(${changeParam})" title="Undo last revision">‚Ü©Ô∏è Undo</button>`
                : '';

            // Build portions param - same pattern as change/revise
            const portionsParam = dayIndex !== null ? `event, '${index}', ${dayIndex}, ${mealIndex}` : `event, ${index}`;

            let actionButtons = `
                <button class="btn btn-favorite ${favoriteClass}" id="fav-${index}" onclick="toggleFavorite('${escapedMealName}', '${meal.type || ''}', ${meal.calories}, ${meal.protein}, ${meal.carbs}, ${meal.fat}, '${index}')" title="${isFavorited ? 'Remove from favorites' : 'Add to favorites'}">${favoriteIcon}</button>
                <button class="btn btn-change" onclick="changeMeal(${changeParam})">üîÑ Change</button>
                <button class="btn btn-revise" onclick="reviseMeal(${changeParam})">‚úèÔ∏è Revise</button>
                <button class="btn btn-portions" onclick="showPortionsDropdown(${portionsParam})" title="Adjust serving size">‚öñÔ∏è Portions</button>
                <button class="btn btn-custom" onclick="customMeal(${changeParam})" title="Create exact meal from scratch">üéØ Custom</button>
                ${undoButton}
            `;

            card.innerHTML = `
                <div class="meal-header">
                    <div class="meal-name">${meal.name}</div>
                    <div class="meal-actions">
                        ${actionButtons}
                    </div>
                </div>
                <div class="macro-grid">
                    <div class="macro-item">
                        <div class="macro-label">Calories</div>
                        <div class="macro-value">${meal.calories}</div>
                    </div>
                    <div class="macro-item">
                        <div class="macro-label">Protein</div>
                        <div class="macro-value">${meal.protein}g</div>
                    </div>
                    <div class="macro-item">
                        <div class="macro-label">Carbs</div>
                        <div class="macro-value">${meal.carbs}g</div>
                    </div>
                    <div class="macro-item">
                        <div class="macro-label">Fat</div>
                        <div class="macro-value">${meal.fat}g</div>
                    </div>
                </div>
                <div class="instructions">
                    <span class="instructions-label">üìù Instructions:</span>
                    ${meal.instructions}
                </div>
                ${notesSection}
            `;
            return card;
        }

        // Update day totals after meal changes (undo, revise, change, custom)
        function updateDayTotals(dayIndex) {
            if (!currentPlan.multiDay || !currentPlan.days || !currentPlan.days[dayIndex]) {
                console.log('‚ö†Ô∏è updateDayTotals: Not a multi-day plan or invalid dayIndex');
                return;
            }

            const dayData = currentPlan.days[dayIndex];
            const dayTotalsDiv = document.getElementById(`day-totals-${dayIndex}`);

            if (!dayTotalsDiv) {
                console.log('‚ö†Ô∏è updateDayTotals: Could not find day-totals div for day', dayIndex);
                return;
            }

            // Recalculate totals from meals
            let dayTotals = { calories: 0, protein: 0, carbs: 0, fat: 0 };
            if (dayData.plan && Array.isArray(dayData.plan)) {
                dayData.plan.forEach(meal => {
                    dayTotals.calories += parseInt(meal.calories) || 0;
                    dayTotals.protein += parseInt(meal.protein) || 0;
                    dayTotals.carbs += parseInt(meal.carbs) || 0;
                    dayTotals.fat += parseInt(meal.fat) || 0;
                });
            }

            // Get targets (use day targets if available, otherwise use plan nutrition)
            const nutrition = currentPlan.nutrition || {};
            const targets = dayData.targets || nutrition;

            // Calculate variance
            const dayVariance = {
                calories: targets.calories ? ((dayTotals.calories - targets.calories) / targets.calories * 100) : 0,
                protein: targets.protein ? ((dayTotals.protein - targets.protein) / targets.protein * 100) : 0,
                carbs: targets.carbs ? ((dayTotals.carbs - targets.carbs) / targets.carbs * 100) : 0,
                fat: targets.fat ? ((dayTotals.fat - targets.fat) / targets.fat * 100) : 0
            };

            // Calculate macro distribution percentages
            const macroPercent = {
                protein: dayTotals.calories > 0 ? Math.round((dayTotals.protein * 4) / dayTotals.calories * 100) : 0,
                carbs: dayTotals.calories > 0 ? Math.round((dayTotals.carbs * 4) / dayTotals.calories * 100) : 0,
                fat: dayTotals.calories > 0 ? Math.round((dayTotals.fat * 9) / dayTotals.calories * 100) : 0
            };

            // Helper functions for display
            const getVarianceColor = (variancePercent) => {
                const abs = Math.abs(variancePercent);
                if (abs <= 10) return '#16a34a'; // green - within ¬±10%
                if (abs <= 20) return '#ca8a04'; // yellow - within ¬±20%
                return '#dc2626'; // red - over ¬±20%
            };

            const formatVariance = (actual, target, variancePercent) => {
                const diff = actual - target;
                const sign = diff >= 0 ? '+' : '';
                return `${sign}${diff} (${sign}${variancePercent.toFixed(1)}%)`;
            };

            // Update the day totals div
            dayTotalsDiv.innerHTML = `
                <p style="font-size: 0.85em; font-weight: 600; color: #666; margin-bottom: 10px;">Day ${dayData.day} Totals:</p>
                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; text-align: center;">
                    <div>
                        <p style="font-size: 0.75em; color: #888;">Calories</p>
                        <span style="font-weight: 700; color: ${getVarianceColor(dayVariance.calories)}">${dayTotals.calories}</span>
                        <p style="font-size: 0.7em; color: ${getVarianceColor(dayVariance.calories)}">${formatVariance(dayTotals.calories, targets.calories, dayVariance.calories)}</p>
                    </div>
                    <div>
                        <p style="font-size: 0.75em; color: #888;">Protein</p>
                        <span style="font-weight: 700; color: ${getVarianceColor(dayVariance.protein)}">${dayTotals.protein}g</span>
                        <span style="font-size: 0.7em; font-weight: 500; color: #10b981; display: block;">${macroPercent.protein}%</span>
                        <p style="font-size: 0.7em; color: ${getVarianceColor(dayVariance.protein)}">${formatVariance(dayTotals.protein, targets.protein, dayVariance.protein)}</p>
                    </div>
                    <div>
                        <p style="font-size: 0.75em; color: #888;">Carbs</p>
                        <span style="font-weight: 700; color: ${getVarianceColor(dayVariance.carbs)}">${dayTotals.carbs}g</span>
                        <span style="font-size: 0.7em; font-weight: 500; color: #f59e0b; display: block;">${macroPercent.carbs}%</span>
                        <p style="font-size: 0.7em; color: ${getVarianceColor(dayVariance.carbs)}">${formatVariance(dayTotals.carbs, targets.carbs, dayVariance.carbs)}</p>
                    </div>
                    <div>
                        <p style="font-size: 0.75em; color: #888;">Fat</p>
                        <span style="font-weight: 700; color: ${getVarianceColor(dayVariance.fat)}">${dayTotals.fat}g</span>
                        <span style="font-size: 0.7em; font-weight: 500; color: #3b82f6; display: block;">${macroPercent.fat}%</span>
                        <p style="font-size: 0.7em; color: ${getVarianceColor(dayVariance.fat)}">${formatVariance(dayTotals.fat, targets.fat, dayVariance.fat)}</p>
                    </div>
                </div>
                <div style="margin-top: 8px; text-align: center; font-size: 0.7em; color: #888;">
                    <span style="color: #16a34a;">‚óè</span> Within ¬±10% |
                    <span style="color: #ca8a04;">‚óè</span> Within ¬±20% |
                    <span style="color: #dc2626;">‚óè</span> Over ¬±20%
                </div>
            `;

            console.log(`‚úÖ Updated day ${dayIndex} totals:`, dayTotals);
        }

        async function undoRevision(index, dayIndex = null, mealIndex = null) {
            // Get the state key
            const stateKey = dayIndex !== null ? `${dayIndex}-${mealIndex}` : `${index}`;
            const previousState = previousMealStates[stateKey];

            if (!previousState) {
                alert('No previous state to undo');
                return;
            }

            console.log(`‚Ü©Ô∏è Undoing revision for meal ${stateKey}:`, previousState);

            // Restore the previous meal state
            if (dayIndex !== null && mealIndex !== null) {
                // Multi-day plan
                currentPlan.days[dayIndex].plan[mealIndex] = JSON.parse(JSON.stringify(previousState));
            } else {
                // Single-day plan
                currentPlan.meals[index] = JSON.parse(JSON.stringify(previousState));
            }

            // Remove the undo state (can only undo once)
            delete previousMealStates[stateKey];
            saveUndoStates(); // Persist to localStorage

            // Save to localStorage
            localStorage.setItem('currentMealPlan', JSON.stringify(currentPlan));

            // Save to database
            await savePlanToDatabase();

            // Re-render the FULL plan (like planner.html does)
            displayMealPlan();

            // Show success message
            alert('Undo successful! Meal restored to previous state.');
        }

        // ADJUST PORTIONS - Quick serving size adjustment
        function showPortionsDropdown(event, index, dayIndex = null, mealIndex = null) {
            // Remove any existing dropdown
            const existingDropdown = document.querySelector('.portions-dropdown');
            if (existingDropdown) {
                existingDropdown.remove();
            }

            const buttonElement = event.target;
            const dropdown = document.createElement('div');
            dropdown.className = 'portions-dropdown';

            const options = [
                { label: '0.5x (Half)', multiplier: 0.5 },
                { label: '0.75x', multiplier: 0.75 },
                { label: '1.25x', multiplier: 1.25 },
                { label: '1.5x', multiplier: 1.5 },
                { label: '2x (Double)', multiplier: 2 }
            ];

            options.forEach(option => {
                const btn = document.createElement('button');
                btn.textContent = option.label;
                btn.onclick = (e) => {
                    e.stopPropagation();
                    adjustPortions(index, dayIndex, mealIndex, option.multiplier);
                    dropdown.remove();
                };
                dropdown.appendChild(btn);
            });

            // Position the dropdown below the button
            const rect = buttonElement.getBoundingClientRect();
            dropdown.style.position = 'fixed';
            dropdown.style.top = `${rect.bottom + 5}px`;
            dropdown.style.left = `${rect.left}px`;

            document.body.appendChild(dropdown);

            // Close dropdown when clicking outside
            const closeDropdown = (e) => {
                if (!dropdown.contains(e.target) && e.target !== buttonElement) {
                    dropdown.remove();
                    document.removeEventListener('click', closeDropdown);
                }
            };
            setTimeout(() => document.addEventListener('click', closeDropdown), 0);
        }

        async function adjustPortions(index, dayIndex, mealIndex, multiplier) {
            // Get the meal based on plan structure
            let meal;
            if (dayIndex !== null && mealIndex !== null) {
                // Multi-day plan
                meal = currentPlan.days[dayIndex].plan[mealIndex];
            } else {
                // Single-day plan
                meal = currentPlan.meals[index];
            }

            // Save current meal state for undo functionality
            const stateKey = dayIndex !== null ? `${dayIndex}-${mealIndex}` : `${index}`;
            previousMealStates[stateKey] = JSON.parse(JSON.stringify(meal));
            saveUndoStates();
            console.log(`üíæ Saved previous state for undo (portions):`, previousMealStates[stateKey]);

            // Scale macros proportionally
            meal.calories = Math.round(meal.calories * multiplier);
            meal.protein = Math.round(meal.protein * multiplier);
            meal.carbs = Math.round(meal.carbs * multiplier);
            meal.fat = Math.round(meal.fat * multiplier);

            // Update meal name to reflect portion change
            const portionLabel = `${multiplier}x portion`;
            if (!meal.name.includes('portion')) {
                meal.name = `${meal.name} (${portionLabel})`;
            } else {
                // Replace existing portion label
                meal.name = meal.name.replace(/\s*\([0-9.]+x portion\)/, ` (${portionLabel})`);
            }

            // Save to localStorage
            localStorage.setItem('currentMealPlan', JSON.stringify(currentPlan));

            // Save to database
            await savePlanToDatabase();

            // Re-render the plan
            displayMealPlan();

            console.log(`‚öñÔ∏è Adjusted portions for ${meal.type}: ${multiplier}x`);
        }

        async function saveMealNote(index, dayIndex = null, mealIndex = null) {
            const textarea = document.getElementById(`meal-note-${index}`);
            const note = textarea.value.trim();
            const saveBtn = textarea.parentElement.querySelector('button');

            // Update the meal in currentPlan
            let meal;
            if (dayIndex !== null && mealIndex !== null) {
                // Multi-day plan
                meal = currentPlan.days[dayIndex].plan[mealIndex];
            } else if (currentPlan.meals) {
                // Single-day plan
                meal = currentPlan.meals[index];
            } else if (currentPlan.days) {
                // Fallback for days structure
                const parts = index.split('-');
                if (parts.length === 2) {
                    meal = currentPlan.days[parseInt(parts[0])].plan[parseInt(parts[1])];
                }
            }

            if (!meal) {
                alert('Error: Could not find meal to save note');
                return;
            }

            // Save the note to the meal
            meal.coach_note = note;

            // Show saving state
            const originalText = saveBtn.textContent;
            saveBtn.textContent = 'Saving...';
            saveBtn.disabled = true;

            try {
                // Get planId from URL
                const urlParams = new URLSearchParams(window.location.search);
                const planId = urlParams.get('planId');

                if (planId) {
                    // Save to database
                    const { error } = await supabaseClient
                        .from('coach_meal_plans')
                        .update({ plan_data: currentPlan })
                        .eq('id', planId);

                    if (error) throw error;
                }

                // Also update localStorage if available
                localStorage.setItem('currentMealPlan', JSON.stringify(currentPlan));

                saveBtn.textContent = 'Saved!';
                saveBtn.style.background = '#16a34a';

                setTimeout(() => {
                    saveBtn.textContent = originalText;
                    saveBtn.style.background = '#0284c7';
                    saveBtn.disabled = false;
                }, 2000);

            } catch (error) {
                console.error('Error saving note:', error);
                saveBtn.textContent = 'Error';
                saveBtn.style.background = '#dc2626';

                setTimeout(() => {
                    saveBtn.textContent = originalText;
                    saveBtn.style.background = '#0284c7';
                    saveBtn.disabled = false;
                }, 2000);
            }
        }

        async function reviseMeal(index, dayIndex = null, mealIndex = null) {
            // Get the meal based on plan structure
            let meal;
            if (dayIndex !== null && mealIndex !== null) {
                // Multi-day plan
                meal = currentPlan.days[dayIndex].plan[mealIndex];
            } else {
                // Single-day plan
                meal = currentPlan.meals[index];
            }

            // Use window.prompt() like planner.html does
            const revisionText = window.prompt(
                `Revise "${meal.name}"?\n\nEnter your specific request (e.g., "make it vegetarian", "swap rice for sweet potato", "just protein shake with creatine"):`,
                ''
            );

            if (!revisionText || !revisionText.trim()) {
                return; // User cancelled or entered empty string
            }

            const mealCard = document.getElementById(`meal-${index}`);

            // Save current meal state for undo functionality
            const stateKey = dayIndex !== null ? `${dayIndex}-${mealIndex}` : `${index}`;
            previousMealStates[stateKey] = JSON.parse(JSON.stringify(meal)); // Deep copy
            console.log(`üíæ Saved previous state for meal ${stateKey}:`, previousMealStates[stateKey]);
            saveUndoStates(); // Persist to localStorage

            // Show loading
            mealCard.innerHTML = '<div class="spinner"></div><p style="text-align:center;">Revising meal...</p>';

            try {
                // Use EXACT same prompt as planner.html for consistency
                const prompt = `Revise this meal based on user request: "${meal.name}" (${meal.type || 'meal'})

USER REQUEST: ${revisionText}

CURRENT MEAL:
- Calories: ${meal.calories}
- Protein: ${meal.protein}g
- Carbs: ${meal.carbs}g
- Fat: ${meal.fat}g
- Ingredients: ${meal.ingredients ? (Array.isArray(meal.ingredients) ? meal.ingredients.join(', ') : meal.ingredients) : 'N/A'}

REVISION RULES - Follow these carefully:

1. EXPLICIT AMOUNTS: If user specifies exact amount (e.g., "make salmon 200g", "use 2 eggs"),
   use EXACTLY that amount even if it changes the meal's total calories.

2. VAGUE INCREASE: If user says "increase salmon" or "more protein" (no specific amount),
   increase by a reasonable amount (~30-50%) AND reduce other ingredients to keep total calories similar.

3. SWAP INGREDIENT: If user says "swap salmon for chicken" or "replace rice with quinoa",
   calculate the NEW ingredient amount to match the CALORIES of the original ingredient.
   Example: 130g salmon (230 cal) ‚Üí ~140g chicken breast to match ~230 cal

4. ADD NEW INGREDIENT: If user says "add chicken" to a meal that has none,
   ADD it on top - the meal will be bigger. Don't reduce other ingredients.

5. COMPLETE REPLACEMENT: If user specifies a simple meal or uses words like
   "just", "only", "make it", "change to", or "replace with":
   - Return ONLY the EXACT ingredients they specify - NOTHING ELSE
   - Do NOT add milk, water, banana, oats, peanut butter or ANY other ingredients
   - Do NOT try to make it a "complete meal" or "balanced"
   - Example: "just protein shake 2 scoops" = {"ingredients": ["Whey Protein (2 scoops)"]} - ONLY ONE INGREDIENT
   - Example: "only eggs and toast" = {"ingredients": ["Eggs (2 whole)", "Whole Wheat Bread (2 slices)"]} - ONLY TWO INGREDIENTS
   - The user WANTS a simple/small meal - this is intentional, not a mistake

Diet: ${currentPlan.preferences?.dietType || 'any'}
${currentPlan.preferences?.allergies ? `Avoid: ${currentPlan.preferences.allergies}` : ''}

Use ONLY foods from USDA database - you can choose from 200+ foods including:
Proteins: Chicken Breast, Salmon, Ground Turkey, Eggs, Shrimp, Tofu, Greek Yogurt, Whey Protein
Carbs: Brown Rice, Quinoa, Sweet Potato, Oats, Whole Wheat Bread, Pasta
Fats: Olive Oil, Avocado, Almonds, Peanut Butter
Vegetables: Broccoli, Spinach, Bell Pepper, Asparagus, etc.

CRITICAL:
1. Return ingredients as ARRAY OF STRINGS with amounts in parentheses
2. DO NOT include calories/protein/carbs/fat - backend will calculate from database
MEAL NAME FORMAT: Include ALL key ingredient portions inline in parentheses

EXAMPLE FORMAT:
{"type":"${meal.type || 'meal'}","name":"Whey Protein Shake (2 scoops)","ingredients":["Whey Protein (2 scoops)"],"instructions":"Mix with water and consume."}

Return ONLY valid JSON. NO quotes in text - use apostrophes. Keep it brief.`;

                // Send isJson and targets, but skipAutoScale for revise (user controls portions)
                const response = await fetch(API_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt,
                        isJson: true,
                        skipAutoScale: true, // Don't auto-scale revisions - user controls the portions
                        targets: {
                            calories: meal.calories || 500,
                            protein: meal.protein || 30,
                            carbs: meal.carbs || 50,
                            fat: meal.fat || 15
                        },
                        mealsPerDay: 1
                    })
                });

                if (!response.ok) throw new Error('API request failed');

                const data = await response.json();

                let revisedMeal;
                // Handle new backend format (with USDA calculation)
                if (data.success && data.data) {
                    console.log('‚úÖ Using new format with USDA calculation');
                    revisedMeal = data.data;

                    // Validate that backend calculated macros
                    if (!revisedMeal.calories || revisedMeal.calories === 0) {
                        console.warn('‚ö†Ô∏è Backend returned zero calories - ingredients may not have matched');
                    }
                } else {
                    // FALLBACK: Old Gemini format (shouldn't happen with new code)
                    console.log('‚ö†Ô∏è Using old Gemini format - macros may be inaccurate');
                    let text = data.candidates[0].content.parts[0].text;
                    text = text.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim();
                    text = text.replace(/:\s*NaN/g, ': null');

                    const jsonMatch = text.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        text = jsonMatch[0];
                    }

                    revisedMeal = JSON.parse(text);
                }

                // Ensure meal has required fields
                revisedMeal.type = revisedMeal.type || meal.type || 'meal';
                revisedMeal.name = revisedMeal.name || 'Revised Meal';
                revisedMeal.instructions = revisedMeal.instructions || meal.instructions || '';

                // Use calculated macros - only fallback if truly undefined/null (not 0)
                // Note: 0 is a valid value if ingredient wasn't found, so log warning
                if (revisedMeal.calories === 0 || revisedMeal.calories === undefined || revisedMeal.calories === null) {
                    console.warn('‚ö†Ô∏è Backend returned 0/missing calories - ingredient may not be in database');
                }
                revisedMeal.calories = revisedMeal.calories !== undefined && revisedMeal.calories !== null ? revisedMeal.calories : meal.calories;
                revisedMeal.protein = revisedMeal.protein !== undefined && revisedMeal.protein !== null ? revisedMeal.protein : meal.protein;
                revisedMeal.carbs = revisedMeal.carbs !== undefined && revisedMeal.carbs !== null ? revisedMeal.carbs : meal.carbs;
                revisedMeal.fat = revisedMeal.fat !== undefined && revisedMeal.fat !== null ? revisedMeal.fat : meal.fat;

                // Save the revised meal to the correct location
                if (dayIndex !== null && mealIndex !== null) {
                    // Multi-day plan
                    currentPlan.days[dayIndex].plan[mealIndex] = revisedMeal;
                } else {
                    // Single-day plan
                    currentPlan.meals[index] = revisedMeal;
                }
                localStorage.setItem('currentMealPlan', JSON.stringify(currentPlan));

                // Save to database if viewing from database
                await savePlanToDatabase();

                // Refresh display
                displayMealPlan();

            } catch (error) {
                console.error('‚ùå Revision error:', error);
                alert('Failed to revise meal. Please try again.');
                displayMealPlan();
            }
        }

        // CUSTOM MEAL - Opens modal for custom meal creation
        function customMeal(index, dayIndex = null, mealIndex = null) {
            openCustomMealModal(index, dayIndex, mealIndex);
        }

        async function changeMeal(index, dayIndex = null, mealIndex = null) {
            // Get the meal based on plan structure
            let meal;
            let mealsPerDay = 1;
            let allMealNames = []; // Collect all meal names to avoid repetition

            if (dayIndex !== null && mealIndex !== null) {
                // Multi-day plan
                meal = currentPlan.days[dayIndex].plan[mealIndex];
                mealsPerDay = currentPlan.days[dayIndex].plan.length;
                // Collect ALL meal names from ALL days
                currentPlan.days.forEach(day => {
                    day.plan.forEach(m => {
                        if (m.name) allMealNames.push(m.name);
                    });
                });
            } else {
                // Single-day plan
                meal = currentPlan.meals[index];
                mealsPerDay = currentPlan.meals.length;
                // Collect all meal names
                currentPlan.meals.forEach(m => {
                    if (m.name) allMealNames.push(m.name);
                });
            }

            // Calculate per-meal targets based on MEAL TYPE (not equal distribution)
            // This ensures proper calorie distribution across the day
            const dailyNutrition = currentPlan.nutrition || {};
            const dailyCal = dailyNutrition.calories || 2000;
            const dailyProtein = dailyNutrition.protein || 150;
            const dailyCarbs = dailyNutrition.carbs || 200;
            const dailyFat = dailyNutrition.fat || 70;
            const mealType = meal.type?.toLowerCase() || 'meal';

            // Meal-type specific distribution percentages
            let calPercent = 0.25; // Default
            if (mealType === 'breakfast') calPercent = 0.27;
            else if (mealType === 'lunch') calPercent = 0.32;
            else if (mealType === 'dinner') calPercent = 0.28;
            else if (mealType === 'snack' || mealType === 'snack 1' || mealType === 'snack 2') calPercent = 0.13;

            const targetCalories = Math.round(dailyCal * calPercent);
            const targetProtein = Math.round(dailyProtein * calPercent);
            const targetCarbs = Math.round(dailyCarbs * calPercent);
            const targetFat = Math.round(dailyFat * calPercent);

            console.log(`üéØ Exchange targets for ${mealType} (${Math.round(calPercent * 100)}% of daily): ${targetCalories}cal, ${targetProtein}P, ${targetCarbs}C, ${targetFat}F`);
            console.log(`üö´ Meals to avoid (${allMealNames.length}):`, allMealNames);

            const mealCard = document.getElementById(`meal-${index}`);

            // Save current meal state for undo functionality
            const stateKey = dayIndex !== null ? `${dayIndex}-${mealIndex}` : `${index}`;
            previousMealStates[stateKey] = JSON.parse(JSON.stringify(meal)); // Deep copy
            console.log(`üíæ Saved previous state for undo (change):`, previousMealStates[stateKey]);
            saveUndoStates(); // Persist to localStorage

            mealCard.innerHTML = '<div class="spinner"></div><p style="text-align:center;">Generating new meal...</p>';

            try {
                // Build the "avoid these meals" list for variety
                const avoidMealsList = allMealNames.length > 0
                    ? `\n\nNEVER generate any of these meals (they're already in the plan):\n${allMealNames.map(n => `- ${n}`).join('\n')}\n`
                    : '';

                // NEW: Prompt asks for ingredients array - backend will calculate macros from USDA database
                const variationSeed = Math.floor(Math.random() * 1000000);
                const prompt = `Generate a DIFFERENT ${meal.type || 'meal'} (not "${meal.name}").
[Variation: ${variationSeed}] - Generate something UNIQUE and CREATIVE.
${avoidMealsList}
STRICT Target Nutrition - the new meal MUST closely match these values:
- Calories: ${targetCalories} (stay within ¬±50 calories)
- Protein: ${targetProtein}g (stay within ¬±5g)
- Carbs: ${targetCarbs}g (stay within ¬±10g)
- Fat: ${targetFat}g (stay within ¬±5g)

Diet: ${currentPlan.preferences?.dietType || 'any'}
${currentPlan.preferences?.allergies ? `Avoid: ${currentPlan.preferences.allergies}` : ''}

IMPORTANT: Be CREATIVE and suggest a UNIQUE meal. Try different cuisines (Mexican, Asian, Mediterranean, American, Indian) and cooking styles.

Use ONLY foods from USDA database including:
Proteins: Chicken Breast, Salmon, Ground Turkey, Eggs, Egg Whites, Shrimp, Tofu, Greek Yogurt, Tilapia, Cod, Tuna, Lean Beef, Pork Tenderloin
Carbs: Brown Rice, Quinoa, Sweet Potato, Oats, Whole Wheat Bread, Pasta, White Rice, Couscous, Black Beans, Chickpeas
Fats: Olive Oil, Avocado, Almonds, Peanut Butter, Walnuts, Cashews, Coconut Oil
Vegetables: Broccoli, Spinach, Bell Pepper, Asparagus, Zucchini, Mushrooms, Onions, Tomatoes, Carrots, Green Beans
Fruits: Blueberries, Strawberries, Banana, Apple, Mango, Pineapple, Orange

CRITICAL:
1. Return ingredients as ARRAY OF STRINGS with amounts in parentheses
2. DO NOT include calories/protein/carbs/fat values - the backend will calculate them
3. Choose portions that CLOSELY MATCH the target nutrition above - this is essential
4. If original meal was small (under 400 cal), keep new meal small. If large (over 600 cal), keep it large.

Return ONLY valid JSON (NO markdown, NO backticks):
{
  "type": "${meal.type || 'meal'}",
  "name": "Meal Name (with key portions)",
  "ingredients": ["Ingredient 1 (amount)", "Ingredient 2 (amount)"],
  "instructions": "Cooking instructions"
}`;

                // NEW: Send isJson and targets to trigger backend USDA calculation
                const response = await fetch(API_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt,
                        isJson: true,
                        targets: {
                            calories: targetCalories,
                            protein: targetProtein,
                            carbs: targetCarbs,
                            fat: targetFat
                        },
                        mealsPerDay: 1
                    })
                });

                if (!response.ok) throw new Error('API request failed');

                const data = await response.json();

                let newMeal;
                // Handle new backend format (with USDA calculation)
                if (data.success && data.data) {
                    console.log('‚úÖ Using new format with USDA calculation');
                    newMeal = data.data;

                    // Validate that backend calculated macros
                    if (!newMeal.calories || newMeal.calories === 0) {
                        console.warn('‚ö†Ô∏è Backend returned zero calories - ingredients may not have matched');
                    }
                } else {
                    // FALLBACK: Old Gemini format
                    console.log('‚ö†Ô∏è Using old Gemini format - macros may be inaccurate');
                    let text = data.candidates[0].content.parts[0].text;
                    text = text.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim();
                    text = text.replace(/:\s*NaN/g, ': null');

                    const jsonMatch = text.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        text = jsonMatch[0];
                    }

                    newMeal = JSON.parse(text);
                }

                // Ensure meal has required fields
                newMeal.type = newMeal.type || meal.type || 'meal';
                newMeal.name = newMeal.name || 'New Meal';
                newMeal.instructions = newMeal.instructions || '';

                // Use calculated macros - only fallback if truly undefined/null (not 0)
                if (newMeal.calories === 0 || newMeal.calories === undefined || newMeal.calories === null) {
                    console.warn('‚ö†Ô∏è Backend returned 0/missing calories - ingredient may not be in database');
                }
                newMeal.calories = newMeal.calories !== undefined && newMeal.calories !== null ? newMeal.calories : meal.calories;
                newMeal.protein = newMeal.protein !== undefined && newMeal.protein !== null ? newMeal.protein : meal.protein;
                newMeal.carbs = newMeal.carbs !== undefined && newMeal.carbs !== null ? newMeal.carbs : meal.carbs;
                newMeal.fat = newMeal.fat !== undefined && newMeal.fat !== null ? newMeal.fat : meal.fat;

                // Save the new meal to the correct location
                if (dayIndex !== null && mealIndex !== null) {
                    // Multi-day plan
                    currentPlan.days[dayIndex].plan[mealIndex] = newMeal;
                } else {
                    // Single-day plan
                    currentPlan.meals[index] = newMeal;
                }
                localStorage.setItem('currentMealPlan', JSON.stringify(currentPlan));

                // Save to database if viewing from database
                await savePlanToDatabase();

                displayMealPlan();

            } catch (error) {
                console.error('‚ùå Change meal error:', error);
                alert('Failed to change meal. Please try again.');
                displayMealPlan();
            }
        }

        // REGENERATE ENTIRE DAY - Generate all new meals for a specific day
        async function regenerateDay(dayIndex) {
            if (!currentPlan.multiDay || !currentPlan.days || !currentPlan.days[dayIndex]) {
                alert('Cannot regenerate: Invalid day index');
                return;
            }

            const dayData = currentPlan.days[dayIndex];
            const dayNumber = dayData.day;
            const numMeals = dayData.plan.length;
            const targets = dayData.targets || currentPlan.nutrition;

            // Get meal structure from original day
            const mealTypes = dayData.plan.map(m => m.type || 'meal');

            // Build list of meals from other days to avoid repetition
            let otherDaysMeals = [];
            currentPlan.days.forEach((d, idx) => {
                if (idx !== dayIndex && d.plan) {
                    d.plan.forEach(meal => {
                        otherDaysMeals.push(meal.name);
                    });
                }
            });
            const avoidMealsText = otherDaysMeals.length > 0
                ? `\nDO NOT repeat these meals from other days: ${otherDaysMeals.slice(0, 10).join(', ')}`
                : '';

            // Show loading state on all meal cards for this day
            const container = document.getElementById('mealsContainer');
            const dayHeaders = container.querySelectorAll('.day-header');
            if (dayHeaders[dayIndex]) {
                let currentElement = dayHeaders[dayIndex].nextElementSibling;
                // Skip the day totals div
                if (currentElement) currentElement = currentElement.nextElementSibling;

                while (currentElement && !currentElement.classList.contains('day-header')) {
                    if (currentElement.classList.contains('meal-card')) {
                        currentElement.innerHTML = '<div class="spinner"></div><p style="text-align:center;">Regenerating day...</p>';
                    }
                    currentElement = currentElement.nextElementSibling;
                }
            }

            try {
                // Generate all meals for the day in one request
                // NEW: Ask for ingredients arrays - backend will calculate macros from USDA database
                const dailyCal = targets.calories || 2000;
                const variationSeed = Math.floor(Math.random() * 1000000);
                const prompt = `Generate a COMPLETELY NEW ${numMeals}-meal plan for Day ${dayNumber}.
[Variation: ${variationSeed}] - Generate UNIQUE meals different from any previous generation.

Daily Nutrition Targets:
- Calories: ${dailyCal}
- Protein: ${targets.protein || 150}g
- Carbs: ${targets.carbs || 200}g
- Fat: ${targets.fat || 70}g

CRITICAL MEAL DISTRIBUTION - HARD LIMITS:
- BREAKFAST: ${Math.round(dailyCal * 0.25)}-${Math.round(dailyCal * 0.30)} calories (25-30% of daily)
- LUNCH: ${Math.round(dailyCal * 0.30)}-${Math.round(dailyCal * 0.35)} calories (30-35% of daily)
- DINNER: ${Math.round(dailyCal * 0.25)}-${Math.round(dailyCal * 0.30)} calories (25-30% of daily)
- SNACKS: ${Math.round(dailyCal * 0.10)}-${Math.round(dailyCal * 0.15)} calories each (10-15% of daily)
- ABSOLUTE MAXIMUM: No single meal can exceed ${Math.round(dailyCal * 0.40)} calories
- Violating these limits will cause errors

Required meal types (in order): ${mealTypes.join(', ')}

Diet: ${currentPlan.preferences?.dietType || 'any'}
${currentPlan.preferences?.allergies ? `Avoid: ${currentPlan.preferences.allergies}` : ''}${avoidMealsText}

CRITICAL: Return ingredients as ARRAY OF STRINGS with amounts in parentheses for EACH meal.
DO NOT include calories/protein/carbs/fat values - the backend will calculate them from the USDA database.
Use common foods with specific amounts like: "Chicken Breast (200g)", "Brown Rice (150g)", "Olive Oil (1 tbsp)"

Return ONLY a valid JSON array with ${numMeals} meal objects:
[
  {"type":"breakfast","name":"Meal Name (with portions)","ingredients":["Ingredient 1 (amount)","Ingredient 2 (amount)"],"instructions":"Cooking steps"},
  {"type":"lunch","name":"Another Meal (with portions)","ingredients":["Ingredient 1 (amount)","Ingredient 2 (amount)"],"instructions":"Steps"}
]

NO markdown, NO backticks, NO extra text. ONLY the JSON array.`;

                // NEW: Send isJson and targets to trigger backend USDA calculation
                const response = await fetch(API_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt,
                        isJson: true,
                        targets: {
                            calories: targets.calories || 2000,
                            protein: targets.protein || 150,
                            carbs: targets.carbs || 200,
                            fat: targets.fat || 70
                        },
                        mealsPerDay: numMeals
                    })
                });

                if (!response.ok) throw new Error('API request failed');

                const data = await response.json();

                let newMeals;
                // Handle new backend format (with Claude corrections)
                if (data.success && data.data) {
                    console.log('‚úÖ Using new format with Claude corrections');
                    newMeals = Array.isArray(data.data) ? data.data : [data.data];
                } else {
                    // FALLBACK: Old Gemini format
                    console.log('‚ö†Ô∏è Using old Gemini format');
                    let text = data.candidates[0].content.parts[0].text;
                    text = text.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim();
                    text = text.replace(/:\s*NaN/g, ': null');

                    // Extract JSON array
                    const jsonMatch = text.match(/\[[\s\S]*\]/);
                    if (jsonMatch) {
                        text = jsonMatch[0];
                    }
                    newMeals = JSON.parse(text);
                }

                // Validate and sanitize the meals
                if (!Array.isArray(newMeals) || newMeals.length === 0) {
                    throw new Error('Invalid response format');
                }

                // Sanitize and preserve all meal data including ingredients
                // Backend calculates macros from USDA database based on ingredients
                newMeals = newMeals.map((meal, i) => ({
                    type: meal.type || mealTypes[i] || 'meal',
                    name: meal.name || 'New Meal',
                    calories: parseInt(meal.calories) || Math.round(targets.calories / numMeals),
                    protein: parseInt(meal.protein) || Math.round(targets.protein / numMeals),
                    carbs: parseInt(meal.carbs) || Math.round(targets.carbs / numMeals),
                    fat: parseInt(meal.fat) || Math.round(targets.fat / numMeals),
                    ingredients: meal.ingredients || [],
                    instructions: meal.instructions || 'Follow recipe instructions.'
                }));

                // Update the day's meals
                currentPlan.days[dayIndex].plan = newMeals;
                localStorage.setItem('currentMealPlan', JSON.stringify(currentPlan));

                // Save to database if viewing from database
                await savePlanToDatabase();

                // Refresh the display
                displayMealPlan();

                console.log(`‚úÖ Day ${dayNumber} regenerated successfully`);

            } catch (error) {
                console.error('‚ùå Regenerate day error:', error);
                alert('Failed to regenerate day. Please try again.');
                displayMealPlan();
            }
        }

        // MEAL PREP GUIDE FUNCTIONS
        async function showMealPrepGuide() {
            const modal = document.getElementById('mealPrepModal');
            const content = document.getElementById('mealPrepContent');

            // Show modal with loading state
            modal.style.display = 'flex';
            content.innerHTML = `
                <div style="text-align: center; padding: 40px;">
                    <div class="loader" style="margin: 0 auto 20px; border: 4px solid #f3f3f3; border-top: 4px solid #0d9488; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite;"></div>
                    <p style="color: #666;">Generating your comprehensive meal prep guide...</p>
                </div>
            `;

            try {
                // Collect all meals from the plan (handle both single-day and multi-day)
                const allMeals = [];
                let numDays = 1;

                if (currentPlan.multiDay && currentPlan.days) {
                    // Multi-day plan: collect from all days
                    numDays = currentPlan.days.length;
                    currentPlan.days.forEach(dayData => {
                        if (dayData.plan && Array.isArray(dayData.plan)) {
                            dayData.plan.forEach(meal => {
                                allMeals.push({
                                    day: dayData.day,
                                    type: meal.type,
                                    name: meal.name,
                                    calories: meal.calories,
                                    protein: meal.protein,
                                    carbs: meal.carbs,
                                    fat: meal.fat
                                });
                            });
                        }
                    });
                } else if (currentPlan.meals && Array.isArray(currentPlan.meals)) {
                    // Single-day plan
                    currentPlan.meals.forEach(meal => {
                        allMeals.push({
                            type: meal.type,
                            name: meal.name,
                            calories: meal.calories,
                            protein: meal.protein,
                            carbs: meal.carbs,
                            fat: meal.fat
                        });
                    });
                }

                if (allMeals.length === 0) {
                    content.innerHTML = '<p style="text-align: center; color: #666;">No meal plan found.</p>';
                    return;
                }

                // Build meals list (include day number for multi-day plans)
                const mealsList = allMeals.map(m => {
                    if (m.day) {
                        return `Day ${m.day} ${m.type}: ${m.name}`;
                    }
                    return `${m.type}: ${m.name}`;
                }).join('\n');

                const prompt = `You are a professional meal prep consultant. Create a comprehensive meal prep guide for the following ${numDays}-day meal plan:

${mealsList}

Create a detailed, actionable meal prep guide with the following sections:

## üìù Shopping List
Group all ingredients by category (Proteins, Vegetables, Fruits, Grains/Carbs, Dairy, Pantry Items, etc.)
Combine quantities where meals share ingredients
Be specific with quantities and measurements

## ‚è∞ Meal Prep Timeline
Provide a prep schedule (e.g., "Sunday: Cook all proteins", "Monday: Prep vegetables")
Include which meals to batch cook together
Suggest which components can be prepared ahead
Include estimated time for each prep session

## ü•° Storage Instructions
For EACH meal, specify:
- How long it keeps in the refrigerator (be specific: 3-4 days, 5-6 days, etc.)
- Whether it can be frozen and for how long
- Best storage containers (airtight, glass, etc.)
- Any special storage notes

## üî• Reheating Instructions
For EACH meal type, provide:
- Microwave instructions (time and power level)
- Oven/stovetop instructions if better quality
- Tips to maintain texture and flavor

## üí° Time-Saving Tips
- Batch cooking strategies (cook all chicken at once, prep all vegetables together, etc.)
- Make-ahead components (cook rice/grains in bulk, pre-chop vegetables, etc.)
- Kitchen shortcuts and efficiency tips
- Which meals taste better fresh vs reheated

Format the response in clean, readable markdown with clear headings and bullet points.
Be specific, practical, and actionable. Focus on making meal prep as easy and efficient as possible.`;

                const response = await callGeminiAPI(prompt);

                // Format the response nicely
                content.innerHTML = `<div style="line-height: 1.6;">${formatMarkdown(response)}</div>`;

            } catch (error) {
                console.error('Error generating meal prep guide:', error);
                content.innerHTML = `
                    <div style="text-align: center; color: #f44336; padding: 40px;">
                        <p style="font-weight: bold;">Error generating meal prep guide</p>
                        <p style="font-size: 14px; margin-top: 10px;">${error.message}</p>
                    </div>
                `;
            }
        }

        function closeMealPrepModal() {
            document.getElementById('mealPrepModal').style.display = 'none';
        }

        // Simple markdown formatter
        function formatMarkdown(text) {
            if (!text || typeof text !== 'string') {
                console.error('formatMarkdown received invalid input:', text);
                throw new Error('Invalid response format from AI');
            }
            return text
                .replace(/^## (.+)$/gm, '<h2 style="font-size: 24px; font-weight: bold; margin: 30px 0 15px 0; color: #333;">$1</h2>')
                .replace(/^### (.+)$/gm, '<h3 style="font-size: 18px; font-weight: 600; margin: 20px 0 10px 0; color: #555;">$1</h3>')
                .replace(/^\* (.+)$/gm, '<li style="margin-left: 20px; margin-bottom: 8px;">$1</li>')
                .replace(/^- (.+)$/gm, '<li style="margin-left: 20px; margin-bottom: 8px;">$1</li>')
                .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                .replace(/\n\n/g, '</p><p style="margin: 12px 0;">')
                .replace(/^(?!<[hl]|<li)/gm, '<p style="margin: 12px 0;">')
                .replace(/<\/li>\n<li/g, '</li><li');
        }

        // API call to Gemini (reuse existing implementation if available, or add new one)
        async function callGeminiAPI(prompt) {
            const response = await fetch('/.netlify/functions/generate-meal-plan', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    prompt,
                    isJson: false // üÜï CRITICAL: This is a text-only request (markdown)
                })
            });

            if (!response.ok) {
                const errorText = await response.text();
                console.error('API Error:', errorText);
                throw new Error('Failed to generate meal prep guide');
            }

            const data = await response.json();
            console.log('API Response:', data);

            // NEW: Handle new backend format (with Claude corrections)
            if (data.success && data.data) {
                console.log('‚úÖ Using new format with Claude corrections');
                // Backend returns parsed data, convert to text if needed
                return typeof data.data === 'string' ? data.data : JSON.stringify(data.data);
            }

            // FALLBACK: Extract text from Gemini response structure
            if (data.candidates && data.candidates[0] && data.candidates[0].content) {
                console.log('‚ö†Ô∏è Using old Gemini format');
                const text = data.candidates[0].content.parts[0].text;
                if (!text) {
                    console.error('No text in response:', data);
                    throw new Error('Invalid response from AI service');
                }
                return text;
            }

            // Fallback: check for data.result (in case of different response format)
            if (data.result) {
                return data.result;
            }

            console.error('Unexpected response structure:', data);
            throw new Error('Invalid response from AI service');
        }

        async function downloadPDF() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();

            const margin = 15;
            const pageWidth = doc.internal.pageSize.getWidth();
            const maxWidth = pageWidth - (margin * 2);
            let y = 20;

            // Title
            doc.setFontSize(24);
            doc.setTextColor(102, 126, 234);
            doc.text('Personalized Meal Plan', margin, y);
            y += 10;

            // Client Name
            if (currentPlan.clientName) {
                doc.setFontSize(16);
                doc.setTextColor(0, 0, 0);
                doc.text(`For: ${currentPlan.clientName}`, margin, y);
                y += 12;
            }

            // Daily Nutrition Summary
            doc.setFontSize(14);
            doc.setTextColor(0, 0, 0);
            doc.text('Daily Nutrition Targets:', margin, y);
            y += 8;
            doc.setFontSize(11);
            const nutrition = currentPlan.nutrition;
            doc.text(`Calories: ${nutrition.calories} | Protein: ${nutrition.protein}g | Carbs: ${nutrition.carbs}g | Fat: ${nutrition.fat}g`, margin, y);
            y += 15;

            // Collect all meals (handles both single-day and multi-day plans)
            let allMeals = [];
            if (currentPlan.multiDay && currentPlan.days) {
                // Multi-day plan: collect meals from all days
                currentPlan.days.forEach(dayData => {
                    if (dayData.plan && Array.isArray(dayData.plan)) {
                        dayData.plan.forEach(meal => {
                            allMeals.push({ ...meal, dayNumber: dayData.day });
                        });
                    }
                });
            } else if (currentPlan.meals) {
                // Single-day plan
                allMeals = currentPlan.meals;
            }

            // Meals
            allMeals.forEach((meal, index) => {
                // Add day header for multi-day plans
                if (meal.dayNumber && (index === 0 || meal.dayNumber !== allMeals[index - 1].dayNumber)) {
                    if (y > 250) {
                        doc.addPage();
                        y = 20;
                    }
                    doc.setFontSize(16);
                    doc.setTextColor(102, 126, 234);
                    doc.text(`Day ${meal.dayNumber}`, margin, y);
                    y += 10;
                }
                if (y > 230) {
                    doc.addPage();
                    y = 20;
                }

                // Meal Name
                doc.setFontSize(14);
                doc.setTextColor(102, 126, 234);
                const mealNameLines = doc.splitTextToSize(meal.name, maxWidth);
                doc.text(mealNameLines, margin, y);
                y += mealNameLines.length * 6;

                // Macros
                doc.setFontSize(10);
                doc.setTextColor(100, 100, 100);
                doc.text(`${meal.calories} cal | ${meal.protein}g protein | ${meal.carbs}g carbs | ${meal.fat}g fat`, margin + 5, y);
                y += 7;

                // Ingredients (if available)
                if (meal.ingredients && Array.isArray(meal.ingredients) && meal.ingredients.length > 0) {
                    doc.setFontSize(11);
                    doc.setTextColor(0, 0, 0);
                    doc.setFont(undefined, 'bold');
                    doc.text('Ingredients:', margin + 5, y);
                    y += 5;
                    doc.setFont(undefined, 'normal');
                    doc.setFontSize(9);
                    meal.ingredients.forEach(ingredient => {
                        if (y > 270) {
                            doc.addPage();
                            y = 20;
                        }
                        const ingredientLines = doc.splitTextToSize(`‚Ä¢ ${ingredient}`, maxWidth - 10);
                        doc.text(ingredientLines, margin + 10, y);
                        y += ingredientLines.length * 4;
                    });
                    y += 3;
                }

                // Cooking Instructions
                if (meal.instructions) {
                    if (y > 260) {
                        doc.addPage();
                        y = 20;
                    }
                    doc.setFontSize(11);
                    doc.setFont(undefined, 'bold');
                    doc.text('Cooking Instructions:', margin + 5, y);
                    y += 5;
                    doc.setFont(undefined, 'normal');
                    doc.setFontSize(9);
                    const instructionLines = doc.splitTextToSize(meal.instructions, maxWidth - 10);
                    doc.text(instructionLines, margin + 10, y);
                    y += instructionLines.length * 4 + 8;
                }

                y += 5; // Space between meals
            });

            // Grocery List
            const groceryList = aggregateGroceryList();
            if (groceryList && groceryList.length > 0) {
                doc.addPage();
                y = 20;
                doc.setFontSize(20);
                doc.setTextColor(102, 126, 234);
                doc.text('Shopping List', margin, y);
                y += 12;

                doc.setFontSize(10);
                doc.setTextColor(0, 0, 0);
                groceryList.forEach(item => {
                    if (y > 270) {
                        doc.addPage();
                        y = 20;
                    }
                    const itemText = `- ${item.quantity.toFixed(1)} ${item.unit} ${item.name}`;
                    doc.text(itemText, margin, y);
                    y += 6;
                });
            }

            // Meal Prep Guide
            try {
                // Show loading indicator
                const loadingMsg = document.createElement('div');
                loadingMsg.id = 'pdf-loading';
                loadingMsg.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:white;padding:30px;border-radius:10px;box-shadow:0 4px 20px rgba(0,0,0,0.3);z-index:10001;text-align:center;';
                loadingMsg.innerHTML = '<div style="font-size:18px;font-weight:bold;margin-bottom:10px;">üìÑ Generating PDF...</div><div style="color:#666;">Adding meal prep guide</div>';
                document.body.appendChild(loadingMsg);

                // Generate meal prep guide
                const allMeals = [];
                let numDays = 1;

                if (currentPlan.multiDay && currentPlan.days) {
                    // Multi-day plan: collect from all days
                    numDays = currentPlan.days.length;
                    currentPlan.days.forEach(dayData => {
                        if (dayData.plan && Array.isArray(dayData.plan)) {
                            dayData.plan.forEach(meal => {
                                allMeals.push({
                                    day: dayData.day,
                                    type: meal.type,
                                    name: meal.name,
                                    calories: meal.calories,
                                    protein: meal.protein,
                                    carbs: meal.carbs,
                                    fat: meal.fat
                                });
                            });
                        }
                    });
                } else if (currentPlan.meals && Array.isArray(currentPlan.meals)) {
                    // Single-day plan
                    currentPlan.meals.forEach(meal => {
                        allMeals.push({
                            type: meal.type,
                            name: meal.name,
                            calories: meal.calories,
                            protein: meal.protein,
                            carbs: meal.carbs,
                            fat: meal.fat
                        });
                    });
                }

                // Build meals list (include day number for multi-day plans)
                const mealsList = allMeals.map(m => {
                    if (m.day) {
                        return `Day ${m.day} ${m.type}: ${m.name}`;
                    }
                    return `${m.type}: ${m.name}`;
                }).join('\n');

                const prompt = `You are a professional meal prep consultant. Create a comprehensive meal prep guide for the following ${numDays}-day meal plan:

${mealsList}

Create a detailed, actionable meal prep guide with the following sections:

## üìù Shopping List Tips
Provide tips for efficient shopping based on this meal plan (best stores, what to buy in bulk, what to buy fresh, etc.)

## ‚è∞ Meal Prep Timeline
Provide a day-by-day prep schedule (e.g., "Sunday: Cook all proteins", "Monday: Prep vegetables")
Include which meals to batch cook together
Suggest which components can be prepared ahead
Include estimated time for each prep session

## ü•° Storage Instructions
For EACH unique meal type, specify:
- How long it keeps in the refrigerator (be specific: 3-4 days, 5-6 days, etc.)
- Whether it can be frozen and for how long
- Best storage containers (airtight, glass, etc.)
- Any special storage notes

## üî• Reheating Instructions
For EACH unique meal type, provide:
- Microwave instructions (time and power level)
- Oven/stovetop instructions if better quality
- Tips to maintain texture and flavor

## üí° Time-Saving Tips
- Batch cooking strategies
- Make-ahead components
- Kitchen shortcuts and efficiency tips
- Which meals taste better fresh vs reheated

Format the response in clean, readable markdown with clear headings and bullet points.
Be specific, practical, and actionable. Keep it concise but comprehensive.`;

                const response = await callGeminiAPI(prompt);

                // Remove loading indicator
                document.body.removeChild(loadingMsg);

                // Add new page for meal prep guide
                doc.addPage();
                y = 20;

                // Title
                doc.setFontSize(20);
                doc.setTextColor(255, 107, 107);
                doc.text('Meal Prep Guide', margin, y);
                y += 12;

                // Parse and format the meal prep guide for PDF
                const lines = response.split('\n');
                doc.setTextColor(0, 0, 0);

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();

                    if (!line) {
                        y += 4; // Blank line spacing
                        continue;
                    }

                    // Check if we need a new page
                    if (y > 270) {
                        doc.addPage();
                        y = 20;
                    }

                    // Section headers (## )
                    if (line.startsWith('## ')) {
                        y += 5;
                        if (y > 265) {
                            doc.addPage();
                            y = 20;
                        }
                        const headerText = line.replace('## ', '').replace(/[üìù‚è∞ü•°üî•üí°]/g, '').trim();
                        doc.setFontSize(14);
                        doc.setFont(undefined, 'bold');
                        doc.setTextColor(102, 126, 234);
                        doc.text(headerText, margin, y);
                        y += 8;
                        doc.setFont(undefined, 'normal');
                        doc.setTextColor(0, 0, 0);
                        continue;
                    }

                    // Subsection headers (### )
                    if (line.startsWith('### ')) {
                        y += 3;
                        if (y > 268) {
                            doc.addPage();
                            y = 20;
                        }
                        const subheaderText = line.replace('### ', '');
                        doc.setFontSize(11);
                        doc.setFont(undefined, 'bold');
                        doc.text(subheaderText, margin + 5, y);
                        y += 6;
                        doc.setFont(undefined, 'normal');
                        continue;
                    }

                    // Bullet points
                    if (line.startsWith('* ') || line.startsWith('- ')) {
                        doc.setFontSize(9);
                        const bulletText = line.replace(/^[*-] /, '').replace(/\*\*/g, '');
                        const bulletLines = doc.splitTextToSize(`‚Ä¢ ${bulletText}`, maxWidth - 15);

                        bulletLines.forEach((bulletLine, idx) => {
                            if (y > 275) {
                                doc.addPage();
                                y = 20;
                            }
                            doc.text(bulletLine, margin + (idx === 0 ? 8 : 12), y);
                            y += 4;
                        });
                        continue;
                    }

                    // Regular paragraph text
                    doc.setFontSize(9);
                    const textLines = doc.splitTextToSize(line, maxWidth - 5);
                    textLines.forEach(textLine => {
                        if (y > 275) {
                            doc.addPage();
                            y = 20;
                        }
                        doc.text(textLine, margin + 5, y);
                        y += 4;
                    });
                }

            } catch (error) {
                console.error('Error generating meal prep guide for PDF:', error);
                // Continue with PDF generation without meal prep guide
                const loadingEl = document.getElementById('pdf-loading');
                if (loadingEl) document.body.removeChild(loadingEl);
            }

            // Footer
            y += 10;
            if (y > 260) {
                doc.addPage();
                y = 20;
            }
            doc.setFontSize(8);
            doc.setTextColor(150, 150, 150);
            doc.text(`Generated on ${new Date().toLocaleDateString()}`, margin, y);

            doc.save('meal-plan.pdf');
        }

        // Helper functions for grocery list aggregation
        function parseIngredient(ingredient) {
            const match = ingredient.match(/^([\d.\/]+)?\s*([a-zA-Z]+)?\s*(.+)$/);
            if (!match) return { quantity: 1, unit: 'unit', name: ingredient };

            const quantity = match[1] ? eval(match[1]) : 1;
            const unit = match[2] || 'unit';
            const name = match[3] || ingredient;

            return { quantity, unit: unit.toLowerCase(), name: name.trim() };
        }

        function normalizeUnit(quantity, unit) {
            const conversions = {
                'tbsp': { base: 'cup', factor: 1/16 },
                'tablespoon': { base: 'cup', factor: 1/16 },
                'tsp': { base: 'cup', factor: 1/48 },
                'teaspoon': { base: 'cup', factor: 1/48 },
                'oz': { base: 'lb', factor: 1/16 },
                'ounce': { base: 'lb', factor: 1/16 },
                'g': { base: 'kg', factor: 0.001 },
                'gram': { base: 'kg', factor: 0.001 },
                'ml': { base: 'l', factor: 0.001 },
                'milliliter': { base: 'l', factor: 0.001 }
            };

            if (conversions[unit]) {
                return {
                    quantity: quantity * conversions[unit].factor,
                    unit: conversions[unit].base
                };
            }

            return { quantity, unit };
        }

        function aggregateGroceryList() {
            if (!currentPlan) return [];

            const aggregated = {};
            let allMeals = [];

            // Handle both multi-day and single-day plans
            if (currentPlan.multiDay && currentPlan.days) {
                // Multi-day plan: collect meals from all days
                currentPlan.days.forEach(dayData => {
                    if (dayData.plan && Array.isArray(dayData.plan)) {
                        allMeals = allMeals.concat(dayData.plan);
                    }
                });
            } else if (currentPlan.meals && Array.isArray(currentPlan.meals)) {
                // Single-day plan
                allMeals = currentPlan.meals;
            }

            // Aggregate ingredients from all meals
            allMeals.forEach(meal => {
                if (!meal.ingredients || !Array.isArray(meal.ingredients)) return;

                meal.ingredients.forEach(ingredient => {
                    const parsed = parseIngredient(ingredient);
                    const normalized = normalizeUnit(parsed.quantity, parsed.unit);

                    const key = `${parsed.name}|${normalized.unit}`;
                    if (aggregated[key]) {
                        aggregated[key].quantity += normalized.quantity;
                    } else {
                        aggregated[key] = {
                            name: parsed.name,
                            quantity: normalized.quantity,
                            unit: normalized.unit
                        };
                    }
                });
            });

            return Object.values(aggregated).sort((a, b) => a.name.localeCompare(b.name));
        }

        // ========== FAVORITES FUNCTIONS ==========

        async function loadFavorites(clientId) {
            if (!clientId) return;

            try {
                const response = await fetch(`${TOGGLE_FAVORITE_ENDPOINT}?clientId=${clientId}`);
                if (response.ok) {
                    const data = await response.json();
                    clientFavorites = data.favorites || [];
                    console.log('Loaded favorites:', clientFavorites.length);
                }
            } catch (error) {
                console.error('Error loading favorites:', error);
            }
        }

        async function toggleFavorite(mealName, mealType, calories, protein, carbs, fat, index) {
            // Get client ID from current context
            let clientId = null;
            let coachId = null;

            // Check URL params for client view
            const urlParams = new URLSearchParams(window.location.search);
            const isClientView = urlParams.get('clientView') === 'true';

            if (isClientView) {
                // Get client ID from session
                const { data: { session } } = await supabaseClient.auth.getSession();
                if (session) {
                    const { data: clientData } = await supabaseClient
                        .from('clients')
                        .select('id, coach_id')
                        .eq('user_id', session.user.id)
                        .single();

                    if (clientData) {
                        clientId = clientData.id;
                        coachId = clientData.coach_id;
                    }
                }
            }

            if (!clientId) {
                alert('Could not determine client. Please log in again.');
                return;
            }

            const btn = document.getElementById(`fav-${index}`);
            const originalContent = btn.innerHTML;
            btn.innerHTML = '...';
            btn.disabled = true;

            try {
                const response = await fetch(TOGGLE_FAVORITE_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        clientId,
                        coachId,
                        mealName,
                        mealType,
                        calories,
                        protein,
                        carbs,
                        fat
                    })
                });

                if (!response.ok) throw new Error('Failed to toggle favorite');

                const data = await response.json();

                if (data.action === 'added') {
                    btn.innerHTML = '‚ù§Ô∏è';
                    btn.classList.add('active');
                    btn.title = 'Remove from favorites';
                    clientFavorites.push({ meal_name: mealName });
                } else {
                    btn.innerHTML = 'ü§ç';
                    btn.classList.remove('active');
                    btn.title = 'Add to favorites';
                    clientFavorites = clientFavorites.filter(f => f.meal_name !== mealName);
                }

            } catch (error) {
                console.error('Error toggling favorite:', error);
                btn.innerHTML = originalContent;
            }

            btn.disabled = false;
        }
    </script>
</body>
</html>
