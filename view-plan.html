<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Your Meal Plan - Zique Fitness</title>
    <!-- Prevent caching to avoid stale data on back navigation -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0d9488 0%, #0284c7 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        .header {
            text-align: center;
            margin-bottom: 40px;
        }

        .header h1 {
            color: #0d9488;
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .client-info {
            background: #f8f9ff;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 30px;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .info-item {
            padding: 15px;
            background: white;
            border-radius: 10px;
            border: 2px solid #e0e7ff;
        }

        .info-label {
            color: #0d9488;
            font-weight: 600;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .info-value {
            color: #333;
            font-size: 1.2em;
            font-weight: 700;
        }

        .meal-card {
            background: #f8f9ff;
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 25px;
            border: 2px solid #e0e7ff;
        }

        .meal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .meal-name {
            color: #0d9488;
            font-size: 1.8em;
            font-weight: 700;
        }

        .meal-actions {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9em;
        }

        .btn-change {
            background: #0d9488;
            color: white;
        }

        .btn-change:hover {
            background: #5568d3;
            transform: translateY(-2px);
        }

        .btn-revise {
            background: #0284c7;
            color: white;
        }

        .btn-revise:hover {
            background: #653a8a;
            transform: translateY(-2px);
        }

        .btn-favorite {
            background: transparent;
            color: #e53e3e;
            border: 2px solid #fed7d7;
            padding: 8px 14px;
            font-size: 1.1em;
        }

        .btn-favorite:hover {
            background: #fed7d7;
            transform: translateY(-2px);
        }

        .btn-favorite.active {
            background: #fed7d7;
            color: #c53030;
        }

        .macro-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .macro-item {
            background: white;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 2px solid #e0e7ff;
        }

        .macro-label {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .macro-value {
            color: #0d9488;
            font-size: 1.5em;
            font-weight: 700;
        }

        .instructions {
            background: #fff4e6;
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #ffa726;
            margin-top: 15px;
        }

        .instructions-label {
            color: #e65100;
            font-weight: 600;
            margin-bottom: 8px;
            display: block;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            margin-top: 40px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn-primary {
            background: linear-gradient(135deg, #0d9488 0%, #0284c7 100%);
            color: white;
            padding: 15px 40px;
            font-size: 1.1em;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
            padding: 15px 40px;
            font-size: 1.1em;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .revise-section {
            margin-top: 15px;
            padding: 15px;
            background: white;
            border-radius: 10px;
        }

        .revise-input {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #0d9488;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 10px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal-content {
            background: white;
            border-radius: 20px;
            padding: 40px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        }

        .modal-header {
            text-align: center;
            margin-bottom: 25px;
        }

        .modal-header h2 {
            color: #0d9488;
            font-size: 1.8em;
            margin-bottom: 10px;
        }

        .share-link-container {
            background: #f8f9ff;
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #e0e7ff;
            margin-bottom: 20px;
            word-break: break-all;
        }

        .share-link {
            color: #0d9488;
            font-weight: 600;
            font-size: 0.95em;
        }

        .btn-copy {
            background: #0d9488;
            color: white;
            width: 100%;
            padding: 15px;
            font-size: 1.1em;
        }

        .btn-copy:hover {
            background: #5568d3;
        }

        .btn-close-modal {
            background: #6c757d;
            color: white;
            width: 100%;
            padding: 15px;
            font-size: 1.1em;
            margin-top: 10px;
        }

        .btn-close-modal:hover {
            background: #5a6268;
        }

        .btn-share {
            background: #28a745;
            color: white;
            padding: 15px 40px;
            font-size: 1.1em;
        }

        .btn-share:hover {
            background: #218838;
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(40, 167, 69, 0.4);
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }

            .header h1 {
                font-size: 1.8em;
            }

            .macro-grid {
                grid-template-columns: repeat(2, 1fr);
            }

            .modal-content {
                padding: 25px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 id="planHeader">üî• Your Personalized Meal Plan</h1>
        </div>

        <div class="client-info">
            <div class="info-grid">
                <div class="info-item">
                    <div class="info-label">Daily Calories</div>
                    <div class="info-value" id="totalCalories">Loading...</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Protein</div>
                    <div class="info-value" id="totalProtein">Loading...</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Carbs</div>
                    <div class="info-value" id="totalCarbs">Loading...</div>
                </div>
                <div class="info-item">
                    <div class="info-label">Fat</div>
                    <div class="info-value" id="totalFat">Loading...</div>
                </div>
            </div>
        </div>

        <div id="mealsContainer"></div>

        <div class="action-buttons">
            <button class="btn btn-primary" onclick="showMealPrepGuide()" style="background:#ff6b6b;">üìã Meal Prep Guide</button>
            <button class="btn btn-primary" onclick="downloadPDF()">üì• Download PDF</button>
            <button id="sharePlanBtn" class="btn btn-share" onclick="generateShareLink()" style="display: none;">üîó Share Plan Link</button>
            <button id="generateNewBtn" class="btn btn-secondary" onclick="window.location.href='planner.html'" style="display: none;">‚Üê Generate New Plan</button>
        </div>
    </div>

    <!-- Meal Prep Guide Modal -->
    <div id="mealPrepModal" class="modal-overlay">
        <div class="modal-content" style="max-width: 900px; max-height: 85vh; overflow-y: auto;">
            <div class="modal-header">
                <h2>üìã Meal Prep Guide</h2>
                <button class="close-btn" onclick="closeMealPrepModal()">&times;</button>
            </div>
            <div id="mealPrepContent" style="padding: 20px;">
                <div style="text-align: center; padding: 40px;">
                    <div class="loader" style="margin: 0 auto 20px;"></div>
                    <p style="color: #666;">Generating your comprehensive meal prep guide...</p>
                </div>
            </div>
            <div style="padding: 20px; border-top: 1px solid #ddd; text-align: right;">
                <button class="btn btn-secondary" onclick="closeMealPrepModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Share Modal -->
    <div id="shareModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üîó Share Your Meal Plan</h2>
                <p style="color: #666;">Share this link with your client</p>
            </div>
            <div class="share-link-container">
                <div class="share-link" id="shareLinkText">Generating link...</div>
            </div>
            <button class="btn btn-copy" onclick="copyShareLink()">üìã Copy Link</button>
            <button class="btn btn-close-modal" onclick="closeShareModal()">Close</button>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
        // Initialize Supabase client
        const SUPABASE_URL = 'https://qewqcjzlfqamqwbccapr.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFld3FjanpsZnFhbXF3YmNjYXByIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM2OTg0NzAsImV4cCI6MjA3OTI3NDQ3MH0.mQnMC33O88oLkLLGWD2oG-oaSHGI-NfHmtQCZxnxSLs';

        const { createClient } = supabase;
        const supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        const API_ENDPOINT = '/.netlify/functions/generate-meal-plan';
        const SAVE_PLAN_ENDPOINT = '/.netlify/functions/save-shared-plan';
        const GET_PLAN_ENDPOINT = '/.netlify/functions/get-shared-plan';
        const TOGGLE_FAVORITE_ENDPOINT = '/.netlify/functions/toggle-favorite';
        let currentPlan = null;
        let clientFavorites = [];
        let currentShareUrl = '';
        let realtimeChannel = null;
        let currentPlanId = null;

        // Detect if page was loaded from back/forward cache and force reload
        window.addEventListener('pageshow', function(event) {
            if (event.persisted) {
                // Page was loaded from bfcache (back/forward cache)
                console.log('Page loaded from cache, forcing reload...');
                window.location.reload();
            }
        });

        // Load meal plan
        document.addEventListener('DOMContentLoaded', async function() {
            // Check URL parameters
            const urlParams = new URLSearchParams(window.location.search);
            const shareId = urlParams.get('share');
            const planId = urlParams.get('planId');
            const clientView = urlParams.get('clientView') === 'true';

            if (shareId) {
                // Load shared plan from database (client view)
                loadSharedPlan(shareId);
            } else if (planId) {
                // Load plan from database by ID (coach or client viewing)
                await loadCoachPlan(planId, clientView);
            } else {
                // Load from localStorage (newly generated plan)
                const planData = localStorage.getItem('currentMealPlan');

                if (!planData) {
                    alert('No meal plan found. Redirecting...');
                    window.location.href = 'planner.html';
                    return;
                }

                try {
                    currentPlan = JSON.parse(planData);
                    console.log('Loaded plan from localStorage:', currentPlan);

                    // Show coach-only buttons
                    document.getElementById('sharePlanBtn').style.display = 'inline-block';
                    document.getElementById('generateNewBtn').style.display = 'inline-block';

                    displayMealPlan();
                } catch (error) {
                    console.error('Error loading plan:', error);
                    alert('Error loading plan. Please generate a new one.');
                    window.location.href = 'planner.html';
                }
            }
        });

        // Load shared plan from database
        async function loadSharedPlan(shareId) {
            try {
                console.log('üì• Loading shared plan:', shareId);

                const response = await fetch(`${GET_PLAN_ENDPOINT}?shareId=${shareId}`);

                if (!response.ok) {
                    throw new Error('Failed to load shared plan');
                }

                const data = await response.json();
                currentPlan = data.planData;

                console.log('‚úÖ Loaded shared plan:', currentPlan);

                // Also save to localStorage for offline access
                localStorage.setItem('currentMealPlan', JSON.stringify(currentPlan));

                displayMealPlan();

                // Update header with client name
                const clientName = currentPlan.clientName || 'Client';
                const mealCount = currentPlan.meals ? currentPlan.meals.length : 0;
                const planText = mealCount > 1 ? 'Meal Plans' : 'Meal Plan';
                document.getElementById('planHeader').textContent = `üî• ${clientName}'s ${planText}`;

            } catch (error) {
                console.error('‚ùå Error loading shared plan:', error);
                alert('Failed to load shared plan. The link may be invalid or expired.');
                window.location.href = 'planner.html';
            }
        }

        // Load coach plan from database by ID
        async function loadCoachPlan(planId, isClientView = false) {
            try {
                console.log('Loading plan:', planId, 'Client view:', isClientView);

                // Clear any cached session data to force fresh fetch
                await supabaseClient.auth.refreshSession();

                // Check if user is logged in
                const { data: { session }, error: sessionError } = await supabaseClient.auth.getSession();

                if (sessionError || !session) {
                    alert('Please log in to view this plan.');
                    const redirectUrl = isClientView ? 'client-login.html' : 'index.html';
                    window.location.href = redirectUrl;
                    return;
                }

                const currentUser = session.user;
                let query = supabaseClient
                    .from('coach_meal_plans')
                    .select('*')
                    .eq('id', planId);

                if (isClientView) {
                    // For client view, verify the client owns this plan
                    const { data: clientData, error: clientError } = await supabaseClient
                        .from('clients')
                        .select('id')
                        .eq('user_id', currentUser.id)
                        .single();

                    if (clientError || !clientData) {
                        alert('Client account not found. Please contact your coach.');
                        window.location.href = 'client-login.html';
                        return;
                    }

                    // Load favorites for the client
                    await loadFavorites(clientData.id);

                    query = query.eq('client_id', clientData.id);
                } else {
                    // For coach view, verify the coach owns this plan
                    query = query.eq('coach_id', currentUser.id);
                }

                const { data, error } = await query.single();

                if (error) {
                    console.error('Supabase error:', error);
                    throw new Error('Failed to load plan');
                }

                if (!data) {
                    throw new Error('Plan not found');
                }

                console.log('Loaded plan:', data);
                currentPlanId = planId;

                // Extract and transform plan_data from the response
                const planData = data.plan_data;

                // FIXED: Store multi-day structure instead of flattening
                if (planData.currentPlan && Array.isArray(planData.currentPlan)) {
                    // Multi-day plan structure - keep it organized by day
                    currentPlan = {
                        planId: data.id, // Store the coach plan ID for linking shared plans
                        clientName: planData.clientName || data.client_name,
                        preferences: planData.preferences || {},
                        multiDay: true,
                        days: planData.currentPlan, // Store all days with structure
                        nutrition: {
                            calories: planData.calories,
                            protein: planData.protein,
                            carbs: planData.carbs,
                            fat: planData.fat
                        },
                        coachNotes: data.coach_notes || null
                    };
                } else {
                    // Fallback for old single-day format
                    currentPlan = {
                        planId: data.id, // Store the coach plan ID for linking shared plans
                        clientName: planData.clientName || data.client_name,
                        preferences: planData.preferences || {},
                        meals: planData.meals || [],
                        nutrition: planData.nutrition || {},
                        coachNotes: data.coach_notes || null
                    };
                }

                console.log('Transformed plan:', currentPlan);

                // Show coach-only buttons (only for coach view)
                if (!isClientView) {
                    document.getElementById('sharePlanBtn').style.display = 'inline-block';
                    document.getElementById('generateNewBtn').style.display = 'inline-block';
                }

                displayMealPlan();

                // Update header with client name
                const clientName = currentPlan.clientName || 'Client';
                const mealCount = currentPlan.meals ? currentPlan.meals.length : 0;
                const planText = mealCount > 1 ? 'Meal Plans' : 'Meal Plan';
                if (isClientView) {
                    document.getElementById('planHeader').textContent = `Your ${planText}`;
                } else {
                    document.getElementById('planHeader').textContent = `${clientName}'s ${planText}`;
                }

                // Set up real-time subscription for automatic updates
                setupRealtimeSubscription(planId, isClientView);

            } catch (error) {
                console.error('Error loading plan:', error);
                alert('Failed to load plan. Please try again.');
                const redirectUrl = isClientView ? 'client-dashboard.html' : 'past-plans.html';
                window.location.href = redirectUrl;
            }
        }

        function setupRealtimeSubscription(planId, isClientView) {
            // Clean up existing subscription if any
            if (realtimeChannel) {
                supabaseClient.removeChannel(realtimeChannel);
            }

            // Subscribe to changes for this specific plan
            realtimeChannel = supabaseClient
                .channel(`plan_${planId}`)
                .on(
                    'postgres_changes',
                    {
                        event: '*', // Listen to all events (INSERT, UPDATE, DELETE)
                        schema: 'public',
                        table: 'coach_meal_plans',
                        filter: `id=eq.${planId}`
                    },
                    (payload) => {
                        console.log('Real-time update received:', payload);
                        handlePlanUpdate(payload, isClientView);
                    }
                )
                .subscribe((status) => {
                    console.log('Realtime subscription status:', status);
                });
        }

        async function handlePlanUpdate(payload, isClientView) {
            const { eventType, new: newRecord } = payload;

            if (eventType === 'DELETE') {
                // Plan was deleted by coach
                console.log('Plan deleted');
                alert('This meal plan has been removed by your coach.');
                const redirectUrl = isClientView ? 'client-dashboard.html' : 'past-plans.html';
                window.location.href = redirectUrl;
            } else if (eventType === 'UPDATE') {
                // Plan was updated - reload and display
                console.log('Plan updated:', newRecord);

                const planData = newRecord.plan_data;

                // Update the currentPlan with new data
                if (planData.currentPlan && Array.isArray(planData.currentPlan)) {
                    currentPlan = {
                        planId: newRecord.id,
                        clientName: planData.clientName || newRecord.client_name,
                        preferences: planData.preferences || {},
                        multiDay: true,
                        days: planData.currentPlan,
                        nutrition: {
                            calories: planData.calories,
                            protein: planData.protein,
                            carbs: planData.carbs,
                            fat: planData.fat
                        }
                    };
                } else {
                    currentPlan = {
                        planId: newRecord.id,
                        clientName: planData.clientName || newRecord.client_name,
                        preferences: planData.preferences || {},
                        meals: planData.meals || [],
                        nutrition: planData.nutrition || {}
                    };
                }

                // Refresh the display with updated data
                displayMealPlan();

                console.log('Plan display refreshed with updated data');
            }
        }

        // Clean up subscription when page unloads
        window.addEventListener('beforeunload', function() {
            if (realtimeChannel) {
                supabaseClient.removeChannel(realtimeChannel);
            }
        });

        // Save current plan back to database if viewing from database
        async function savePlanToDatabase() {
            if (!currentPlanId) {
                console.log('‚è≠Ô∏è Skipping database save - no planId (viewing from localStorage)');
                return;
            }

            try {
                console.log('üíæ Saving plan changes to database...', currentPlanId);

                // Prepare the plan data in the format the database expects
                const planData = {
                    clientName: currentPlan.clientName,
                    preferences: currentPlan.preferences || {},
                    nutrition: currentPlan.nutrition
                };

                // Add the plan structure based on type
                if (currentPlan.multiDay && currentPlan.days) {
                    planData.currentPlan = currentPlan.days;
                    planData.calories = currentPlan.nutrition.calories;
                    planData.protein = currentPlan.nutrition.protein;
                    planData.carbs = currentPlan.nutrition.carbs;
                    planData.fat = currentPlan.nutrition.fat;
                } else if (currentPlan.meals) {
                    planData.meals = currentPlan.meals;
                }

                // Update the database record
                const { error } = await supabaseClient
                    .from('coach_meal_plans')
                    .update({ plan_data: planData })
                    .eq('id', currentPlanId);

                if (error) {
                    console.error('‚ùå Database save error:', error);
                    throw error;
                }

                console.log('‚úÖ Plan saved to database successfully');
            } catch (error) {
                console.error('‚ùå Failed to save plan to database:', error);
                alert('Warning: Changes saved locally but failed to sync to database. Your coach may not see your changes.');
            }
        }

        // Generate and save share link
        async function generateShareLink() {
            if (!currentPlan) {
                alert('No meal plan to share');
                return;
            }

            // Show modal with loading state
            const modal = document.getElementById('shareModal');
            const linkText = document.getElementById('shareLinkText');
            linkText.textContent = 'Generating share link...';
            modal.classList.add('show');

            try {
                console.log('üì§ Saving plan for sharing...');

                // Prepare request body
                const requestBody = { planData: currentPlan };

                // If this plan was loaded from database (has planId), include it
                // This links the shared plan to the coach plan for cascade deletion
                if (currentPlan.planId) {
                    requestBody.coachPlanId = currentPlan.planId;
                    console.log('Linking shared plan to coach plan:', currentPlan.planId);
                }

                const response = await fetch(SAVE_PLAN_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    throw new Error('Failed to generate share link');
                }

                const data = await response.json();
                currentShareUrl = data.shareUrl;

                console.log('‚úÖ Share link generated:', currentShareUrl);

                linkText.textContent = currentShareUrl;

            } catch (error) {
                console.error('‚ùå Error generating share link:', error);
                linkText.textContent = 'Failed to generate link. Please try again.';
                alert('Failed to generate share link. Please try again.');
            }
        }

        // Copy share link to clipboard
        async function copyShareLink() {
            if (!currentShareUrl) {
                alert('No share link available');
                return;
            }

            try {
                await navigator.clipboard.writeText(currentShareUrl);

                // Update button text temporarily
                const copyBtn = event.target;
                const originalText = copyBtn.textContent;
                copyBtn.textContent = '‚úÖ Copied!';
                copyBtn.style.background = '#28a745';

                setTimeout(() => {
                    copyBtn.textContent = originalText;
                    copyBtn.style.background = '';
                }, 2000);

            } catch (error) {
                console.error('‚ùå Copy error:', error);
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = currentShareUrl;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                alert('Link copied to clipboard!');
            }
        }

        // Close share modal
        function closeShareModal() {
            const modal = document.getElementById('shareModal');
            modal.classList.remove('show');
        }

        function displayMealPlan() {
            // FIXED: Handle both multi-day and single-day plans
            let nutrition = currentPlan.nutrition;

            if (!nutrition || !nutrition.calories) {
                console.warn('‚ö†Ô∏è Nutrition object missing or invalid, calculating...');
                nutrition = {
                    calories: 0,
                    protein: 0,
                    carbs: 0,
                    fat: 0
                };

                // Calculate based on plan type
                if (currentPlan.multiDay && currentPlan.days) {
                    // For multi-day, show DAILY targets (not total across all days)
                    if (currentPlan.days[0] && currentPlan.days[0].targets) {
                        nutrition = currentPlan.days[0].targets;
                    }
                } else if (currentPlan.meals) {
                    // For single-day, calculate totals
                    currentPlan.meals.forEach(meal => {
                        nutrition.calories += parseInt(meal.calories) || 0;
                        nutrition.protein += parseInt(meal.protein) || 0;
                        nutrition.carbs += parseInt(meal.carbs) || 0;
                        nutrition.fat += parseInt(meal.fat) || 0;
                    });
                }

                currentPlan.nutrition = nutrition;
                localStorage.setItem('currentMealPlan', JSON.stringify(currentPlan));
                console.log('‚úÖ Calculated nutrition:', nutrition);
            }

            // Display DAILY nutrition totals
            document.getElementById('totalCalories').textContent = nutrition.calories || 'N/A';
            document.getElementById('totalProtein').textContent = nutrition.protein ? nutrition.protein + 'g' : 'N/A';
            document.getElementById('totalCarbs').textContent = nutrition.carbs ? nutrition.carbs + 'g' : 'N/A';
            document.getElementById('totalFat').textContent = nutrition.fat ? nutrition.fat + 'g' : 'N/A';

            // Display coach notes if present
            const existingNotesSection = document.getElementById('coachNotesSection');
            if (existingNotesSection) {
                existingNotesSection.remove();
            }

            if (currentPlan.coachNotes) {
                const notesSection = document.createElement('div');
                notesSection.id = 'coachNotesSection';
                notesSection.style.cssText = 'background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%); padding: 20px; border-radius: 12px; margin-bottom: 20px; border: 1px solid #7dd3fc;';
                notesSection.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
                        <span style="font-size: 20px;">üìù</span>
                        <h3 style="margin: 0; color: #0369a1; font-size: 16px; font-weight: 600;">Message from Your Coach</h3>
                    </div>
                    <p style="margin: 0; color: #334155; font-size: 15px; line-height: 1.6; white-space: pre-wrap;">${currentPlan.coachNotes}</p>
                `;
                document.getElementById('mealsContainer').parentNode.insertBefore(notesSection, document.getElementById('mealsContainer'));
            }

            // Display meals - FIXED for multi-day plans
            const container = document.getElementById('mealsContainer');
            container.innerHTML = '';

            // Helper function to get color class based on variance
            const getVarianceColor = (variancePercent) => {
                const abs = Math.abs(variancePercent);
                if (abs <= 10) return '#16a34a'; // green - within ¬±10%
                if (abs <= 20) return '#ca8a04'; // yellow - within ¬±20%
                return '#dc2626'; // red - over ¬±20%
            };

            // Helper function to format variance display
            const formatVariance = (actual, target, variancePercent) => {
                const diff = actual - target;
                const sign = diff >= 0 ? '+' : '';
                return `${sign}${diff} (${sign}${variancePercent.toFixed(1)}%)`;
            };

            if (currentPlan.multiDay && currentPlan.days) {
                // Multi-day plan: show days with separators
                currentPlan.days.forEach((dayData, dayIndex) => {
                    // Calculate per-day actual totals
                    let dayTotals = { calories: 0, protein: 0, carbs: 0, fat: 0 };
                    if (dayData.plan && Array.isArray(dayData.plan)) {
                        dayData.plan.forEach(meal => {
                            dayTotals.calories += parseInt(meal.calories) || 0;
                            dayTotals.protein += parseInt(meal.protein) || 0;
                            dayTotals.carbs += parseInt(meal.carbs) || 0;
                            dayTotals.fat += parseInt(meal.fat) || 0;
                        });
                    }

                    // Get targets (use day targets if available, otherwise use plan nutrition)
                    const targets = dayData.targets || nutrition;

                    // Calculate per-day variance
                    const dayVariance = {
                        calories: targets.calories ? ((dayTotals.calories - targets.calories) / targets.calories * 100) : 0,
                        protein: targets.protein ? ((dayTotals.protein - targets.protein) / targets.protein * 100) : 0,
                        carbs: targets.carbs ? ((dayTotals.carbs - targets.carbs) / targets.carbs * 100) : 0,
                        fat: targets.fat ? ((dayTotals.fat - targets.fat) / targets.fat * 100) : 0
                    };

                    // Day header with regenerate button
                    const dayHeader = document.createElement('div');
                    dayHeader.className = 'day-header';
                    dayHeader.style.cssText = 'background: linear-gradient(135deg, #0d9488 0%, #0284c7 100%); color: white; padding: 15px 20px; border-radius: 12px; margin: 20px 0 15px 0; font-weight: 700; font-size: 1.3em; display: flex; justify-content: space-between; align-items: center;';

                    // Check if client view - hide regenerate button for clients
                    const urlParams = new URLSearchParams(window.location.search);
                    const isClientView = urlParams.get('clientView') === 'true';

                    dayHeader.innerHTML = `
                        <span>Day ${dayData.day}</span>
                        ${!isClientView ? `<button onclick="regenerateDay(${dayIndex})" class="btn" style="background: rgba(255,255,255,0.2); color: white; border: 1px solid rgba(255,255,255,0.3); padding: 8px 16px; font-size: 0.8em;">üîÑ Regenerate Day</button>` : ''}
                    `;
                    container.appendChild(dayHeader);

                    // Day totals section
                    const dayTotalsDiv = document.createElement('div');
                    dayTotalsDiv.style.cssText = 'background: #f8f9ff; padding: 15px; border-radius: 10px; margin-bottom: 15px; border: 1px solid #e0e7ff;';
                    dayTotalsDiv.innerHTML = `
                        <p style="font-size: 0.85em; font-weight: 600; color: #666; margin-bottom: 10px;">Day ${dayData.day} Totals:</p>
                        <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; text-align: center;">
                            <div>
                                <p style="font-size: 0.75em; color: #888;">Calories</p>
                                <span style="font-weight: 700; color: ${getVarianceColor(dayVariance.calories)}">${dayTotals.calories}</span>
                                <p style="font-size: 0.7em; color: ${getVarianceColor(dayVariance.calories)}">${formatVariance(dayTotals.calories, targets.calories, dayVariance.calories)}</p>
                            </div>
                            <div>
                                <p style="font-size: 0.75em; color: #888;">Protein</p>
                                <span style="font-weight: 700; color: ${getVarianceColor(dayVariance.protein)}">${dayTotals.protein}g</span>
                                <p style="font-size: 0.7em; color: ${getVarianceColor(dayVariance.protein)}">${formatVariance(dayTotals.protein, targets.protein, dayVariance.protein)}</p>
                            </div>
                            <div>
                                <p style="font-size: 0.75em; color: #888;">Carbs</p>
                                <span style="font-weight: 700; color: ${getVarianceColor(dayVariance.carbs)}">${dayTotals.carbs}g</span>
                                <p style="font-size: 0.7em; color: ${getVarianceColor(dayVariance.carbs)}">${formatVariance(dayTotals.carbs, targets.carbs, dayVariance.carbs)}</p>
                            </div>
                            <div>
                                <p style="font-size: 0.75em; color: #888;">Fat</p>
                                <span style="font-weight: 700; color: ${getVarianceColor(dayVariance.fat)}">${dayTotals.fat}g</span>
                                <p style="font-size: 0.7em; color: ${getVarianceColor(dayVariance.fat)}">${formatVariance(dayTotals.fat, targets.fat, dayVariance.fat)}</p>
                            </div>
                        </div>
                        <div style="margin-top: 8px; text-align: center; font-size: 0.7em; color: #888;">
                            <span style="color: #16a34a;">‚óè</span> Within ¬±10% |
                            <span style="color: #ca8a04;">‚óè</span> Within ¬±20% |
                            <span style="color: #dc2626;">‚óè</span> Over ¬±20%
                        </div>
                    `;
                    container.appendChild(dayTotalsDiv);

                    // Meals for this day
                    if (dayData.plan && Array.isArray(dayData.plan)) {
                        dayData.plan.forEach((meal, mealIndex) => {
                            const mealCard = createMealCard(meal, `${dayIndex}-${mealIndex}`, dayIndex, mealIndex);
                            container.appendChild(mealCard);
                        });
                    }
                });
            } else if (currentPlan.meals) {
                // Single-day plan: show meals directly
                currentPlan.meals.forEach((meal, index) => {
                    const mealCard = createMealCard(meal, index);
                    container.appendChild(mealCard);
                });
            }
        }

        function createMealCard(meal, index, dayIndex = null, mealIndex = null) {
            const card = document.createElement('div');
            card.className = 'meal-card';
            card.id = `meal-${index}`;

            // For multi-day plans, pass both indices; for single-day, pass just the index
            const changeParam = dayIndex !== null ? `'${index}', ${dayIndex}, ${mealIndex}` : index;
            const reviseParam = dayIndex !== null ? `'${index}', ${dayIndex}, ${mealIndex}` : index;

            // Check if meal is already favorited
            const isFavorited = clientFavorites.some(f => f.meal_name === meal.name);
            const favoriteClass = isFavorited ? 'active' : '';
            const favoriteIcon = isFavorited ? '‚ù§Ô∏è' : 'ü§ç';

            // Escape meal name for use in onclick
            const escapedMealName = meal.name.replace(/'/g, "\\'").replace(/"/g, '\\"');

            card.innerHTML = `
                <div class="meal-header">
                    <div class="meal-name">${meal.name}</div>
                    <div class="meal-actions">
                        <button class="btn btn-favorite ${favoriteClass}" id="fav-${index}" onclick="toggleFavorite('${escapedMealName}', '${meal.type || ''}', ${meal.calories}, ${meal.protein}, ${meal.carbs}, ${meal.fat}, '${index}')" title="${isFavorited ? 'Remove from favorites' : 'Add to favorites'}">${favoriteIcon}</button>
                        <button class="btn btn-change" onclick="changeMeal(${changeParam})">üîÑ Change</button>
                        <button class="btn btn-revise" onclick="toggleRevise(${reviseParam})">‚úèÔ∏è Revise</button>
                    </div>
                </div>
                <div class="macro-grid">
                    <div class="macro-item">
                        <div class="macro-label">Calories</div>
                        <div class="macro-value">${meal.calories}</div>
                    </div>
                    <div class="macro-item">
                        <div class="macro-label">Protein</div>
                        <div class="macro-value">${meal.protein}g</div>
                    </div>
                    <div class="macro-item">
                        <div class="macro-label">Carbs</div>
                        <div class="macro-value">${meal.carbs}g</div>
                    </div>
                    <div class="macro-item">
                        <div class="macro-label">Fat</div>
                        <div class="macro-value">${meal.fat}g</div>
                    </div>
                </div>
                <div class="instructions">
                    <span class="instructions-label">üìù Instructions:</span>
                    ${meal.instructions}
                </div>
                <div id="revise-${index}" class="revise-section" style="display:none;">
                    <input type="text" id="revise-input-${index}" class="revise-input" placeholder="What would you like to change? e.g., make it vegetarian">
                    <button class="btn btn-revise" onclick="submitRevision(${changeParam})">Apply Changes</button>
                </div>
            `;
            return card;
        }

        function toggleRevise(index, dayIndex = null, mealIndex = null) {
            const reviseSection = document.getElementById(`revise-${index}`);
            if (reviseSection.style.display === 'none') {
                reviseSection.style.display = 'block';
            } else {
                reviseSection.style.display = 'none';
            }
        }

        async function submitRevision(index, dayIndex = null, mealIndex = null) {
            const input = document.getElementById(`revise-input-${index}`);
            const revisionText = input.value.trim();

            if (!revisionText) {
                alert('Please enter what you want to change');
                return;
            }

            // Get the meal based on plan structure
            let meal;
            if (dayIndex !== null && mealIndex !== null) {
                // Multi-day plan
                meal = currentPlan.days[dayIndex].plan[mealIndex];
            } else {
                // Single-day plan
                meal = currentPlan.meals[index];
            }
            const mealCard = document.getElementById(`meal-${index}`);

            // Show loading
            mealCard.innerHTML = '<div class="spinner"></div><p style="text-align:center;">Revising meal...</p>';

            try {
                // NEW: Prompt asks for ingredients array - backend will calculate macros from USDA database
                const prompt = `Revise this meal based on user request:

CURRENT MEAL:
Name: ${meal.name}
Type: ${meal.type || 'meal'}
Instructions: ${meal.instructions || 'N/A'}

USER REQUEST: ${revisionText}

Diet: ${currentPlan.preferences?.dietType || 'any'}
${currentPlan.preferences?.allergies ? `Avoid: ${currentPlan.preferences.allergies}` : ''}

Use ONLY foods from USDA database including:
Proteins: Chicken Breast, Salmon, Ground Turkey, Eggs, Egg Whites, Shrimp, Tofu, Greek Yogurt
Carbs: Brown Rice, Quinoa, Sweet Potato, Oats, Whole Wheat Bread, Pasta
Fats: Olive Oil, Avocado, Almonds, Peanut Butter
Vegetables: Broccoli, Spinach, Bell Pepper, Asparagus, etc.
Fruits: Blueberries, Strawberries, Banana, Apple

CRITICAL: Return ingredients as ARRAY OF STRINGS with amounts in parentheses.
DO NOT include calories/protein/carbs/fat values - the backend will calculate them from the database.
MEAL NAME FORMAT: Include key ingredient portions inline.

Return ONLY valid JSON (NO markdown, NO backticks):
{
  "type": "${meal.type || 'meal'}",
  "name": "Updated Meal Name (with portions)",
  "ingredients": ["Ingredient 1 (amount)", "Ingredient 2 (amount)"],
  "instructions": "Cooking instructions"
}`;

                // NEW: Send isJson and targets to trigger backend USDA calculation
                const response = await fetch(API_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt,
                        isJson: true,
                        targets: {
                            calories: meal.calories || 500,
                            protein: meal.protein || 30,
                            carbs: meal.carbs || 50,
                            fat: meal.fat || 15
                        },
                        mealsPerDay: 1
                    })
                });

                if (!response.ok) throw new Error('API request failed');

                const data = await response.json();

                let revisedMeal;
                // Handle new backend format (with USDA calculation)
                if (data.success && data.data) {
                    console.log('‚úÖ Using new format with USDA calculation');
                    revisedMeal = data.data;

                    // Validate that backend calculated macros
                    if (!revisedMeal.calories || revisedMeal.calories === 0) {
                        console.warn('‚ö†Ô∏è Backend returned zero calories - ingredients may not have matched');
                    }
                } else {
                    // FALLBACK: Old Gemini format (shouldn't happen with new code)
                    console.log('‚ö†Ô∏è Using old Gemini format - macros may be inaccurate');
                    let text = data.candidates[0].content.parts[0].text;
                    text = text.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim();
                    text = text.replace(/:\s*NaN/g, ': null');

                    const jsonMatch = text.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        text = jsonMatch[0];
                    }

                    revisedMeal = JSON.parse(text);
                }

                // Ensure meal has required fields
                revisedMeal.type = revisedMeal.type || meal.type || 'meal';
                revisedMeal.name = revisedMeal.name || 'Revised Meal';
                revisedMeal.instructions = revisedMeal.instructions || meal.instructions || '';

                // Use calculated macros, or fallback to original if calculation failed
                revisedMeal.calories = revisedMeal.calories || meal.calories;
                revisedMeal.protein = revisedMeal.protein || meal.protein;
                revisedMeal.carbs = revisedMeal.carbs || meal.carbs;
                revisedMeal.fat = revisedMeal.fat || meal.fat;

                // Save the revised meal to the correct location
                if (dayIndex !== null && mealIndex !== null) {
                    // Multi-day plan
                    currentPlan.days[dayIndex].plan[mealIndex] = revisedMeal;
                } else {
                    // Single-day plan
                    currentPlan.meals[index] = revisedMeal;
                }
                localStorage.setItem('currentMealPlan', JSON.stringify(currentPlan));

                // Save to database if viewing from database
                await savePlanToDatabase();

                // Refresh display
                displayMealPlan();

            } catch (error) {
                console.error('‚ùå Revision error:', error);
                alert('Failed to revise meal. Please try again.');
                displayMealPlan();
            }
        }

        async function changeMeal(index, dayIndex = null, mealIndex = null) {
            // Get the meal based on plan structure
            let meal;
            if (dayIndex !== null && mealIndex !== null) {
                // Multi-day plan
                meal = currentPlan.days[dayIndex].plan[mealIndex];
            } else {
                // Single-day plan
                meal = currentPlan.meals[index];
            }

            const mealCard = document.getElementById(`meal-${index}`);

            mealCard.innerHTML = '<div class="spinner"></div><p style="text-align:center;">Generating new meal...</p>';

            try {
                // NEW: Prompt asks for ingredients array - backend will calculate macros from USDA database
                const prompt = `Generate a DIFFERENT ${meal.type || 'meal'} (not "${meal.name}"):

Target Nutrition (approximate):
- Calories: ${meal.calories}
- Protein: ${meal.protein}g
- Carbs: ${meal.carbs}g
- Fat: ${meal.fat}g

Diet: ${currentPlan.preferences?.dietType || 'any'}
${currentPlan.preferences?.allergies ? `Avoid: ${currentPlan.preferences.allergies}` : ''}

Use ONLY foods from USDA database including:
Proteins: Chicken Breast, Salmon, Ground Turkey, Eggs, Egg Whites, Shrimp, Tofu, Greek Yogurt
Carbs: Brown Rice, Quinoa, Sweet Potato, Oats, Whole Wheat Bread, Pasta
Fats: Olive Oil, Avocado, Almonds, Peanut Butter
Vegetables: Broccoli, Spinach, Bell Pepper, Asparagus, etc.
Fruits: Blueberries, Strawberries, Banana, Apple

CRITICAL: Return ingredients as ARRAY OF STRINGS with amounts in parentheses.
DO NOT include calories/protein/carbs/fat values - the backend will calculate them from the database.
Choose portions that will approximately match the target nutrition.

Return ONLY valid JSON (NO markdown, NO backticks):
{
  "type": "${meal.type || 'meal'}",
  "name": "Meal Name (with key portions)",
  "ingredients": ["Ingredient 1 (amount)", "Ingredient 2 (amount)"],
  "instructions": "Cooking instructions"
}`;

                // NEW: Send isJson and targets to trigger backend USDA calculation
                const response = await fetch(API_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt,
                        isJson: true,
                        targets: {
                            calories: meal.calories || 500,
                            protein: meal.protein || 30,
                            carbs: meal.carbs || 50,
                            fat: meal.fat || 15
                        },
                        mealsPerDay: 1
                    })
                });

                if (!response.ok) throw new Error('API request failed');

                const data = await response.json();

                let newMeal;
                // Handle new backend format (with USDA calculation)
                if (data.success && data.data) {
                    console.log('‚úÖ Using new format with USDA calculation');
                    newMeal = data.data;

                    // Validate that backend calculated macros
                    if (!newMeal.calories || newMeal.calories === 0) {
                        console.warn('‚ö†Ô∏è Backend returned zero calories - ingredients may not have matched');
                    }
                } else {
                    // FALLBACK: Old Gemini format
                    console.log('‚ö†Ô∏è Using old Gemini format - macros may be inaccurate');
                    let text = data.candidates[0].content.parts[0].text;
                    text = text.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim();
                    text = text.replace(/:\s*NaN/g, ': null');

                    const jsonMatch = text.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        text = jsonMatch[0];
                    }

                    newMeal = JSON.parse(text);
                }

                // Ensure meal has required fields
                newMeal.type = newMeal.type || meal.type || 'meal';
                newMeal.name = newMeal.name || 'New Meal';
                newMeal.instructions = newMeal.instructions || '';

                // Use calculated macros, or fallback to original if calculation failed
                newMeal.calories = newMeal.calories || meal.calories;
                newMeal.protein = newMeal.protein || meal.protein;
                newMeal.carbs = newMeal.carbs || meal.carbs;
                newMeal.fat = newMeal.fat || meal.fat;

                // Save the new meal to the correct location
                if (dayIndex !== null && mealIndex !== null) {
                    // Multi-day plan
                    currentPlan.days[dayIndex].plan[mealIndex] = newMeal;
                } else {
                    // Single-day plan
                    currentPlan.meals[index] = newMeal;
                }
                localStorage.setItem('currentMealPlan', JSON.stringify(currentPlan));

                // Save to database if viewing from database
                await savePlanToDatabase();

                displayMealPlan();

            } catch (error) {
                console.error('‚ùå Change meal error:', error);
                alert('Failed to change meal. Please try again.');
                displayMealPlan();
            }
        }

        // REGENERATE ENTIRE DAY - Generate all new meals for a specific day
        async function regenerateDay(dayIndex) {
            if (!currentPlan.multiDay || !currentPlan.days || !currentPlan.days[dayIndex]) {
                alert('Cannot regenerate: Invalid day index');
                return;
            }

            const dayData = currentPlan.days[dayIndex];
            const dayNumber = dayData.day;
            const numMeals = dayData.plan.length;
            const targets = dayData.targets || currentPlan.nutrition;

            // Get meal structure from original day
            const mealTypes = dayData.plan.map(m => m.type || 'meal');

            // Build list of meals from other days to avoid repetition
            let otherDaysMeals = [];
            currentPlan.days.forEach((d, idx) => {
                if (idx !== dayIndex && d.plan) {
                    d.plan.forEach(meal => {
                        otherDaysMeals.push(meal.name);
                    });
                }
            });
            const avoidMealsText = otherDaysMeals.length > 0
                ? `\nDO NOT repeat these meals from other days: ${otherDaysMeals.slice(0, 10).join(', ')}`
                : '';

            // Show loading state on all meal cards for this day
            const container = document.getElementById('mealsContainer');
            const dayHeaders = container.querySelectorAll('.day-header');
            if (dayHeaders[dayIndex]) {
                let currentElement = dayHeaders[dayIndex].nextElementSibling;
                // Skip the day totals div
                if (currentElement) currentElement = currentElement.nextElementSibling;

                while (currentElement && !currentElement.classList.contains('day-header')) {
                    if (currentElement.classList.contains('meal-card')) {
                        currentElement.innerHTML = '<div class="spinner"></div><p style="text-align:center;">Regenerating day...</p>';
                    }
                    currentElement = currentElement.nextElementSibling;
                }
            }

            try {
                // Generate all meals for the day in one request
                // NEW: Ask for ingredients arrays - backend will calculate macros from USDA database
                const prompt = `Generate a COMPLETELY NEW ${numMeals}-meal plan for Day ${dayNumber}.

Daily Nutrition Targets:
- Calories: ${targets.calories || 2000}
- Protein: ${targets.protein || 150}g
- Carbs: ${targets.carbs || 200}g
- Fat: ${targets.fat || 70}g

Required meal types (in order): ${mealTypes.join(', ')}

Diet: ${currentPlan.preferences?.dietType || 'any'}
${currentPlan.preferences?.allergies ? `Avoid: ${currentPlan.preferences.allergies}` : ''}${avoidMealsText}

CRITICAL: Return ingredients as ARRAY OF STRINGS with amounts in parentheses for EACH meal.
DO NOT include calories/protein/carbs/fat values - the backend will calculate them from the USDA database.
Use common foods with specific amounts like: "Chicken Breast (200g)", "Brown Rice (150g)", "Olive Oil (1 tbsp)"

Return ONLY a valid JSON array with ${numMeals} meal objects:
[
  {"type":"breakfast","name":"Meal Name (with portions)","ingredients":["Ingredient 1 (amount)","Ingredient 2 (amount)"],"instructions":"Cooking steps"},
  {"type":"lunch","name":"Another Meal (with portions)","ingredients":["Ingredient 1 (amount)","Ingredient 2 (amount)"],"instructions":"Steps"}
]

NO markdown, NO backticks, NO extra text. ONLY the JSON array.`;

                // NEW: Send isJson and targets to trigger backend USDA calculation
                const response = await fetch(API_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        prompt,
                        isJson: true,
                        targets: {
                            calories: targets.calories || 2000,
                            protein: targets.protein || 150,
                            carbs: targets.carbs || 200,
                            fat: targets.fat || 70
                        },
                        mealsPerDay: numMeals
                    })
                });

                if (!response.ok) throw new Error('API request failed');

                const data = await response.json();

                let newMeals;
                // Handle new backend format (with Claude corrections)
                if (data.success && data.data) {
                    console.log('‚úÖ Using new format with Claude corrections');
                    newMeals = Array.isArray(data.data) ? data.data : [data.data];
                } else {
                    // FALLBACK: Old Gemini format
                    console.log('‚ö†Ô∏è Using old Gemini format');
                    let text = data.candidates[0].content.parts[0].text;
                    text = text.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim();
                    text = text.replace(/:\s*NaN/g, ': null');

                    // Extract JSON array
                    const jsonMatch = text.match(/\[[\s\S]*\]/);
                    if (jsonMatch) {
                        text = jsonMatch[0];
                    }
                    newMeals = JSON.parse(text);
                }

                // Validate and sanitize the meals
                if (!Array.isArray(newMeals) || newMeals.length === 0) {
                    throw new Error('Invalid response format');
                }

                // Sanitize and preserve all meal data including ingredients
                // Backend calculates macros from USDA database based on ingredients
                newMeals = newMeals.map((meal, i) => ({
                    type: meal.type || mealTypes[i] || 'meal',
                    name: meal.name || 'New Meal',
                    calories: parseInt(meal.calories) || Math.round(targets.calories / numMeals),
                    protein: parseInt(meal.protein) || Math.round(targets.protein / numMeals),
                    carbs: parseInt(meal.carbs) || Math.round(targets.carbs / numMeals),
                    fat: parseInt(meal.fat) || Math.round(targets.fat / numMeals),
                    ingredients: meal.ingredients || [],
                    instructions: meal.instructions || 'Follow recipe instructions.'
                }));

                // Update the day's meals
                currentPlan.days[dayIndex].plan = newMeals;
                localStorage.setItem('currentMealPlan', JSON.stringify(currentPlan));

                // Save to database if viewing from database
                await savePlanToDatabase();

                // Refresh the display
                displayMealPlan();

                console.log(`‚úÖ Day ${dayNumber} regenerated successfully`);

            } catch (error) {
                console.error('‚ùå Regenerate day error:', error);
                alert('Failed to regenerate day. Please try again.');
                displayMealPlan();
            }
        }

        // MEAL PREP GUIDE FUNCTIONS
        async function showMealPrepGuide() {
            const modal = document.getElementById('mealPrepModal');
            const content = document.getElementById('mealPrepContent');

            // Show modal with loading state
            modal.style.display = 'flex';
            content.innerHTML = `
                <div style="text-align: center; padding: 40px;">
                    <div class="loader" style="margin: 0 auto 20px; border: 4px solid #f3f3f3; border-top: 4px solid #0d9488; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite;"></div>
                    <p style="color: #666;">Generating your comprehensive meal prep guide...</p>
                </div>
            `;

            try {
                // Collect all meals from the plan (handle both single-day and multi-day)
                const allMeals = [];
                let numDays = 1;

                if (currentPlan.multiDay && currentPlan.days) {
                    // Multi-day plan: collect from all days
                    numDays = currentPlan.days.length;
                    currentPlan.days.forEach(dayData => {
                        if (dayData.plan && Array.isArray(dayData.plan)) {
                            dayData.plan.forEach(meal => {
                                allMeals.push({
                                    day: dayData.day,
                                    type: meal.type,
                                    name: meal.name,
                                    calories: meal.calories,
                                    protein: meal.protein,
                                    carbs: meal.carbs,
                                    fat: meal.fat
                                });
                            });
                        }
                    });
                } else if (currentPlan.meals && Array.isArray(currentPlan.meals)) {
                    // Single-day plan
                    currentPlan.meals.forEach(meal => {
                        allMeals.push({
                            type: meal.type,
                            name: meal.name,
                            calories: meal.calories,
                            protein: meal.protein,
                            carbs: meal.carbs,
                            fat: meal.fat
                        });
                    });
                }

                if (allMeals.length === 0) {
                    content.innerHTML = '<p style="text-align: center; color: #666;">No meal plan found.</p>';
                    return;
                }

                // Build meals list (include day number for multi-day plans)
                const mealsList = allMeals.map(m => {
                    if (m.day) {
                        return `Day ${m.day} ${m.type}: ${m.name}`;
                    }
                    return `${m.type}: ${m.name}`;
                }).join('\n');

                const prompt = `You are a professional meal prep consultant. Create a comprehensive meal prep guide for the following ${numDays}-day meal plan:

${mealsList}

Create a detailed, actionable meal prep guide with the following sections:

## üìù Shopping List
Group all ingredients by category (Proteins, Vegetables, Fruits, Grains/Carbs, Dairy, Pantry Items, etc.)
Combine quantities where meals share ingredients
Be specific with quantities and measurements

## ‚è∞ Meal Prep Timeline
Provide a prep schedule (e.g., "Sunday: Cook all proteins", "Monday: Prep vegetables")
Include which meals to batch cook together
Suggest which components can be prepared ahead
Include estimated time for each prep session

## ü•° Storage Instructions
For EACH meal, specify:
- How long it keeps in the refrigerator (be specific: 3-4 days, 5-6 days, etc.)
- Whether it can be frozen and for how long
- Best storage containers (airtight, glass, etc.)
- Any special storage notes

## üî• Reheating Instructions
For EACH meal type, provide:
- Microwave instructions (time and power level)
- Oven/stovetop instructions if better quality
- Tips to maintain texture and flavor

## üí° Time-Saving Tips
- Batch cooking strategies (cook all chicken at once, prep all vegetables together, etc.)
- Make-ahead components (cook rice/grains in bulk, pre-chop vegetables, etc.)
- Kitchen shortcuts and efficiency tips
- Which meals taste better fresh vs reheated

Format the response in clean, readable markdown with clear headings and bullet points.
Be specific, practical, and actionable. Focus on making meal prep as easy and efficient as possible.`;

                const response = await callGeminiAPI(prompt);

                // Format the response nicely
                content.innerHTML = `<div style="line-height: 1.6;">${formatMarkdown(response)}</div>`;

            } catch (error) {
                console.error('Error generating meal prep guide:', error);
                content.innerHTML = `
                    <div style="text-align: center; color: #f44336; padding: 40px;">
                        <p style="font-weight: bold;">Error generating meal prep guide</p>
                        <p style="font-size: 14px; margin-top: 10px;">${error.message}</p>
                    </div>
                `;
            }
        }

        function closeMealPrepModal() {
            document.getElementById('mealPrepModal').style.display = 'none';
        }

        // Simple markdown formatter
        function formatMarkdown(text) {
            if (!text || typeof text !== 'string') {
                console.error('formatMarkdown received invalid input:', text);
                throw new Error('Invalid response format from AI');
            }
            return text
                .replace(/^## (.+)$/gm, '<h2 style="font-size: 24px; font-weight: bold; margin: 30px 0 15px 0; color: #333;">$1</h2>')
                .replace(/^### (.+)$/gm, '<h3 style="font-size: 18px; font-weight: 600; margin: 20px 0 10px 0; color: #555;">$1</h3>')
                .replace(/^\* (.+)$/gm, '<li style="margin-left: 20px; margin-bottom: 8px;">$1</li>')
                .replace(/^- (.+)$/gm, '<li style="margin-left: 20px; margin-bottom: 8px;">$1</li>')
                .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                .replace(/\n\n/g, '</p><p style="margin: 12px 0;">')
                .replace(/^(?!<[hl]|<li)/gm, '<p style="margin: 12px 0;">')
                .replace(/<\/li>\n<li/g, '</li><li');
        }

        // API call to Gemini (reuse existing implementation if available, or add new one)
        async function callGeminiAPI(prompt) {
            const response = await fetch('/.netlify/functions/generate-meal-plan', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    prompt,
                    isJson: false // üÜï CRITICAL: This is a text-only request (markdown)
                })
            });

            if (!response.ok) {
                const errorText = await response.text();
                console.error('API Error:', errorText);
                throw new Error('Failed to generate meal prep guide');
            }

            const data = await response.json();
            console.log('API Response:', data);

            // NEW: Handle new backend format (with Claude corrections)
            if (data.success && data.data) {
                console.log('‚úÖ Using new format with Claude corrections');
                // Backend returns parsed data, convert to text if needed
                return typeof data.data === 'string' ? data.data : JSON.stringify(data.data);
            }

            // FALLBACK: Extract text from Gemini response structure
            if (data.candidates && data.candidates[0] && data.candidates[0].content) {
                console.log('‚ö†Ô∏è Using old Gemini format');
                const text = data.candidates[0].content.parts[0].text;
                if (!text) {
                    console.error('No text in response:', data);
                    throw new Error('Invalid response from AI service');
                }
                return text;
            }

            // Fallback: check for data.result (in case of different response format)
            if (data.result) {
                return data.result;
            }

            console.error('Unexpected response structure:', data);
            throw new Error('Invalid response from AI service');
        }

        async function downloadPDF() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();

            const margin = 15;
            const pageWidth = doc.internal.pageSize.getWidth();
            const maxWidth = pageWidth - (margin * 2);
            let y = 20;

            // Title
            doc.setFontSize(24);
            doc.setTextColor(102, 126, 234);
            doc.text('Personalized Meal Plan', margin, y);
            y += 10;

            // Client Name
            if (currentPlan.clientName) {
                doc.setFontSize(16);
                doc.setTextColor(0, 0, 0);
                doc.text(`For: ${currentPlan.clientName}`, margin, y);
                y += 12;
            }

            // Daily Nutrition Summary
            doc.setFontSize(14);
            doc.setTextColor(0, 0, 0);
            doc.text('Daily Nutrition Targets:', margin, y);
            y += 8;
            doc.setFontSize(11);
            const nutrition = currentPlan.nutrition;
            doc.text(`Calories: ${nutrition.calories} | Protein: ${nutrition.protein}g | Carbs: ${nutrition.carbs}g | Fat: ${nutrition.fat}g`, margin, y);
            y += 15;

            // Collect all meals (handles both single-day and multi-day plans)
            let allMeals = [];
            if (currentPlan.multiDay && currentPlan.days) {
                // Multi-day plan: collect meals from all days
                currentPlan.days.forEach(dayData => {
                    if (dayData.plan && Array.isArray(dayData.plan)) {
                        dayData.plan.forEach(meal => {
                            allMeals.push({ ...meal, dayNumber: dayData.day });
                        });
                    }
                });
            } else if (currentPlan.meals) {
                // Single-day plan
                allMeals = currentPlan.meals;
            }

            // Meals
            allMeals.forEach((meal, index) => {
                // Add day header for multi-day plans
                if (meal.dayNumber && (index === 0 || meal.dayNumber !== allMeals[index - 1].dayNumber)) {
                    if (y > 250) {
                        doc.addPage();
                        y = 20;
                    }
                    doc.setFontSize(16);
                    doc.setTextColor(102, 126, 234);
                    doc.text(`Day ${meal.dayNumber}`, margin, y);
                    y += 10;
                }
                if (y > 230) {
                    doc.addPage();
                    y = 20;
                }

                // Meal Name
                doc.setFontSize(14);
                doc.setTextColor(102, 126, 234);
                const mealNameLines = doc.splitTextToSize(meal.name, maxWidth);
                doc.text(mealNameLines, margin, y);
                y += mealNameLines.length * 6;

                // Macros
                doc.setFontSize(10);
                doc.setTextColor(100, 100, 100);
                doc.text(`${meal.calories} cal | ${meal.protein}g protein | ${meal.carbs}g carbs | ${meal.fat}g fat`, margin + 5, y);
                y += 7;

                // Ingredients (if available)
                if (meal.ingredients && Array.isArray(meal.ingredients) && meal.ingredients.length > 0) {
                    doc.setFontSize(11);
                    doc.setTextColor(0, 0, 0);
                    doc.setFont(undefined, 'bold');
                    doc.text('Ingredients:', margin + 5, y);
                    y += 5;
                    doc.setFont(undefined, 'normal');
                    doc.setFontSize(9);
                    meal.ingredients.forEach(ingredient => {
                        if (y > 270) {
                            doc.addPage();
                            y = 20;
                        }
                        const ingredientLines = doc.splitTextToSize(`‚Ä¢ ${ingredient}`, maxWidth - 10);
                        doc.text(ingredientLines, margin + 10, y);
                        y += ingredientLines.length * 4;
                    });
                    y += 3;
                }

                // Cooking Instructions
                if (meal.instructions) {
                    if (y > 260) {
                        doc.addPage();
                        y = 20;
                    }
                    doc.setFontSize(11);
                    doc.setFont(undefined, 'bold');
                    doc.text('Cooking Instructions:', margin + 5, y);
                    y += 5;
                    doc.setFont(undefined, 'normal');
                    doc.setFontSize(9);
                    const instructionLines = doc.splitTextToSize(meal.instructions, maxWidth - 10);
                    doc.text(instructionLines, margin + 10, y);
                    y += instructionLines.length * 4 + 8;
                }

                y += 5; // Space between meals
            });

            // Grocery List
            const groceryList = aggregateGroceryList();
            if (groceryList && groceryList.length > 0) {
                doc.addPage();
                y = 20;
                doc.setFontSize(20);
                doc.setTextColor(102, 126, 234);
                doc.text('Shopping List', margin, y);
                y += 12;

                doc.setFontSize(10);
                doc.setTextColor(0, 0, 0);
                groceryList.forEach(item => {
                    if (y > 270) {
                        doc.addPage();
                        y = 20;
                    }
                    const itemText = `- ${item.quantity.toFixed(1)} ${item.unit} ${item.name}`;
                    doc.text(itemText, margin, y);
                    y += 6;
                });
            }

            // Meal Prep Guide
            try {
                // Show loading indicator
                const loadingMsg = document.createElement('div');
                loadingMsg.id = 'pdf-loading';
                loadingMsg.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:white;padding:30px;border-radius:10px;box-shadow:0 4px 20px rgba(0,0,0,0.3);z-index:10001;text-align:center;';
                loadingMsg.innerHTML = '<div style="font-size:18px;font-weight:bold;margin-bottom:10px;">üìÑ Generating PDF...</div><div style="color:#666;">Adding meal prep guide</div>';
                document.body.appendChild(loadingMsg);

                // Generate meal prep guide
                const allMeals = [];
                let numDays = 1;

                if (currentPlan.multiDay && currentPlan.days) {
                    // Multi-day plan: collect from all days
                    numDays = currentPlan.days.length;
                    currentPlan.days.forEach(dayData => {
                        if (dayData.plan && Array.isArray(dayData.plan)) {
                            dayData.plan.forEach(meal => {
                                allMeals.push({
                                    day: dayData.day,
                                    type: meal.type,
                                    name: meal.name,
                                    calories: meal.calories,
                                    protein: meal.protein,
                                    carbs: meal.carbs,
                                    fat: meal.fat
                                });
                            });
                        }
                    });
                } else if (currentPlan.meals && Array.isArray(currentPlan.meals)) {
                    // Single-day plan
                    currentPlan.meals.forEach(meal => {
                        allMeals.push({
                            type: meal.type,
                            name: meal.name,
                            calories: meal.calories,
                            protein: meal.protein,
                            carbs: meal.carbs,
                            fat: meal.fat
                        });
                    });
                }

                // Build meals list (include day number for multi-day plans)
                const mealsList = allMeals.map(m => {
                    if (m.day) {
                        return `Day ${m.day} ${m.type}: ${m.name}`;
                    }
                    return `${m.type}: ${m.name}`;
                }).join('\n');

                const prompt = `You are a professional meal prep consultant. Create a comprehensive meal prep guide for the following ${numDays}-day meal plan:

${mealsList}

Create a detailed, actionable meal prep guide with the following sections:

## üìù Shopping List Tips
Provide tips for efficient shopping based on this meal plan (best stores, what to buy in bulk, what to buy fresh, etc.)

## ‚è∞ Meal Prep Timeline
Provide a day-by-day prep schedule (e.g., "Sunday: Cook all proteins", "Monday: Prep vegetables")
Include which meals to batch cook together
Suggest which components can be prepared ahead
Include estimated time for each prep session

## ü•° Storage Instructions
For EACH unique meal type, specify:
- How long it keeps in the refrigerator (be specific: 3-4 days, 5-6 days, etc.)
- Whether it can be frozen and for how long
- Best storage containers (airtight, glass, etc.)
- Any special storage notes

## üî• Reheating Instructions
For EACH unique meal type, provide:
- Microwave instructions (time and power level)
- Oven/stovetop instructions if better quality
- Tips to maintain texture and flavor

## üí° Time-Saving Tips
- Batch cooking strategies
- Make-ahead components
- Kitchen shortcuts and efficiency tips
- Which meals taste better fresh vs reheated

Format the response in clean, readable markdown with clear headings and bullet points.
Be specific, practical, and actionable. Keep it concise but comprehensive.`;

                const response = await callGeminiAPI(prompt);

                // Remove loading indicator
                document.body.removeChild(loadingMsg);

                // Add new page for meal prep guide
                doc.addPage();
                y = 20;

                // Title
                doc.setFontSize(20);
                doc.setTextColor(255, 107, 107);
                doc.text('Meal Prep Guide', margin, y);
                y += 12;

                // Parse and format the meal prep guide for PDF
                const lines = response.split('\n');
                doc.setTextColor(0, 0, 0);

                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();

                    if (!line) {
                        y += 4; // Blank line spacing
                        continue;
                    }

                    // Check if we need a new page
                    if (y > 270) {
                        doc.addPage();
                        y = 20;
                    }

                    // Section headers (## )
                    if (line.startsWith('## ')) {
                        y += 5;
                        if (y > 265) {
                            doc.addPage();
                            y = 20;
                        }
                        const headerText = line.replace('## ', '').replace(/[üìù‚è∞ü•°üî•üí°]/g, '').trim();
                        doc.setFontSize(14);
                        doc.setFont(undefined, 'bold');
                        doc.setTextColor(102, 126, 234);
                        doc.text(headerText, margin, y);
                        y += 8;
                        doc.setFont(undefined, 'normal');
                        doc.setTextColor(0, 0, 0);
                        continue;
                    }

                    // Subsection headers (### )
                    if (line.startsWith('### ')) {
                        y += 3;
                        if (y > 268) {
                            doc.addPage();
                            y = 20;
                        }
                        const subheaderText = line.replace('### ', '');
                        doc.setFontSize(11);
                        doc.setFont(undefined, 'bold');
                        doc.text(subheaderText, margin + 5, y);
                        y += 6;
                        doc.setFont(undefined, 'normal');
                        continue;
                    }

                    // Bullet points
                    if (line.startsWith('* ') || line.startsWith('- ')) {
                        doc.setFontSize(9);
                        const bulletText = line.replace(/^[*-] /, '').replace(/\*\*/g, '');
                        const bulletLines = doc.splitTextToSize(`‚Ä¢ ${bulletText}`, maxWidth - 15);

                        bulletLines.forEach((bulletLine, idx) => {
                            if (y > 275) {
                                doc.addPage();
                                y = 20;
                            }
                            doc.text(bulletLine, margin + (idx === 0 ? 8 : 12), y);
                            y += 4;
                        });
                        continue;
                    }

                    // Regular paragraph text
                    doc.setFontSize(9);
                    const textLines = doc.splitTextToSize(line, maxWidth - 5);
                    textLines.forEach(textLine => {
                        if (y > 275) {
                            doc.addPage();
                            y = 20;
                        }
                        doc.text(textLine, margin + 5, y);
                        y += 4;
                    });
                }

            } catch (error) {
                console.error('Error generating meal prep guide for PDF:', error);
                // Continue with PDF generation without meal prep guide
                const loadingEl = document.getElementById('pdf-loading');
                if (loadingEl) document.body.removeChild(loadingEl);
            }

            // Footer
            y += 10;
            if (y > 260) {
                doc.addPage();
                y = 20;
            }
            doc.setFontSize(8);
            doc.setTextColor(150, 150, 150);
            doc.text(`Generated on ${new Date().toLocaleDateString()}`, margin, y);

            doc.save('meal-plan.pdf');
        }

        // Helper functions for grocery list aggregation
        function parseIngredient(ingredient) {
            const match = ingredient.match(/^([\d.\/]+)?\s*([a-zA-Z]+)?\s*(.+)$/);
            if (!match) return { quantity: 1, unit: 'unit', name: ingredient };

            const quantity = match[1] ? eval(match[1]) : 1;
            const unit = match[2] || 'unit';
            const name = match[3] || ingredient;

            return { quantity, unit: unit.toLowerCase(), name: name.trim() };
        }

        function normalizeUnit(quantity, unit) {
            const conversions = {
                'tbsp': { base: 'cup', factor: 1/16 },
                'tablespoon': { base: 'cup', factor: 1/16 },
                'tsp': { base: 'cup', factor: 1/48 },
                'teaspoon': { base: 'cup', factor: 1/48 },
                'oz': { base: 'lb', factor: 1/16 },
                'ounce': { base: 'lb', factor: 1/16 },
                'g': { base: 'kg', factor: 0.001 },
                'gram': { base: 'kg', factor: 0.001 },
                'ml': { base: 'l', factor: 0.001 },
                'milliliter': { base: 'l', factor: 0.001 }
            };

            if (conversions[unit]) {
                return {
                    quantity: quantity * conversions[unit].factor,
                    unit: conversions[unit].base
                };
            }

            return { quantity, unit };
        }

        function aggregateGroceryList() {
            if (!currentPlan) return [];

            const aggregated = {};
            let allMeals = [];

            // Handle both multi-day and single-day plans
            if (currentPlan.multiDay && currentPlan.days) {
                // Multi-day plan: collect meals from all days
                currentPlan.days.forEach(dayData => {
                    if (dayData.plan && Array.isArray(dayData.plan)) {
                        allMeals = allMeals.concat(dayData.plan);
                    }
                });
            } else if (currentPlan.meals && Array.isArray(currentPlan.meals)) {
                // Single-day plan
                allMeals = currentPlan.meals;
            }

            // Aggregate ingredients from all meals
            allMeals.forEach(meal => {
                if (!meal.ingredients || !Array.isArray(meal.ingredients)) return;

                meal.ingredients.forEach(ingredient => {
                    const parsed = parseIngredient(ingredient);
                    const normalized = normalizeUnit(parsed.quantity, parsed.unit);

                    const key = `${parsed.name}|${normalized.unit}`;
                    if (aggregated[key]) {
                        aggregated[key].quantity += normalized.quantity;
                    } else {
                        aggregated[key] = {
                            name: parsed.name,
                            quantity: normalized.quantity,
                            unit: normalized.unit
                        };
                    }
                });
            });

            return Object.values(aggregated).sort((a, b) => a.name.localeCompare(b.name));
        }

        // ========== FAVORITES FUNCTIONS ==========

        async function loadFavorites(clientId) {
            if (!clientId) return;

            try {
                const response = await fetch(`${TOGGLE_FAVORITE_ENDPOINT}?clientId=${clientId}`);
                if (response.ok) {
                    const data = await response.json();
                    clientFavorites = data.favorites || [];
                    console.log('Loaded favorites:', clientFavorites.length);
                }
            } catch (error) {
                console.error('Error loading favorites:', error);
            }
        }

        async function toggleFavorite(mealName, mealType, calories, protein, carbs, fat, index) {
            // Get client ID from current context
            let clientId = null;
            let coachId = null;

            // Check URL params for client view
            const urlParams = new URLSearchParams(window.location.search);
            const isClientView = urlParams.get('clientView') === 'true';

            if (isClientView) {
                // Get client ID from session
                const { data: { session } } = await supabaseClient.auth.getSession();
                if (session) {
                    const { data: clientData } = await supabaseClient
                        .from('clients')
                        .select('id, coach_id')
                        .eq('user_id', session.user.id)
                        .single();

                    if (clientData) {
                        clientId = clientData.id;
                        coachId = clientData.coach_id;
                    }
                }
            }

            if (!clientId) {
                alert('Could not determine client. Please log in again.');
                return;
            }

            const btn = document.getElementById(`fav-${index}`);
            const originalContent = btn.innerHTML;
            btn.innerHTML = '...';
            btn.disabled = true;

            try {
                const response = await fetch(TOGGLE_FAVORITE_ENDPOINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        clientId,
                        coachId,
                        mealName,
                        mealType,
                        calories,
                        protein,
                        carbs,
                        fat
                    })
                });

                if (!response.ok) throw new Error('Failed to toggle favorite');

                const data = await response.json();

                if (data.action === 'added') {
                    btn.innerHTML = '‚ù§Ô∏è';
                    btn.classList.add('active');
                    btn.title = 'Remove from favorites';
                    clientFavorites.push({ meal_name: mealName });
                } else {
                    btn.innerHTML = 'ü§ç';
                    btn.classList.remove('active');
                    btn.title = 'Add to favorites';
                    clientFavorites = clientFavorites.filter(f => f.meal_name !== mealName);
                }

            } catch (error) {
                console.error('Error toggling favorite:', error);
                btn.innerHTML = originalContent;
            }

            btn.disabled = false;
        }
    </script>
</body>
</html>
