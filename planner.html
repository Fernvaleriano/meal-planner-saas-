<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Meal Planner - Zique Fitness Nutrition</title>
    <!-- Prevent caching to avoid stale data on back navigation -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        * {
            -webkit-overflow-scrolling: touch !important;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #0d9488 0%, #0284c7 100%);
            min-height: 100vh;
            overflow-y: auto !important;
        }

        .app-container {
            max-width: 1200px;
            margin: 1rem auto;
            padding: 0.5rem;
        }

        .card {
            background-color: white;
            border-radius: 1rem;
            padding: 2rem;
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1);
            margin-bottom: 1rem;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background-color: #0d9488;
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background-color: #5568d3;
        }

        .btn-secondary {
            background-color: #E3E9F5;
            color: #0d9488;
        }

        .btn-secondary:hover:not(:disabled) {
            background-color: #D3DBF0;
        }

        .btn-custom {
            background: #7c3aed;
            color: white;
        }

        .btn-custom:hover:not(:disabled) {
            background: #6d28d9;
        }

        .hidden {
            display: none;
        }

        .input-field {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
            margin-top: 0.5rem;
        }

        .radio-label, .checkbox-label {
            display: flex;
            align-items: center;
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        input[type="radio"]:checked + .radio-label,
        input[type="checkbox"]:checked + .checkbox-label {
            background-color: #E3E9F5;
            border-color: #0d9488;
        }

        .loader {
            width: 80px;
            height: 80px;
            margin: 2rem auto;
            position: relative;
        }

        .loader-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #0d9488;
            border-radius: 50%;
            animation: spin 2s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .meal-card {
            border: 1px solid #e5e7eb;
            padding: 1.5rem;
            border-radius: 0.75rem;
            margin-bottom: 1rem;
        }

        .day-divider {
            background: linear-gradient(135deg, #0d9488 0%, #0284c7 100%);
            color: white;
            padding: 1rem;
            border-radius: 0.75rem;
            margin: 2rem 0 1rem 0;
            font-weight: 700;
            font-size: 1.25rem;
            text-align: center;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }

        .prose h3 { margin-bottom: 0.5em; }
        .prose ul { list-style-type: disc; padding-left: 1.5em; }
        .prose ol { list-style-type: decimal; padding-left: 1.5em; }

        /* Custom Meal Modal Styles */
        .custom-meal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .custom-meal-overlay.show {
            display: flex;
        }

        .custom-meal-modal {
            background: white;
            border-radius: 20px;
            padding: 30px;
            max-width: 450px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            box-sizing: border-box;
            overflow: hidden;
            max-height: 90vh;
            overflow-y: auto;
        }

        .custom-meal-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .custom-meal-header h2 {
            color: #0d9488;
            font-size: 1.5em;
            margin-bottom: 5px;
        }

        .custom-meal-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .custom-meal-tab {
            flex: 1;
            padding: 15px 10px;
            border: 2px solid #e0e7ff;
            border-radius: 12px;
            background: white;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }

        .custom-meal-tab:hover {
            border-color: #0d9488;
        }

        .custom-meal-tab.active {
            background: linear-gradient(135deg, #0d9488 0%, #0891b2 100%);
            border-color: transparent;
            color: white;
        }

        .custom-meal-tab-icon {
            display: block;
            font-size: 1.5em;
            margin-bottom: 5px;
        }

        .custom-meal-tab-label {
            font-size: 0.85em;
            font-weight: 600;
        }

        .custom-meal-panel {
            display: none;
        }

        .custom-meal-panel.active {
            display: block;
        }

        .custom-meal-hint {
            background: #f0fdf4;
            border: 1px solid #86efac;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
            font-size: 0.9em;
            color: #166534;
        }

        .custom-meal-input {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e0e7ff;
            border-radius: 10px;
            font-size: 1em;
            margin-bottom: 15px;
            box-sizing: border-box;
        }

        .custom-meal-input:focus {
            outline: none;
            border-color: #0d9488;
        }

        .food-search-container {
            position: relative;
            margin-bottom: 15px;
        }

        .food-search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #e0e7ff;
            border-top: none;
            border-radius: 0 0 10px 10px;
            max-height: 250px;
            overflow-y: auto;
            z-index: 100;
            display: none;
        }

        .food-search-results.active {
            display: block;
        }

        .food-search-item {
            padding: 10px 12px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
        }

        .food-search-item:hover {
            background: #f0fdf4;
        }

        .food-search-item:last-child {
            border-bottom: none;
        }

        .food-name {
            font-weight: 600;
            color: #333;
            margin-bottom: 2px;
        }

        .food-macros {
            font-size: 0.8em;
            color: #666;
        }

        .food-search-loading, .food-search-empty {
            padding: 15px;
            text-align: center;
            color: #888;
        }

        .selected-ingredients {
            margin-bottom: 15px;
        }

        .selected-ingredients-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #e0e7ff;
            margin-bottom: 10px;
            font-weight: 600;
            color: #333;
        }

        .ingredients-list {
            max-height: 150px;
            overflow-y: auto;
        }

        .ingredient-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: #f8fafc;
            border-radius: 8px;
            margin-bottom: 6px;
        }

        .ingredient-name {
            flex: 1;
            font-size: 0.9em;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .ingredient-qty {
            width: 60px;
            padding: 4px 8px;
            border: 1px solid #e0e7ff;
            border-radius: 6px;
            text-align: center;
            font-size: 0.9em;
        }

        .ingredient-unit {
            font-size: 0.85em;
            color: #666;
        }

        .ingredient-remove {
            background: #fee2e2;
            border: none;
            color: #dc2626;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            font-weight: bold;
        }

        .no-ingredients {
            text-align: center;
            color: #888;
            padding: 15px;
            font-style: italic;
        }

        .calculated-totals {
            background: linear-gradient(135deg, #ecfdf5 0%, #d1fae5 100%);
            border: 2px solid #10b981;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .totals-header {
            font-weight: 700;
            color: #065f46;
            margin-bottom: 10px;
            font-size: 0.9em;
        }

        .totals-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            text-align: center;
        }

        .total-item {
            background: white;
            padding: 8px;
            border-radius: 8px;
        }

        .total-value {
            font-weight: 700;
            color: #0d9488;
            font-size: 1.1em;
        }

        .total-label {
            font-size: 0.75em;
            color: #666;
        }

        .macro-inputs-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .macro-input-group label {
            display: block;
            font-size: 0.85em;
            color: #666;
            margin-bottom: 5px;
            font-weight: 600;
        }

        .macro-input-group input {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #e0e7ff;
            border-radius: 8px;
            font-size: 1em;
            text-align: center;
            box-sizing: border-box;
        }

        .macro-input-group input:focus {
            outline: none;
            border-color: #0d9488;
        }

        .btn-submit-custom {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #0d9488 0%, #0891b2 100%);
            border: none;
            border-radius: 12px;
            color: white;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .btn-submit-custom:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(13, 148, 136, 0.4);
        }

        .btn-submit-custom:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-cancel-custom {
            width: 100%;
            padding: 12px;
            background: #6b7280;
            border: none;
            border-radius: 12px;
            color: white;
            font-size: 1em;
            cursor: pointer;
            margin-top: 10px;
        }

        /* Saved Meals Styles */
        .saved-meals-list {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 15px;
        }

        .saved-meal-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            margin-bottom: 8px;
            background: #fafafa;
        }

        .saved-meal-item:hover {
            background: #f0fdf4;
            border-color: #86efac;
        }

        .saved-meal-info {
            flex: 1;
            min-width: 0;
        }

        .saved-meal-name {
            font-weight: 600;
            color: #1f2937;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .saved-meal-macros {
            font-size: 0.8em;
            color: #6b7280;
            margin-top: 2px;
        }

        .saved-meal-actions {
            display: flex;
            gap: 8px;
            margin-left: 10px;
        }

        .btn-use-saved {
            padding: 6px 12px;
            background: linear-gradient(135deg, #0d9488 0%, #0891b2 100%);
            border: none;
            border-radius: 6px;
            color: white;
            font-size: 0.85em;
            cursor: pointer;
        }

        .btn-delete-saved {
            padding: 6px 10px;
            background: #fee2e2;
            border: none;
            border-radius: 6px;
            color: #dc2626;
            font-size: 0.85em;
            cursor: pointer;
        }

        .btn-delete-saved:hover {
            background: #fecaca;
        }

        .no-saved-meals {
            text-align: center;
            padding: 30px;
            color: #9ca3af;
        }

        .save-for-later-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 15px;
            padding: 10px;
            background: #fffbeb;
            border: 1px solid #fcd34d;
            border-radius: 8px;
        }

        .save-for-later-row input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .save-for-later-row label {
            font-size: 0.9em;
            color: #92400e;
            cursor: pointer;
        }
    </style>
</head>
<body>
<div class="app-container">


    <!-- DIET PLAN VIEW -->
    <div id="diet-plan-view">
        <div class="card">
            <a href="dashboard.html" class="text-blue-600 hover:text-blue-800 mb-6 inline-block">&larr; Back to Dashboard</a>
            <h2 class="text-2xl font-bold text-gray-800 mb-6">Full Diet Plan Generator</h2>

            <!-- Unit System Toggle -->
            <div class="flex justify-center items-center gap-3 mb-6 p-3 bg-gray-50 rounded-lg">
                <span class="text-sm font-semibold text-gray-700">Unit System:</span>
                <div class="flex gap-2">
                    <button id="unit-imperial" class="btn btn-primary text-sm py-1 px-3">Imperial (lbs/ft)</button>
                    <button id="unit-metric" class="btn btn-secondary text-sm py-1 px-3">Metric (kg/cm)</button>
                </div>
            </div>

            <div class="space-y-6">
                <!-- Client Selector Section -->
                <div class="p-4 bg-teal-50 border-2 border-teal-400 rounded-lg">
                    <label class="font-bold text-teal-900 block mb-2">üë§ Select Client</label>
                    <div class="grid grid-cols-1 gap-3">
                        <select id="dp_client_selector" class="input-field border-2 border-teal-500" required>
                            <option value="">Loading clients...</option>
                        </select>
                        <div id="new_client_form" class="hidden">
                            <input type="text" id="dp_new_client_name" class="input-field border-2 border-teal-500" placeholder="Enter new client name" required>
                            <input type="hidden" id="dp_selected_client_id">
                        </div>
                    </div>
                </div>

                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div><label for="dp_age" class="font-semibold text-gray-700">Age</label><input type="number" id="dp_age" class="input-field" placeholder="30" required></div>
                    <div><label for="dp_gender" class="font-semibold text-gray-700">Gender</label><select id="dp_gender" class="input-field"><option value="male">Male</option><option value="female">Female</option></select></div>
                    <div><label for="dp_weight" class="font-semibold text-gray-700">Weight (lbs)</label><input type="number" id="dp_weight" class="input-field" placeholder="155" required></div>
                    <div><label for="dp_height_ft" class="font-semibold text-gray-700">Height (ft)</label><input type="number" id="dp_height_ft" class="input-field" placeholder="5" required></div>
                    <div><label for="dp_height_in" class="font-semibold text-gray-700">Height (in)</label><input type="number" id="dp_height_in" class="input-field" placeholder="10" required></div>
                    <div><label for="dp_activity" class="font-semibold text-gray-700">Activity</label><select id="dp_activity" class="input-field"><option value="1.2">Sedentary</option><option value="1.55" selected>Moderate</option><option value="1.725">Very Active</option></select></div>
                </div>

                <div class="p-4 bg-blue-50 border-2 border-blue-400 rounded-lg">
                    <label class="font-bold text-blue-900 block mb-2">üìÖ Number of Days</label>
                    <select id="dp_days" class="input-field border-2 border-blue-500">
                        <option value="1">1 Day</option>
                        <option value="2">2 Days</option>
                        <option value="3" selected>3 Days</option>
                        <option value="4">4 Days</option>
                        <option value="5">5 Days</option>
                        <option value="6">6 Days</option>
                        <option value="7">7 Days (Full Week)</option>
                    </select>
                </div>

                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div><label class="font-semibold text-gray-700">Goal</label><select id="dp_goal" class="input-field"><option value="lose weight">Lose Weight</option><option value="maintain weight" selected>Maintain</option><option value="gain muscle">Gain Muscle</option></select></div>
                    <div><label class="font-semibold text-gray-700">Calorie Adjustment</label><select id="dp_calorie_adjustment" class="input-field"><option value="0" selected>Standard (Recommended)</option><option value="-250">Slightly Aggressive (-250 cals)</option><option value="-500">Aggressive (-500 cals)</option><option value="-750">Most Aggressive (-750 cals)</option><option value="250">Slight Surplus (+250 cals)</option><option value="500">Moderate Surplus (+500 cals)</option></select></div>
                    <div><label class="font-semibold text-gray-700">Diet Type</label><select id="dp_preference" class="input-field"><option value="omnivore" selected>Omnivore</option><option value="vegetarian">Vegetarian</option><option value="vegan">Vegan</option><option value="keto">Keto</option></select></div>
                    <div><label class="font-semibold text-gray-700">Macronutrient Preference</label><select id="dp_macro_preference" class="input-field"><option value="balanced" selected>Balanced (Default)</option><option value="lower-carb">Lower Carb</option><option value="higher-carb">Higher Carb / Lower Fat</option></select></div>
                    <div><label for="dp_allergies" class="font-semibold text-gray-700">Allergies</label><input type="text" id="dp_allergies" class="input-field" placeholder="e.g., dairy, nuts"></div>
                    <div><label for="dp_disliked_foods" class="font-semibold text-gray-700">Disliked Foods</label><input type="text" id="dp_disliked_foods" class="input-field" placeholder="e.g., mushrooms, olives"></div>
                    <div><label for="dp_preferred_foods" class="font-semibold text-gray-700">Preferred Foods or Cuisines</label><input type="text" id="dp_preferred_foods" class="input-field" placeholder="e.g., Italian, Mexican"></div>
                    <div><label for="dp_budget" class="font-semibold text-gray-700">Budget (Optional)</label><input type="text" id="dp_budget" class="input-field" placeholder="e.g., $50/week"></div>
                    <div><label class="font-semibold text-gray-700">Meals Per Day</label><select id="dp_meals" class="input-field"><option value="3 meals">3 Meals</option><option value="3 meals, 1 snack" selected>3 Meals + 1 Snack</option><option value="3 meals, 2 snacks">3 Meals + 2 Snacks</option><option value="3 meals, 3 snacks">3 Meals + 3 Snacks</option></select></div>
                </div>

                <!-- Cooking Equipment -->
                <div class="p-4 bg-teal-50 border-2 border-teal-400 rounded-lg">
                    <label class="font-bold text-teal-900 block mb-2">üç≥ Available Cooking Equipment</label>
                    <div class="grid grid-cols-2 md:grid-cols-3 gap-2">
                        <label class="flex items-center"><input type="checkbox" id="equip_stove" value="Stove" class="mr-2 h-4 w-4" checked> Stove</label>
                        <label class="flex items-center"><input type="checkbox" id="equip_oven" value="Oven" class="mr-2 h-4 w-4" checked> Oven</label>
                        <label class="flex items-center"><input type="checkbox" id="equip_microwave" value="Microwave" class="mr-2 h-4 w-4" checked> Microwave</label>
                        <label class="flex items-center"><input type="checkbox" id="equip_airfryer" value="Air Fryer" class="mr-2 h-4 w-4"> Air Fryer</label>
                        <label class="flex items-center"><input type="checkbox" id="equip_grill" value="Grill" class="mr-2 h-4 w-4"> Grill</label>
                        <label class="flex items-center"><input type="checkbox" id="equip_blender" value="Blender" class="mr-2 h-4 w-4" checked> Blender</label>
                    </div>
                </div>

                <!-- Branded Fitness Foods Preference -->
                <div class="p-4 bg-purple-50 border-2 border-purple-400 rounded-lg">
                    <div class="flex items-center">
                        <input type="checkbox" id="dp_use_branded_foods" class="mr-2 h-5 w-5">
                        <label for="dp_use_branded_foods" class="font-bold text-purple-900">üèãÔ∏è Use Branded Fitness Foods</label>
                    </div>
                    <p class="text-sm text-purple-700 mt-1">Include popular fitness brands like Quest Bars, Premier Protein, Fairlife, Oikos, Halo Top, and more in meal plans.</p>
                </div>

                <!-- Protein Powder Integration -->
                <div class="p-4 bg-teal-50 border-2 border-teal-400 rounded-lg">
                    <div class="flex items-center mb-2">
                        <input type="checkbox" id="dp_use_protein" class="mr-2 h-5 w-5">
                        <label for="dp_use_protein" class="font-bold text-teal-900">Add Protein Powder (Optional)</label>
                    </div>
                    <div id="protein-powder-fields" class="hidden grid grid-cols-2 gap-2 mt-2">
                        <input type="text" id="dp_protein_brand" class="input-field" placeholder="Brand/Name">
                        <input type="number" id="dp_protein_cals" class="input-field" placeholder="Calories">
                        <input type="number" id="dp_protein_protein" class="input-field" placeholder="Protein (g)">
                        <input type="number" id="dp_protein_carbs" class="input-field" placeholder="Carbs (g)">
                        <input type="number" id="dp_protein_fat" class="input-field" placeholder="Fat (g)">
                    </div>
                </div>

                <button data-action="generate-plan" id="generate-plan-btn" class="btn btn-primary w-full text-lg">‚ú® Create Diet Plan</button>
            </div>
        </div>
        <div id="diet-plan-result"></div>
    </div>

    <!-- RECIPE MODAL -->
    <div id="recipe-modal" class="modal-overlay hidden">
        <div class="card w-11/12 md:max-w-2xl max-h-[80vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-4">
                <h3 id="recipe-title" class="text-2xl font-bold">Recipe</h3>
                <button data-action="close-modal" class="text-2xl font-bold">&times;</button>
            </div>
            <div id="recipe-content" class="text-gray-700 space-y-4 prose"></div>
        </div>
    </div>

    <!-- SHARE MODAL -->
    <div id="share-modal" class="modal-overlay hidden">
        <div class="card w-11/12 md:max-w-2xl">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-2xl font-bold text-blue-600">üîó Share Meal Plan</h3>
                <button data-action="close-share-modal" class="text-2xl font-bold">&times;</button>
            </div>
            <p class="text-gray-600 mb-4">Share this link with your client. They'll be able to view, change, and revise meals.</p>
            <div class="bg-blue-50 p-4 rounded-lg mb-4 break-all">
                <div id="share-link-text" class="text-blue-600 font-semibold">Generating link...</div>
            </div>
            <button data-action="copy-share-link" class="btn btn-primary w-full mb-2">üìã Copy Link</button>
            <button data-action="close-share-modal" class="btn btn-secondary w-full">Close</button>
        </div>
    </div>

    <!-- MEAL PREP GUIDE MODAL -->
    <div id="meal-prep-modal" class="modal-overlay hidden">
        <div class="card w-11/12 md:max-w-4xl max-h-[85vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-6">
                <h3 class="text-3xl font-bold text-gray-800">üìã Meal Prep Guide</h3>
                <button data-action="close-meal-prep-modal" class="text-2xl font-bold">&times;</button>
            </div>
            <div id="meal-prep-content" class="text-gray-700 space-y-6">
                <div class="flex items-center justify-center py-12">
                    <div class="loader"><div class="loader-spinner"></div></div>
                    <p class="ml-4 text-gray-600">Generating your comprehensive meal prep guide...</p>
                </div>
            </div>
            <div class="mt-6 flex justify-end">
                <button data-action="close-meal-prep-modal" class="btn btn-secondary">Close</button>
            </div>
        </div>
    </div>

    <!-- MATH CHECK MODAL -->
    <div id="math-check-modal" class="modal-overlay hidden">
        <div class="card w-11/12 md:max-w-4xl max-h-[85vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-6">
                <h3 class="text-3xl font-bold text-gray-800">üîç Nutrition Math Check</h3>
                <button data-action="close-math-modal" class="text-2xl font-bold">&times;</button>
            </div>
            <div id="math-check-content" class="text-gray-700 space-y-4"></div>
            <div class="mt-6 flex justify-end">
                <button data-action="close-math-modal" class="btn btn-secondary">Close</button>
            </div>
        </div>
    </div>
</div>

<!-- Custom Meal Modal -->
<div id="customMealModal" class="custom-meal-overlay">
    <div class="custom-meal-modal">
        <div class="custom-meal-header">
            <h2>üéØ Custom Meal</h2>
            <p style="color: #666; margin: 0;">Create your own meal</p>
        </div>

        <!-- Tabs -->
        <div class="custom-meal-tabs">
            <div class="custom-meal-tab active" onclick="switchCustomMealTab('calculate')">
                <span class="custom-meal-tab-icon">üßÆ</span>
                <span class="custom-meal-tab-label">Calculate</span>
            </div>
            <div class="custom-meal-tab" onclick="switchCustomMealTab('manual')">
                <span class="custom-meal-tab-icon">‚úèÔ∏è</span>
                <span class="custom-meal-tab-label">Manual</span>
            </div>
            <div class="custom-meal-tab" onclick="switchCustomMealTab('saved')">
                <span class="custom-meal-tab-icon">üìö</span>
                <span class="custom-meal-tab-label">My Saved</span>
            </div>
        </div>

        <!-- Calculate Panel -->
        <div id="calculatePanel" class="custom-meal-panel active">
            <div class="custom-meal-hint">
                üí° Search our food database for ingredients. Add them with quantities to calculate macros.
            </div>

            <!-- Food Search Input -->
            <div class="food-search-container">
                <input
                    type="text"
                    id="foodSearchInput"
                    class="custom-meal-input"
                    placeholder="Search foods (e.g., chicken breast, rice, Quest bar)..."
                    oninput="handleFoodSearch(this.value)"
                    autocomplete="off"
                    style="margin-bottom: 0;"
                >
                <div id="foodSearchResults" class="food-search-results"></div>
            </div>

            <!-- Selected Ingredients List -->
            <div class="selected-ingredients">
                <div class="selected-ingredients-header">
                    <span>Selected Ingredients</span>
                    <span id="ingredientCount">(0)</span>
                </div>
                <div id="ingredientsList" class="ingredients-list">
                    <div class="no-ingredients">No ingredients added yet</div>
                </div>
            </div>

            <!-- Calculated Totals -->
            <div class="calculated-totals">
                <div class="totals-header">üìä Calculated Totals</div>
                <div class="totals-grid">
                    <div class="total-item">
                        <div class="total-value" id="totalCalories">0</div>
                        <div class="total-label">Calories</div>
                    </div>
                    <div class="total-item">
                        <div class="total-value" id="totalProtein">0g</div>
                        <div class="total-label">Protein</div>
                    </div>
                    <div class="total-item">
                        <div class="total-value" id="totalCarbs">0g</div>
                        <div class="total-label">Carbs</div>
                    </div>
                    <div class="total-item">
                        <div class="total-value" id="totalFat">0g</div>
                        <div class="total-label">Fat</div>
                    </div>
                </div>
            </div>

            <!-- Meal Name -->
            <input
                type="text"
                id="calculatedMealName"
                class="custom-meal-input"
                placeholder="Meal name (optional - auto-generated if blank)"
            >

            <div class="save-for-later-row">
                <input type="checkbox" id="saveCalculatedForLater">
                <label for="saveCalculatedForLater">üíæ Save this meal for future use</label>
            </div>

            <button class="btn-submit-custom" onclick="submitCalculatedMeal()" id="createCalculatedMealBtn" disabled>
                üßÆ Create Meal
            </button>
        </div>

        <!-- Manual Panel -->
        <div id="manualPanel" class="custom-meal-panel">
            <div class="custom-meal-hint">
                üí° Enter the meal name and macros directly. Use nutrition labels or apps like MyFitnessPal.
            </div>
            <input
                type="text"
                id="manualMealName"
                class="custom-meal-input"
                placeholder="Meal name (e.g., Protein Shake, Chipotle Bowl)"
            >
            <div class="macro-inputs-grid">
                <div class="macro-input-group">
                    <label>Calories</label>
                    <input type="number" id="manualCalories" placeholder="0">
                </div>
                <div class="macro-input-group">
                    <label>Protein (g)</label>
                    <input type="number" id="manualProtein" placeholder="0">
                </div>
                <div class="macro-input-group">
                    <label>Carbs (g)</label>
                    <input type="number" id="manualCarbs" placeholder="0">
                </div>
                <div class="macro-input-group">
                    <label>Fat (g)</label>
                    <input type="number" id="manualFat" placeholder="0">
                </div>
            </div>
            <input
                type="text"
                id="manualInstructions"
                class="custom-meal-input"
                placeholder="Instructions (optional)"
            >

            <div class="save-for-later-row">
                <input type="checkbox" id="saveManualForLater">
                <label for="saveManualForLater">üíæ Save this meal for future use</label>
            </div>

            <button class="btn-submit-custom" onclick="submitManualMeal()">
                ‚úÖ Create Meal
            </button>
        </div>

        <!-- Saved Meals Panel -->
        <div id="savedPanel" class="custom-meal-panel">
            <div class="custom-meal-hint">
                üìö Your saved custom meals. Click "Use" to add to your plan.
            </div>
            <div id="savedMealsList" class="saved-meals-list">
                <div class="no-saved-meals">No saved meals yet. Create a meal and check "Save for future use" to add it here.</div>
            </div>
        </div>

        <button class="btn-cancel-custom" onclick="closeCustomMealModal()">Cancel</button>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script>
// Initialize Supabase client
const SUPABASE_URL = 'https://qewqcjzlfqamqwbccapr.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFld3FjanpsZnFhbXF3YmNjYXByIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM2OTg0NzAsImV4cCI6MjA3OTI3NDQ3MH0.mQnMC33O88oLkLLGWD2oG-oaSHGI-NfHmtQCZxnxSLs';
const { createClient } = supabase;
const supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

const API_ENDPOINT = '/.netlify/functions/generate-meal-plan';
const TOGGLE_FAVORITE_ENDPOINT = '/.netlify/functions/toggle-favorite';

// Fetch favorites for a client
async function getClientFavorites(clientId) {
    try {
        const response = await fetch(`${TOGGLE_FAVORITE_ENDPOINT}?clientId=${clientId}`);
        if (!response.ok) return [];
        const data = await response.json();
        return data.favorites || [];
    } catch (error) {
        console.error('Error fetching favorites:', error);
        return [];
    }
}
const SAVE_PLAN_ENDPOINT = '/.netlify/functions/save-shared-plan';
const SAVE_COACH_PLAN_ENDPOINT = '/.netlify/functions/save-coach-plan';
const UPDATE_PLAN_NOTES_ENDPOINT = '/.netlify/functions/update-plan-notes';
const PUBLISH_PLAN_ENDPOINT = '/.netlify/functions/publish-plan';
let lastMealQuery = {};
let lastPlanQuery = {};
let currentShareUrl = '';
let currentCoach = null;
let clientsList = [];
// Store previous meal states for undo functionality - persisted to localStorage
const UNDO_STATES_KEY = 'plannerUndoStates';
let previousMealStates = {};

// Load undo states from localStorage
function loadUndoStates() {
    try {
        const saved = localStorage.getItem(UNDO_STATES_KEY);
        if (saved) {
            previousMealStates = JSON.parse(saved);
            console.log('üìÇ Loaded undo states from localStorage');
        }
    } catch (e) {
        console.error('Error loading undo states:', e);
        previousMealStates = {};
    }
}

// Save undo states to localStorage
function saveUndoStates() {
    try {
        localStorage.setItem(UNDO_STATES_KEY, JSON.stringify(previousMealStates));
    } catch (e) {
        console.error('Error saving undo states:', e);
    }
}

// Load undo states on page load
loadUndoStates();

// Warn user before leaving page with unsaved changes
let hasUnsavedChanges = false;

window.addEventListener('beforeunload', function(e) {
    // Check if there's a plan that hasn't been saved to database
    if (hasUnsavedChanges && lastPlanQuery.currentPlan && !lastPlanQuery.planId) {
        e.preventDefault();
        e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
        return e.returnValue;
    }
});

// Track when changes are made
function markUnsavedChanges() {
    hasUnsavedChanges = true;
}

// Clear unsaved changes flag after save
function clearUnsavedChanges() {
    hasUnsavedChanges = false;
}

// Load clients from database
async function loadClients() {
    try {
        if (!currentCoach) return;

        const response = await fetch(`/.netlify/functions/get-clients?coachId=${currentCoach.id}`);
        const data = await response.json();

        if (!response.ok) {
            throw new Error(data.error || 'Failed to load clients');
        }

        clientsList = data.clients || [];

        // Populate dropdown
        const clientSelector = document.getElementById('dp_client_selector');
        clientSelector.innerHTML = '<option value="">-- Select a Client --</option>';

        clientsList.forEach(client => {
            const option = document.createElement('option');
            option.value = client.id;
            option.textContent = client.client_name;
            clientSelector.appendChild(option);
        });

        console.log(`‚úÖ Loaded ${clientsList.length} clients`);

        // Check for clientId URL parameter and auto-select
        const urlParams = new URLSearchParams(window.location.search);
        const clientId = urlParams.get('clientId');
        if (clientId) {
            clientSelector.value = clientId;
            // Trigger change event to auto-populate fields
            clientSelector.dispatchEvent(new Event('change'));
            console.log(`‚úÖ Auto-selected client from URL: ${clientId}`);
        }

    } catch (error) {
        console.error('Error loading clients:', error);
        const clientSelector = document.getElementById('dp_client_selector');
        clientSelector.innerHTML = '<option value="new">Enter Client Name</option>';
        document.getElementById('new_client_form').classList.remove('hidden');
    }
}

// Handle client selection
document.addEventListener('DOMContentLoaded', () => {
    const clientSelector = document.getElementById('dp_client_selector');
    const newClientForm = document.getElementById('new_client_form');
    const newClientNameInput = document.getElementById('dp_new_client_name');
    const selectedClientIdInput = document.getElementById('dp_selected_client_id');

    clientSelector.addEventListener('change', (e) => {
        const selectedValue = e.target.value;

        if (selectedValue === '') {
            // No selection
            selectedClientIdInput.value = '';
        } else {
            // Client selected
            selectedClientIdInput.value = selectedValue;

            // Find the selected client and auto-populate ALL fields
            const client = clientsList.find(c => c.id === parseInt(selectedValue));
            if (client) {
                console.log('‚úÖ Auto-filling data for client:', client.client_name);

                // Physical stats
                if (client.age) document.getElementById('dp_age').value = client.age;
                if (client.gender) document.getElementById('dp_gender').value = client.gender;
                if (client.weight) document.getElementById('dp_weight').value = client.weight;
                if (client.height_ft) document.getElementById('dp_height_ft').value = client.height_ft;
                if (client.height_in) document.getElementById('dp_height_in').value = client.height_in;
                if (client.activity_level) document.getElementById('dp_activity').value = client.activity_level;

                // Goals & nutrition
                if (client.default_goal) {
                    const goalMap = {
                        'lose_weight': 'lose weight',
                        'maintain': 'maintain weight',
                        'gain_muscle': 'gain muscle'
                    };
                    const goalValue = goalMap[client.default_goal];
                    if (goalValue) document.getElementById('dp_goal').value = goalValue;
                }

                if (client.calorie_adjustment) document.getElementById('dp_calorie_adjustment').value = client.calorie_adjustment;
                if (client.diet_type) document.getElementById('dp_preference').value = client.diet_type;
                if (client.macro_preference) document.getElementById('dp_macro_preference').value = client.macro_preference;
                if (client.meal_count) document.getElementById('dp_meals').value = client.meal_count;

                // Food preferences
                if (client.allergies) document.getElementById('dp_allergies').value = client.allergies;
                if (client.disliked_foods) document.getElementById('dp_disliked_foods').value = client.disliked_foods;
                if (client.preferred_foods) document.getElementById('dp_preferred_foods').value = client.preferred_foods;
                if (client.budget) document.getElementById('dp_budget').value = client.budget;

                // Cooking equipment
                if (client.cooking_equipment && Array.isArray(client.cooking_equipment)) {
                    // Uncheck all first
                    document.querySelectorAll('input[id^="equip_"]').forEach(cb => cb.checked = false);
                    // Check the ones from client profile
                    client.cooking_equipment.forEach(equip => {
                        const equipId = 'equip_' + equip.toLowerCase().replace(/\s+/g, '');
                        const checkbox = document.getElementById(equipId);
                        if (checkbox) checkbox.checked = true;
                    });
                }

                // Protein powder
                if (client.use_protein_powder) {
                    document.getElementById('dp_use_protein').checked = true;
                    document.getElementById('protein-powder-fields').style.display = 'grid';
                    if (client.protein_powder_brand) document.getElementById('dp_protein_brand').value = client.protein_powder_brand;
                    if (client.protein_powder_calories) document.getElementById('dp_protein_cals').value = client.protein_powder_calories;
                    if (client.protein_powder_protein) document.getElementById('dp_protein_protein').value = client.protein_powder_protein;
                    if (client.protein_powder_carbs) document.getElementById('dp_protein_carbs').value = client.protein_powder_carbs;
                    if (client.protein_powder_fat) document.getElementById('dp_protein_fat').value = client.protein_powder_fat;
                } else {
                    document.getElementById('dp_use_protein').checked = false;
                    document.getElementById('protein-powder-fields').style.display = 'none';
                }

                // Branded fitness foods preference
                if (client.use_branded_foods) {
                    document.getElementById('dp_use_branded_foods').checked = true;
                } else {
                    document.getElementById('dp_use_branded_foods').checked = false;
                }

                console.log('‚úÖ All fields auto-populated from client profile');
            }
        }
    });
});

// Listen for auth state changes to handle session expiration
supabaseClient.auth.onAuthStateChange((event, session) => {
    console.log('Auth state changed:', event, session ? 'Session exists' : 'No session');

    if (event === 'SIGNED_OUT') {
        console.log('User signed out, clearing current coach');
        currentCoach = null;
    } else if (event === 'TOKEN_REFRESHED' && currentCoach) {
        console.log('Token refreshed for existing coach');
        // Reload clients if we have a coach
        loadClients();
    }
});

// Detect if page was loaded from back/forward cache and force reload
window.addEventListener('pageshow', function(event) {
    if (event.persisted) {
        // Page was loaded from bfcache (back/forward cache)
        console.log('Page loaded from cache, forcing reload...');
        window.location.reload();
    }
});

// Check authentication on page load
document.addEventListener('DOMContentLoaded', async () => {
    try {
        // Try to refresh the session to get a fresh token
        const { data: refreshData, error: refreshError } = await supabaseClient.auth.refreshSession();

        let session = null;

        // If refresh succeeded and we have a valid session with access token, use it
        if (!refreshError && refreshData?.session?.access_token) {
            session = refreshData.session;
            console.log('Session refreshed successfully');
        } else {
            // If refresh failed, session is likely expired
            console.warn('Session refresh failed or returned invalid session:', refreshError);
            session = null;
        }

        if (session) {
            currentCoach = session.user;
            console.log("Coach logged in:", currentCoach.email);

            // Load clients for the dropdown
            await loadClients();
        } else {
            console.warn("No active session - plans will not be saved to history");
            // If no session, just show a simple text input
            const clientSelector = document.getElementById('dp_client_selector');
            clientSelector.innerHTML = '<option value="new">Enter Client Name</option>';
            document.getElementById('new_client_form').classList.remove('hidden');
        }
    } catch (error) {
        console.error("Auth error:", error);
        currentCoach = null;
    }
});

// DIRECT NETLIFY FUNCTION CALL - Now using Claude 3.5 Sonnet
async function callClaude(prompt, targets, previousAttempt = null) {
    try {
        const response = await fetch(API_ENDPOINT, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                prompt,
                targets,
                previousAttempt
            })
        });

        if (!response.ok) {
            const errorData = await response.json();
            const errorMsg = errorData.message
                ? `${errorData.error}: ${errorData.message}`
                : errorData.error || 'API request failed';
            console.error('API Error Details:', errorData);
            throw new Error(errorMsg);
        }

        const result = await response.json();

        // Claude function returns: { success: true, data: {...}, rawResponse: "..." }
        if (result.success && result.data) {
            // üîç DETAILED LOGGING FOR DEBUGGING
            console.log('\n========================================');
            console.log('üì• BACKEND RESPONSE RECEIVED');
            console.log('========================================');

            // Check if JavaScript optimizer was used
            if (result.jsOptimized) {
                console.log('‚úÖ JavaScript Optimizer: ACTIVE');
            } else {
                console.log('‚ö†Ô∏è JavaScript Optimizer: NOT DETECTED');
            }

            // Log each meal's details
            if (result.data.plan && Array.isArray(result.data.plan)) {
                console.log(`\nüìã Meals Generated: ${result.data.plan.length}`);
                result.data.plan.forEach((meal, index) => {
                    console.log(`\n--- Meal ${index + 1}: ${meal.name} ---`);
                    console.log(`   Type: ${meal.type || 'N/A'}`);
                    console.log(`   Macros: ${meal.calories}cal, ${meal.protein}P, ${meal.carbs}C, ${meal.fat}F`);

                    if (meal.ingredients && Array.isArray(meal.ingredients)) {
                        console.log(`   Ingredients (${meal.ingredients.length}):`);
                        meal.ingredients.forEach(ing => {
                            if (typeof ing === 'string') {
                                console.log(`      - ${ing}`);
                            } else if (ing.food && ing.amount) {
                                console.log(`      - ${ing.amount} ${ing.food}`);
                            }
                        });
                    }

                    if (meal.calculation_notes) {
                        console.log(`   üßÆ JS Calculation:`, meal.calculation_notes);
                    }

                    if (meal.breakdown && Array.isArray(meal.breakdown)) {
                        console.log(`   üìä Detailed Breakdown:`);
                        meal.breakdown.forEach(item => {
                            console.log(`      - ${item.amount} ${item.food}: ${item.macros.calories}cal, ${item.macros.protein}P, ${item.macros.carbs}C, ${item.macros.fat}F (√ó${item.multiplier})`);
                        });
                    }
                });

                // Log totals if available
                if (result.data.targets) {
                    console.log('\nüéØ Target Macros:');
                    console.log(`   ${result.data.targets.calories}cal, ${result.data.targets.protein}P, ${result.data.targets.carbs}C, ${result.data.targets.fat}F`);
                }
            }
            console.log('========================================\n');

            return result.data;
        } else if (result.error) {
            throw new Error(result.error);
        } else {
            throw new Error('Invalid response from Claude API');
        }
    } catch (error) {
        console.error('Claude API Error:', error);
        return { error: error.message };
    }
}

// Backwards compatibility wrapper - gradually replace callGemini with callClaude
async function callGemini(prompt, isJson = true, targets = null, previousAttempt = null, mealsPerDay = null, skipAutoScale = false) {
    // Use hybrid Gemini + Claude approach (Gemini creates, Claude optimizes)
    try {
        const requestBody = {
            prompt,
            isJson // üÜï CRITICAL: Send isJson flag to backend
        };
        if (targets) requestBody.targets = targets;
        if (mealsPerDay) requestBody.mealsPerDay = mealsPerDay;
        if (skipAutoScale) requestBody.skipAutoScale = true; // Don't auto-scale for revisions

        const response = await fetch('/.netlify/functions/generate-meal-plan', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            throw new Error('API request failed');
        }

        const data = await response.json();

        // NEW: Handle new backend format (with Claude corrections)
        if (data.success && data.data) {
            console.log('‚úÖ Using new format with Claude corrections');
            console.log('üì¶ Raw backend response:', JSON.stringify(data.data).substring(0, 500));

            // Log macros if it's a single meal
            if (data.data.calories !== undefined) {
                console.log(`üî¢ Meal macros: ${data.data.calories}cal, ${data.data.protein}P, ${data.data.carbs}C, ${data.data.fat}F`);
            }

            // Backend already parsed and corrected the meal
            if (isJson) {
                return data.data; // Already parsed JSON
            } else {
                // For text responses (like Recipe or Meal Prep Guide), return the raw text
                return data.data; // This is the raw markdown text from Gemini
            }
        }

        // FALLBACK: Old Gemini format (for backwards compatibility)
        console.log('‚ö†Ô∏è Using old Gemini format');
        let text = data.candidates[0].content.parts[0].text;

        // Clean response - remove markdown code blocks
        text = text.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim();
        text = text.replace(/:\s*NaN/g, ': null');
        text = text.replace(/,\s*\.\.\./g, '');

        if (isJson) {
            // Extract JSON array or object
            const jsonMatch = text.match(/[\[{][\s\S]*[\]}]/);
            if (jsonMatch) text = jsonMatch[0];

            try {
                return JSON.parse(text);
            } catch (parseError) {
                console.warn('First parse failed, attempting to fix JSON:', parseError.message);
                text = text.replace(/"instructions":\s*"([^"]*(?:"[^"]*)*)"}/g, (match, content) => {
                    const fixed = content.replace(/"/g, "'");
                    return `"instructions": "${fixed}"}`;
                });
                text = text.replace(/,(\s*[}\]])/g, '$1');
                return JSON.parse(text);
            }
        }
        return text;
    } catch (error) {
        console.error('AI Error:', error);
        return { error: error.message };
    }
}

// FOOD DATABASE - Real nutritional values per standard portion
const FOOD_DATABASE = {
    // Proteins
    'chicken breast': { per: '4oz', cal: 185, protein: 35, carbs: 0, fat: 4 },
    'ground turkey': { per: '4oz', cal: 200, protein: 28, carbs: 0, fat: 11 },
    'ground beef 90/10': { per: '4oz', cal: 200, protein: 24, carbs: 0, fat: 11 },
    'salmon': { per: '4oz', cal: 200, protein: 23, carbs: 0, fat: 12 },
    'tilapia': { per: '4oz', cal: 145, protein: 30, carbs: 0, fat: 3 },
    'shrimp': { per: '4oz', cal: 120, protein: 26, carbs: 0, fat: 1 },
    'egg': { per: '1 large', cal: 70, protein: 6, carbs: 0, fat: 5 },
    'greek yogurt': { per: '1 cup', cal: 150, protein: 20, carbs: 10, fat: 4 },
    'cottage cheese': { per: '1 cup', cal: 200, protein: 28, carbs: 8, fat: 5 },
    'whey protein': { per: '1 scoop', cal: 120, protein: 25, carbs: 3, fat: 1 },

    // Carbs
    'brown rice': { per: '1 cup cooked', cal: 215, protein: 5, carbs: 45, fat: 2 },
    'white rice': { per: '1 cup cooked', cal: 205, protein: 4, carbs: 45, fat: 0 },
    'quinoa': { per: '1 cup cooked', cal: 222, protein: 8, carbs: 39, fat: 4 },
    'sweet potato': { per: '1 medium', cal: 115, protein: 2, carbs: 27, fat: 0 },
    'oats': { per: '1 cup cooked', cal: 150, protein: 6, carbs: 27, fat: 3 },
    'whole wheat bread': { per: '1 slice', cal: 80, protein: 4, carbs: 14, fat: 1 },
    'pasta': { per: '1 cup cooked', cal: 220, protein: 8, carbs: 43, fat: 1 },

    // Fats
    'avocado': { per: '1/2 medium', cal: 120, protein: 1, carbs: 6, fat: 10 },
    'olive oil': { per: '1 tbsp', cal: 120, protein: 0, carbs: 0, fat: 14 },
    'almond butter': { per: '1 tbsp', cal: 95, protein: 3, carbs: 3, fat: 9 },
    'almonds': { per: '1 oz (23 nuts)', cal: 160, protein: 6, carbs: 6, fat: 14 },
    'cheese cheddar': { per: '1 oz', cal: 115, protein: 7, carbs: 0, fat: 9 },

    // Vegetables
    'broccoli': { per: '100g', cal: 35, protein: 3, carbs: 7, fat: 0 },
    'spinach': { per: '100g', cal: 23, protein: 3, carbs: 4, fat: 0 },
    'bell pepper': { per: '100g', cal: 26, protein: 1, carbs: 6, fat: 0 },

    // Fruits
    'banana': { per: '1 medium', cal: 105, protein: 1, carbs: 27, fat: 0 },
    'apple': { per: '1 medium', cal: 95, protein: 0, carbs: 25, fat: 0 },
    'blueberries': { per: '1 cup', cal: 85, protein: 1, carbs: 21, fat: 0 }
};

// MEAL VALIDATION FUNCTION
function validateMeal(meal, mealType) {
    const issues = [];

    // Skip validation for supplement items (user-defined values)
    if (mealType === 'supplement' || meal.type === 'supplement') {
        return { valid: true, issues: [] };
    }

    // Validation 1: Macro math check - ALIGNED with Claude's 8% tolerance
    const calculatedCalories = (meal.protein * 4) + (meal.carbs * 4) + (meal.fat * 9);
    const calorieDifference = Math.abs(meal.calories - calculatedCalories);
    const percentOff = calorieDifference / meal.calories;

    if (percentOff > 0.08) { // More than 8% off - matches Claude's training
        issues.push(`Macro math error: ${meal.calories} cal listed but macros calculate to ${Math.round(calculatedCalories)} cal (${Math.round(percentOff*100)}% error)`);
    }

    // Validation 2 & 3: REMOVED - Calorie ranges were too strict
    // Now using informational warnings only via "Check Math" feature

    // Validation 4: Sanity check on macros
    if (meal.protein < 0 || meal.carbs < 0 || meal.fat < 0) {
        issues.push('Negative macro values detected');
    }

    if (meal.protein > 100 || meal.carbs > 150 || meal.fat > 80) {
        issues.push('Unrealistically high macro values in single meal');
    }

    // Validation 5: Protein source validation - catch impossible protein claims
    const mealNameLower = meal.name.toLowerCase();

    // Check protein limits based on portion sizes in meal name
    const proteinChecks = [
        // Whey protein - STRICT LIMIT
        { regex: /1\s*scoop.*(?:whey|protein powder)/i, maxProtein: 30, name: '1 scoop protein' },
        { regex: /2\s*scoop.*(?:whey|protein powder)/i, maxProtein: 55, name: '2 scoops protein' },

        // Chicken breast
        { regex: /4\s*oz.*chicken/i, maxProtein: 40, name: '4oz chicken' },
        { regex: /6\s*oz.*chicken/i, maxProtein: 55, name: '6oz chicken' },
        { regex: /8\s*oz.*chicken/i, maxProtein: 75, name: '8oz chicken' },

        // Ground turkey
        { regex: /4\s*oz.*(?:ground\s*)?turkey/i, maxProtein: 32, name: '4oz turkey' },
        { regex: /6\s*oz.*(?:ground\s*)?turkey/i, maxProtein: 48, name: '6oz turkey' },

        // Salmon/fish
        { regex: /4\s*oz.*(?:salmon|fish)/i, maxProtein: 28, name: '4oz salmon/fish' },
        { regex: /6\s*oz.*(?:salmon|fish)/i, maxProtein: 40, name: '6oz salmon/fish' },

        // Eggs
        { regex: /2\s*(?:large\s*)?egg/i, maxProtein: 14, name: '2 eggs' },
        { regex: /3\s*(?:large\s*)?egg/i, maxProtein: 20, name: '3 eggs' },
        { regex: /4\s*(?:large\s*)?egg/i, maxProtein: 26, name: '4 eggs' },

        // Greek yogurt
        { regex: /1\s*cup.*greek yogurt/i, maxProtein: 22, name: '1 cup Greek yogurt' },
        { regex: /2\s*cup.*greek yogurt/i, maxProtein: 42, name: '2 cups Greek yogurt' }
    ];

    for (const check of proteinChecks) {
        if (check.regex.test(mealNameLower)) {
            if (meal.protein > check.maxProtein) {
                issues.push(`Protein impossible for ${check.name}: ${meal.protein}g claimed but max ~${check.maxProtein}g from that portion`);
            }
        }
    }

    // Validation 6: Realistic portion sizes for common high-calorie foods
    const calorieFloorChecks = [
        { keywords: ['burrito', 'wrap with'], minCal: 400, name: 'Burrito/Large wrap' },
        { keywords: ['pizza', 'slice'], minCal: 250, name: 'Pizza' },
        { keywords: ['burger', 'cheeseburger'], minCal: 400, name: 'Burger' },
        { keywords: ['pasta', 'spaghetti', 'fettuccine', 'penne'], minCal: 350, name: 'Pasta dish' },
        { keywords: ['fried'], minCal: 300, name: 'Fried food' },
        { keywords: ['quesadilla'], minCal: 400, name: 'Quesadilla' },
        { keywords: ['sandwich with'], minCal: 350, name: 'Large sandwich' },
        { keywords: ['steak', 'ribeye', 'sirloin'], minCal: 300, name: 'Steak meal' },
        { keywords: ['bacon'], minCal: 200, name: 'Meal with bacon' }
    ];

    for (const check of calorieFloorChecks) {
        if (check.keywords.some(kw => mealNameLower.includes(kw))) {
            if (meal.calories < check.minCal) {
                issues.push(`${check.name} is unrealistically low: ${meal.calories} cal (minimum ${check.minCal} cal expected)`);
            }
        }
    }

    return {
        valid: true, // Always valid - issues are informational only
        issues: issues,
        meal: meal
    };
}

// VALIDATE ENTIRE DAY'S TOTALS
function validateDayTotals(dayData) {
    const targets = dayData.targets;
    const plan = dayData.plan;

    // Calculate actual totals
    const actualCals = plan.reduce((sum, meal) => sum + meal.calories, 0);
    const actualProtein = plan.reduce((sum, meal) => sum + meal.protein, 0);
    const actualCarbs = plan.reduce((sum, meal) => sum + meal.carbs, 0);
    const actualFat = plan.reduce((sum, meal) => sum + meal.fat, 0);

    // DISABLED: Trust Claude optimization + USDA database instead of strict validation
    // Claude optimizes each meal to hit targets using accurate database
    // Validation was causing false negatives and blocking good meal plans
    console.log(`üìä Daily totals: ${actualCals} cal, ${actualProtein}g P, ${actualCarbs}g C, ${actualFat}g F`);
    console.log(`üéØ Targets:      ${targets.calories} cal, ${targets.protein}g P, ${targets.carbs}g C, ${targets.fat}g F`);

    const calDiff = Math.abs(actualCals - targets.calories) / targets.calories;
    const proteinDiff = Math.abs(actualProtein - targets.protein) / targets.protein;
    const carbsDiff = Math.abs(actualCarbs - targets.carbs) / targets.carbs;
    const fatDiff = Math.abs(actualFat - targets.fat) / targets.fat;

    console.log(`üìà Variance: ${(calDiff * 100).toFixed(1)}% cal, ${(proteinDiff * 100).toFixed(1)}% P, ${(carbsDiff * 100).toFixed(1)}% C, ${(fatDiff * 100).toFixed(1)}% F`);

    // Always return valid - trust the optimization
    return {
        valid: true,
        issues: [],
        totals: { calories: actualCals, protein: actualProtein, carbs: actualCarbs, fat: actualFat }
    };
}

// MULTI-DAY DIET PLAN GENERATOR
async function generateDietPlan() {
    const resultDiv = document.getElementById('diet-plan-result');
    const button = document.getElementById('generate-plan-btn');

    const age = document.getElementById('dp_age').value;
    const weight = document.getElementById('dp_weight').value;
    const heightFt = document.getElementById('dp_height_ft').value;
    const heightIn = document.getElementById('dp_height_in').value;

    if (!age || !weight || !heightFt) {
        alert('Please fill in all required fields');
        return;
    }

    resultDiv.innerHTML = '<div class="card"><div class="loader"><div class="loader-spinner"></div></div><p class="text-center text-gray-600">Creating your diet plan...</p></div>';
    button.disabled = true;

    // Get client from selector
    let clientName = 'Client';
    let clientId = null;
    const clientSelector = document.getElementById('dp_client_selector');
    const selectedValue = clientSelector.value;

    if (!selectedValue || selectedValue === "") {
        // No client selected
        alert('‚ö†Ô∏è Please select a client from the dropdown before generating a plan.');
        button.disabled = false;
        resultDiv.innerHTML = '';
        return;
    }

    // Parse and validate client ID
    clientId = parseInt(selectedValue);
    if (isNaN(clientId) || clientId <= 0) {
        alert('‚ö†Ô∏è Invalid client selection. Please select a valid client from the dropdown.');
        button.disabled = false;
        resultDiv.innerHTML = '';
        return;
    }

    // Ensure client exists in the list
    const client = clientsList.find(c => c.id === clientId);
    if (!client) {
        alert('‚ö†Ô∏è Selected client not found. Please refresh the page and try again.');
        button.disabled = false;
        resultDiv.innerHTML = '';
        return;
    }

    clientName = client.client_name;

    // Fetch client's favorite meals
    const clientFavorites = await getClientFavorites(clientId);
    let favoriteMealsText = '';
    if (clientFavorites.length > 0) {
        const favoriteMealsList = clientFavorites.slice(0, 10).map(f => {
            return `- ${f.meal_name} (${f.meal_type || 'meal'}: ${f.calories || '?'} cal, ${f.protein || '?'}g protein)`;
        }).join('\n');
        favoriteMealsText = `\n\nCLIENT'S FAVORITE MEALS (try to include 1-2 of these or similar variations):\n${favoriteMealsList}`;
        console.log(`Loaded ${clientFavorites.length} favorites for client ${clientId}`);
    }

    const gender = document.getElementById('dp_gender').value;
    const activity = parseFloat(document.getElementById('dp_activity').value);
    const goal = document.getElementById('dp_goal').value;
    const calorieAdjustment = parseInt(document.getElementById('dp_calorie_adjustment').value);
    const preference = document.getElementById('dp_preference').value;
    const macroPreference = document.getElementById('dp_macro_preference').value;
    const allergies = document.getElementById('dp_allergies').value || 'none';
    const dislikedFoods = document.getElementById('dp_disliked_foods').value || 'none';
    const preferredFoods = document.getElementById('dp_preferred_foods').value || 'none';
    const budget = document.getElementById('dp_budget').value || 'none';
    const meals = document.getElementById('dp_meals').value;
    const numDays = parseInt(document.getElementById('dp_days').value);

    // Get cooking equipment
    const equipment = [];
    if (document.getElementById('equip_stove').checked) equipment.push('Stove');
    if (document.getElementById('equip_oven').checked) equipment.push('Oven');
    if (document.getElementById('equip_microwave').checked) equipment.push('Microwave');
    if (document.getElementById('equip_airfryer').checked) equipment.push('Air Fryer');
    if (document.getElementById('equip_grill').checked) equipment.push('Grill');
    if (document.getElementById('equip_blender').checked) equipment.push('Blender');
    const equipmentStr = equipment.length > 0 ? equipment.join(', ') : 'basic kitchen tools';

    // Get branded fitness foods preference
    const useBrandedFoods = document.getElementById('dp_use_branded_foods').checked;

    // Calculate nutrition (Mifflin-St Jeor)
    let weightKg, heightCm;
    if (currentUnitSystem === 'imperial') {
        weightKg = parseFloat(weight) * 0.453592;
        heightCm = (parseInt(heightFt) * 30.48) + (parseInt(heightIn || 0) * 2.54);
    } else {
        weightKg = parseFloat(weight);
        heightCm = parseFloat(heightFt);
    }

    let bmr;
    if (gender === 'male') {
        bmr = (10 * weightKg) + (6.25 * heightCm) - (5 * parseInt(age)) + 5;
    } else {
        bmr = (10 * weightKg) + (6.25 * heightCm) - (5 * parseInt(age)) - 161;
    }

    let tdee = bmr * activity;
    if (goal === 'lose weight') tdee -= 500;
    if (goal === 'gain muscle') tdee += 300;

    // Apply calorie adjustment
    tdee += calorieAdjustment;

    let calories = Math.round(tdee);

    // Calculate macros based on macro preference
    let proteinRatio, carbRatio, fatRatio;
    if (macroPreference === 'lower-carb') {
        proteinRatio = 0.35;
        carbRatio = 0.25;
        fatRatio = 0.40;
    } else if (macroPreference === 'higher-carb') {
        proteinRatio = 0.25;
        carbRatio = 0.50;
        fatRatio = 0.25;
    } else { // balanced
        proteinRatio = 0.30;
        carbRatio = 0.40;
        fatRatio = 0.30;
    }

    let protein = Math.round((calories * proteinRatio) / 4);
    let carbs = Math.round((calories * carbRatio) / 4);
    let fat = Math.round((calories * fatRatio) / 9);

    // Store original targets (before any protein powder subtraction)
    const originalTargets = {
        calories: calories,
        protein: protein,
        carbs: carbs,
        fat: fat
    };

    // Store protein powder info if selected (will be added as supplement item)
    let proteinPowderInfo = null;
    if (document.getElementById('dp_use_protein').checked) {
        const proteinCals = parseInt(document.getElementById('dp_protein_cals').value) || 0;
        const proteinProtein = parseInt(document.getElementById('dp_protein_protein').value) || 0;
        const proteinCarbs = parseInt(document.getElementById('dp_protein_carbs').value) || 0;
        const proteinFat = parseInt(document.getElementById('dp_protein_fat').value) || 0;
        const proteinBrand = document.getElementById('dp_protein_brand').value || 'Protein Powder';

        // Store protein powder info to add as supplement item later
        proteinPowderInfo = {
            brand: proteinBrand,
            calories: proteinCals,
            protein: proteinProtein,
            carbs: proteinCarbs,
            fat: proteinFat
        };

        // Subtract from targets for meal generation (meals + supplement = original targets)
        calories -= proteinCals;
        protein -= proteinProtein;
        carbs -= proteinCarbs;
        fat -= proteinFat;
    }

    lastPlanQuery = {
        clientName,
        clientId,
        calories: Math.round(tdee),
        protein,
        carbs,
        fat,
        preference,
        macroPreference,
        allergies,
        dislikedFoods,
        preferredFoods,
        budget,
        equipmentStr,
        meals,
        originalTargets,
        proteinPowderInfo,
        useBrandedFoods
    };

    // Generate each day separately
    const allDays = [];
    for (let day = 1; day <= numDays; day++) {
        // Build a list of previously used meals to ensure variety
        let previousMealsText = '';
        if (allDays.length > 0) {
            const previousMeals = [];
            allDays.forEach(dayData => {
                dayData.plan.forEach(meal => {
                    previousMeals.push(meal.name);
                });
            });
            previousMealsText = `\n\nPREVIOUS DAYS MEALS (DO NOT REPEAT):\n${previousMeals.join('\n')}\n\nIMPORTANT: Create COMPLETELY DIFFERENT meals from the previous days listed above. Provide variety in proteins, cuisines, and cooking methods.`;
        }

        // Build protein powder note if applicable
        let proteinPowderNote = '';
        if (proteinPowderInfo) {
            proteinPowderNote = `\nNote: Client uses protein powder (${proteinPowderInfo.brand || 'protein supplement'}) which will be added separately. Meal targets already account for this.`;
        }

        // Build branded fitness foods note if applicable
        let brandedFoodsNote = '';
        if (useBrandedFoods) {
            brandedFoodsNote = `

BRANDED FITNESS FOODS PREFERENCE:
This client PREFERS branded fitness foods. Please ACTIVELY incorporate these popular fitness-friendly products into their meal plan:
- Protein bars as snacks: Quest Bars, RXBars, Built Bars, ONE Bars, Barebells
- Ready-to-drink protein: Premier Protein shakes, Fairlife protein shakes, Core Power
- Greek yogurt: Oikos Triple Zero, Chobani Zero Sugar, Two Good, Siggi's
- Healthy ice cream: Halo Top, Enlightened, Rebel (as occasional treat/dessert)
- Healthy snacks: Smart Sweets, Chomps beef sticks, Epic bars
- High-protein bread: Dave's Killer Bread, Ezekiel bread
- Protein oatmeal: Kodiak Cakes, Magic Spoon cereal
- Nut butters: Justin's almond butter, PB2 powdered peanut butter

Use database keys like: quest_bar_original, premier_protein_chocolate, oikos_triple_zero_vanilla, fairlife_chocolate, halo_top_vanilla, chomps_original, daves_killer_bread_21grain, etc.
Include at least 1-2 branded fitness foods per day in this meal plan.`;
        }

        // Parse meal structure to be explicit
        let mealStructure = '';
        let expectedMealTypes = [];

        if (meals === '3 meals') {
            mealStructure = 'EXACTLY 3 meals: breakfast, lunch, dinner';
            expectedMealTypes = ['breakfast', 'lunch', 'dinner'];
        } else if (meals === '3 meals, 1 snack') {
            mealStructure = 'EXACTLY 4 items: breakfast, lunch, dinner, and 1 snack';
            expectedMealTypes = ['breakfast', 'lunch', 'dinner', 'snack'];
        } else if (meals === '3 meals, 2 snacks') {
            mealStructure = 'EXACTLY 5 items: breakfast, lunch, dinner, and 2 snacks';
            expectedMealTypes = ['breakfast', 'lunch', 'dinner', 'snack', 'snack'];
        } else if (meals === '3 meals, 3 snacks') {
            mealStructure = 'EXACTLY 6 items: breakfast, lunch, dinner, and 3 snacks';
            expectedMealTypes = ['breakfast', 'lunch', 'dinner', 'snack', 'snack', 'snack'];
        } else {
            // Default fallback if meals value is invalid
            console.warn(`Invalid meals value: "${meals}". Defaulting to 3 meals + 1 snack`);
            mealStructure = 'EXACTLY 4 items: breakfast, lunch, dinner, and 1 snack';
            expectedMealTypes = ['breakfast', 'lunch', 'dinner', 'snack'];
        }

        const dayPrompt = `Create 1-day meal plan for Day ${day} of ${numDays}.
Stats: ${age}yo ${gender}, ${weightKg.toFixed(0)}kg, ${heightCm.toFixed(0)}cm
Goal: ${goal}, Diet: ${preference}
Macro Preference: ${macroPreference}
Avoid: ${allergies}
Disliked Foods: ${dislikedFoods}
Preferred Foods/Cuisines: ${preferredFoods}
Budget: ${budget}
Available Equipment: ${equipmentStr}${proteinPowderNote}${previousMealsText}${favoriteMealsText}${brandedFoodsNote}

Daily targets: ${calories} cal, ${protein}g protein, ${carbs}g carbs, ${fat}g fat

CRITICAL TARGET REQUIREMENT:
Your meals MUST add up to approximately these daily targets. This is NOT optional.
- Acceptable variance: ¬±10% for calories, ¬±15% for macros
- Being 20%+ UNDER targets is UNACCEPTABLE - you must size portions appropriately
- Each meal should average ~${Math.round(calories / expectedMealTypes.length)} calories
- Calculate portions so your meals collectively hit targets within acceptable variance
- Example: If target is 2604 cal, acceptable range is 2344-2864 cal
- If your meals only add up to 2079 cal (20% under), portions are TOO SMALL

PORTION SIZING GUIDANCE:
- Small snack: 200-350 cal | Regular meal: 500-700 cal | Large meal: 700-900 cal
- Adjust protein portions: 100-200g chicken/fish, 150-300g tofu/beans
- Adjust carb portions: 150-300g cooked rice/pasta, 200-400g potatoes
- Don't be timid with portions - hitting targets is more important than "small portions"

CRITICAL VARIETY REQUIREMENT:
Create UNIQUE and CREATIVE meals. DO NOT default to common patterns like eggs/toast/avocado.
Vary your meal choices across:
- Different protein sources (chicken, beef, fish, turkey, tofu, eggs, legumes)
- Different cuisines (Italian, Mexican, Asian, Mediterranean, American)
- Different cooking styles (grilled, baked, stir-fried, slow-cooked)
- Different carb sources (rice, pasta, quinoa, sweet potato, bread, oats)
Think creatively and provide interesting variety!

CRITICAL MEAL STRUCTURE:
Generate ${mealStructure}. DO NOT generate more or fewer items.
${expectedMealTypes.length === 4 ? 'The array should have EXACTLY 4 objects.' : ''}
${expectedMealTypes.length === 5 ? 'The array should have EXACTLY 5 objects.' : ''}
${expectedMealTypes.length === 6 ? 'The array should have EXACTLY 6 objects.' : ''}

===== USDA VERIFIED FOOD DATABASE =====
YOU MUST CHOOSE ONLY FROM THIS LIST. Use exact snake_case names.

PROTEINS - Poultry (per 100g raw):
chicken_breast: 165cal, 31P, 0C, 4F | turkey_breast: 135cal, 30P, 0C, 1F
ground_turkey: 176cal, 25P, 0C, 10F | ground_chicken: 143cal, 17P, 0C, 8F

PROTEINS - Beef (per 100g raw):
ground_beef_93: 164cal, 22P, 0C, 7F | sirloin_steak: 160cal, 28P, 0C, 5F
flank_steak: 192cal, 27P, 0C, 9F | bison: 143cal, 28P, 0C, 2F

PROTEINS - Pork (per 100g raw):
pork_tenderloin: 143cal, 26P, 0C, 4F | pork_chop: 206cal, 26P, 0C, 11F

PROTEINS - Seafood (per 100g raw):
salmon: 177cal, 20P, 0C, 11F | cod: 82cal, 18P, 0C, 1F | tilapia: 128cal, 26P, 0C, 3F
shrimp: 106cal, 23P, 1C, 1F | tuna_canned_water: 116cal, 26P, 0C, 1F

PROTEINS - Dairy & Eggs:
egg_large (1 egg): 70cal, 6P, 0C, 5F | egg_white (1 white): 17cal, 4P, 0C, 0F
greek_yogurt_nonfat (100g): 59cal, 10P, 4C, 0F
cottage_cheese_nonfat (100g): 72cal, 12P, 6C, 0F

PROTEINS - Plant (per 100g cooked):
tofu_firm: 76cal, 8P, 2C, 5F | lentils_cooked: 116cal, 9P, 20C, 0F
black_beans: 132cal, 9P, 24C, 1F | chickpeas: 164cal, 9P, 27C, 3F

PROTEINS - Powder (per scoop):
whey_protein (30g): 120cal, 25P, 3C, 1F

CARBS - Rice & Grains (per 100g cooked):
brown_rice_cooked: 112cal, 2P, 24C, 1F | white_rice_cooked: 130cal, 3P, 28C, 0F
quinoa_cooked: 120cal, 4P, 21C, 2F | oats_cooked: 71cal, 2P, 12C, 1F
pasta_cooked: 131cal, 5P, 25C, 1F

CARBS - Potatoes (per 100g):
sweet_potato: 86cal, 2P, 20C, 0F | russet_potato: 79cal, 2P, 18C, 0F

CARBS - Bread (per slice/piece):
whole_wheat_bread (1 slice 28g): 80cal, 4P, 14C, 1F
ezekiel_bread (1 slice 34g): 80cal, 4P, 15C, 1F
tortilla_flour (1 tortilla 32g): 94cal, 3P, 16C, 2F

FATS - Oils & Butters (per tbsp):
olive_oil: 120cal, 0P, 0C, 14F | butter: 102cal, 0P, 0C, 12F
avocado_oil: 120cal, 0P, 0C, 14F

FATS - Nut Butters (per tbsp 16g):
peanut_butter: 94cal, 4P, 3C, 8F | almond_butter: 95cal, 3P, 3C, 9F

FATS - Nuts (per 28g):
almonds: 160cal, 6P, 6C, 14F | walnuts: 185cal, 4P, 4C, 18F

FATS - Whole Foods (per 100g):
avocado: 160cal, 2P, 9C, 15F

VEGETABLES (per 100g):
broccoli: 34cal, 3P, 7C, 0F | spinach: 23cal, 3P, 4C, 0F
bell_pepper: 26cal, 1P, 6C, 0F | zucchini: 17cal, 1P, 3C, 0F
asparagus: 20cal, 2P, 4C, 0F | green_beans: 31cal, 2P, 7C, 0F

FRUITS:
banana (1 medium 118g): 105cal, 1P, 27C, 0F
blueberries (100g): 57cal, 1P, 14C, 0F
strawberries (100g): 32cal, 1P, 8C, 0F
apple (1 medium 182g): 95cal, 0P, 25C, 0F

CONDIMENTS (per tbsp):
ketchup: 17cal, 0P, 4C, 0F | mustard: 10cal, 1P, 1C, 1F
hot_sauce: 1cal, 0P, 0C, 0F | soy_sauce: 9cal, 1P, 1C, 0F

CRITICAL RULES:
- Use ONLY foods from this list with exact snake_case names
- Portions: "100g", "150g", "1 tbsp", "2 slices", "1 egg", "200g"
- MEAL NAME FORMAT: Include ALL key ingredient portions inline in parentheses
  Examples:
  "High-Protein Oatmeal (80g dry) with Scrambled Eggs (2 whole, 200g whites) and Peanut Butter (1 tbsp)"
  "Grilled Chicken Breast (200g) with Quinoa (150g cooked) and Broccoli (100g)"
  "Greek Yogurt Bowl (170g) with Blueberries (75g) and Almonds (28g)"
- CRITICAL: Meal name descriptor MUST match database entry used
  If using "oats_rolled_dry" ‚Üí say "80g dry oats" in name
  If using "oats_cooked" ‚Üí say "80g cooked oats" in name
  If using "quinoa_cooked" ‚Üí say "150g cooked quinoa" in name
  If using "brown_rice_cooked" ‚Üí say "200g cooked rice" in name
- NO adjectives like "delicious" or "hearty" in meal names

IMPORTANT: Only use recipes that can be made with the available equipment.
Consider the budget constraint and preferred foods when planning meals.
${day > 1 ? 'ENSURE VARIETY: This is Day ' + day + ', so make sure meals are different from previous days.' : ''}

CRITICAL: Return ONLY valid JSON with NO special characters, NO quotes in text, NO newlines in strings.
Use only alphanumeric characters and basic punctuation (periods, commas) in text fields.
Replace all quotes with apostrophes. Keep instructions simple and brief.
Include detailed ingredients list and full cooking instructions.

CRITICAL INGREDIENTS FORMAT:
You MUST return ingredients as an ARRAY OF STRINGS in natural language format.
Include the food name AND amount/portion in parentheses.

EXAMPLES:
"Chicken Breast (200g)" ‚úÖ
"Eggs (3 whole)" ‚úÖ
"Rolled Oats (80g dry)" ‚úÖ
"Egg Whites (200g)" ‚úÖ
"Brown Rice (150g cooked)" ‚úÖ
"Whole Wheat Bread (2 slices)" ‚úÖ
"Olive Oil (1 tbsp)" ‚úÖ
"Greek Yogurt (170g)" ‚úÖ

FULL EXAMPLE (use this EXACT format):
{"day":${day},"targets":{"calories":${calories},"protein":${protein},"carbs":${carbs},"fat":${fat}},"plan":[{"type":"breakfast","name":"Scrambled Eggs (3 whole) with Whole Wheat Toast (2 slices) and Avocado (50g)","ingredients":["Eggs (3 whole)","Whole Wheat Bread (2 slices)","Butter (1 tbsp)","Avocado (50g)"],"instructions":"Scramble 3 eggs in 1 tbsp butter. Toast 2 slices bread. Serve with sliced avocado."}]}

CRITICAL REQUIREMENTS:
1. Ingredients MUST be array of strings: ["Food Name (amount)", "Food Name (amount)"]
2. Use natural language names: "Chicken Breast" not "chicken_breast"
3. ALWAYS include amount in parentheses: "Chicken Breast (200g)" not just "Chicken Breast"
4. DO NOT include calories/protein/carbs/fat - backend calculates from database
5. Portions: "100g", "150g", "200g", "1 tbsp", "2 slices", "3 whole", etc.
6. Each meal MUST have "type", "name", "ingredients", "instructions"
7. For descriptors like dry/cooked, include in parentheses: "Oats (80g dry)" or "Rice (200g cooked)"

STEP-BY-STEP:
1. Choose 3-5 foods from database for each meal
2. Use natural language food names
3. Specify realistic portions to hit meal targets
4. Format as string array with amounts in parentheses
5. Backend will match to database and calculate exact macros`;

        // Build targets object for hybrid Gemini + JS optimizer
        const dayTargets = {
            calories: calories,
            protein: protein,
            carbs: carbs,
            fat: fat
        };

        // ‚úÖ Use callGemini (hybrid approach with JS optimizer) instead of callClaude
        const dayData = await callGemini(dayPrompt, true, dayTargets, null, expectedMealTypes.length);
        if (dayData.error) {
            resultDiv.innerHTML = `<div class="card text-red-600">Error generating Day ${day}: ${dayData.error}</div>`;
            button.disabled = false;
            return;
        }

        // Validate meal count
        if (dayData.plan && Array.isArray(dayData.plan)) {
            if (dayData.plan.length !== expectedMealTypes.length) {
                console.warn(`‚ö†Ô∏è Wrong meal count: Got ${dayData.plan.length} meals but expected ${expectedMealTypes.length}`);
                // Trim or pad the plan to match expected count
                if (dayData.plan.length > expectedMealTypes.length) {
                    console.log('Trimming excess meals...');
                    dayData.plan = dayData.plan.slice(0, expectedMealTypes.length);
                }
            }
        }

        // Validate each meal and regenerate if needed
        if (dayData.plan && Array.isArray(dayData.plan)) {
            for (let mealIndex = 0; mealIndex < dayData.plan.length; mealIndex++) {
                const meal = dayData.plan[mealIndex];
                const validation = validateMeal(meal, meal.type);

                if (!validation.valid) {
                    console.warn(`‚ö†Ô∏è Validation failed for ${meal.type} on Day ${day}:`, validation.issues);
                    console.log('üîÑ Regenerating meal...');

                    // Regenerate this specific meal using hybrid Gemini + JS optimizer (max 2 attempts)
                    let retryCount = 0;
                    let validMeal = null;
                    let previousAttempt = null;

                    while (retryCount < 2 && !validMeal) {
                        const regeneratePrompt = `Generate a single ${meal.type} meal.
Diet preference: ${preference}
Avoid: ${allergies}

This meal should fit into a day's plan with the following targets.`;

                        // Build targets object for JS optimizer
                        const mealTargets = {
                            calories: meal.calories,
                            protein: meal.protein,
                            carbs: meal.carbs,
                            fat: meal.fat
                        };

                        // Include validation errors as feedback if this is a retry
                        if (retryCount > 0 && previousAttempt) {
                            previousAttempt.errors = validation.issues;
                        }

                        // ‚úÖ Use callGemini (hybrid approach with JS optimizer) instead of callClaude
                        const newMeal = await callGemini(regeneratePrompt, true, mealTargets, previousAttempt, 1);
                        if (!newMeal.error) {
                            const newValidation = validateMeal(newMeal, meal.type);
                            if (newValidation.valid) {
                                validMeal = newMeal;
                                console.log('‚úÖ Regenerated meal passed validation');
                            } else {
                                console.warn(`Retry ${retryCount + 1} still has issues:`, newValidation.issues);
                                previousAttempt = { errors: newValidation.issues };
                            }
                        }
                        retryCount++;
                    }

                    // Use regenerated meal if valid, otherwise keep original
                    if (validMeal) {
                        dayData.plan[mealIndex] = validMeal;
                    } else {
                        console.error(`‚ùå CRITICAL: Could not generate valid ${meal.type} after ${retryCount} retries`);
                        console.error('Invalid meal issues:', validation.issues);

                        // BLOCK: Do not proceed with invalid meal
                        resultDiv.innerHTML = `<div class="card text-red-600">
                            <h3 class="font-bold mb-2">‚ùå Meal Generation Failed</h3>
                            <p>Could not generate a valid ${meal.type} for Day ${day} after multiple attempts.</p>
                            <p class="mt-2">Issues detected: ${validation.issues.join(', ')}</p>
                            <p class="mt-4 text-sm">This is a quality control measure to ensure accurate nutrition data. Please try generating again.</p>
                        </div>`;
                        button.disabled = false;
                        return; // STOP - don't save or display plan
                    }
                }
            }
        }

        // Validate day's total macros against targets - ENFORCE THIS
        const dayValidation = validateDayTotals(dayData);
        if (!dayValidation.valid) {
            console.error(`‚ùå CRITICAL: Day ${day} totals don't match targets:`, dayValidation.issues);
            console.error(`Actual totals: ${dayValidation.totals.calories} cal, ${dayValidation.totals.protein}g protein, ${dayValidation.totals.carbs}g carbs, ${dayValidation.totals.fat}g fat`);

            // BLOCK: Do not proceed with inaccurate day
            resultDiv.innerHTML = `<div class="card text-red-600">
                <h3 class="font-bold mb-2">‚ùå Daily Total Validation Failed</h3>
                <p>Day ${day} meals don't add up to targets accurately enough.</p>
                <p class="mt-2"><strong>Target:</strong> ${dayData.targets.calories} cal, ${dayData.targets.protein}g protein, ${dayData.targets.carbs}g carbs, ${dayData.targets.fat}g fat</p>
                <p><strong>Actual:</strong> ${dayValidation.totals.calories} cal, ${dayValidation.totals.protein}g protein, ${dayValidation.totals.carbs}g carbs, ${dayValidation.totals.fat}g fat</p>
                <p class="mt-4 text-sm">Issues: ${dayValidation.issues.join(', ')}</p>
                <p class="mt-4 text-sm">This is a quality control measure. Please try generating again.</p>
            </div>`;
            button.disabled = false;
            return; // STOP - don't save or display plan
        } else {
            console.log(`‚úÖ Day ${day} totals validated successfully`);
        }

        // Add protein powder as supplement item if configured
        if (proteinPowderInfo) {
            const supplementItem = {
                type: 'supplement',
                name: proteinPowderInfo.brand,
                calories: proteinPowderInfo.calories,
                protein: proteinPowderInfo.protein,
                carbs: proteinPowderInfo.carbs,
                fat: proteinPowderInfo.fat,
                ingredients: [`${proteinPowderInfo.brand} (1 serving)`],
                instructions: 'Mix with water or milk as directed.'
            };
            dayData.plan.push(supplementItem);
            console.log(`‚úÖ Added protein powder supplement to Day ${day}`);
        }

        // Update targets to show original values (including protein powder)
        dayData.targets = originalTargets;

        allDays.push(dayData);
    }

    // FINAL VALIDATION: Check all days before saving/displaying
    console.log('üîç Performing final validation on entire plan...');
    let planValid = true;
    let planIssues = [];

    for (let i = 0; i < allDays.length; i++) {
        const day = allDays[i];

        // Check each meal
        for (let j = 0; j < day.plan.length; j++) {
            const meal = day.plan[j];
            const validation = validateMeal(meal, meal.type);
            if (!validation.valid) {
                planValid = false;
                planIssues.push(`Day ${day.day} ${meal.type}: ${validation.issues.join(', ')}`);
            }
        }

        // Check day totals
        const dayValidation = validateDayTotals(day);
        if (!dayValidation.valid) {
            planValid = false;
            planIssues.push(`Day ${day.day} totals: ${dayValidation.issues.join(', ')}`);
        }
    }

    if (!planValid) {
        console.error('‚ùå FINAL VALIDATION FAILED');
        console.error('Issues found:', planIssues);
        resultDiv.innerHTML = `<div class="card text-red-600">
            <h3 class="font-bold mb-2">‚ùå Plan Validation Failed</h3>
            <p>The generated plan did not pass final quality checks.</p>
            <p class="mt-2"><strong>Issues found:</strong></p>
            <ul class="list-disc ml-6 mt-2">
                ${planIssues.map(issue => `<li>${issue}</li>`).join('')}
            </ul>
            <p class="mt-4 text-sm">This is a quality control measure. Please try generating again.</p>
        </div>`;
        button.disabled = false;
        return; // BLOCK - do not save or display invalid plan
    }

    console.log('‚úÖ All validation passed - plan is accurate');

    lastPlanQuery.currentPlan = allDays;
    markUnsavedChanges(); // Track that there are unsaved changes

    // Generate a summary of what's in the plan for client display
    lastPlanQuery.summary = generatePlanSummary(lastPlanQuery);
    console.log('üìã Plan summary:', lastPlanQuery.summary);

    displayDietPlan(allDays);

    // Save plan to coach's history (only if valid)
    // Must await to ensure planId is set before user can interact with Submit button
    const saveSuccess = await saveCoachPlan(lastPlanQuery, lastPlanQuery.clientName);

    // Show save status to user
    if (!saveSuccess) {
        showSaveRetryButton();
    }

    button.disabled = false;
}

function displayDietPlan(multiDayData) {
    const resultDiv = document.getElementById('diet-plan-result');
    const targets = multiDayData[0].targets;

    // Helper function to get color class based on variance
    const getVarianceColor = (variancePercent) => {
        const abs = Math.abs(variancePercent);
        if (abs <= 10) return 'text-green-600'; // Within ¬±10% - good
        if (abs <= 20) return 'text-yellow-600'; // Within ¬±20% - acceptable
        return 'text-red-600'; // Over ¬±20% - needs adjustment
    };

    // Helper function to format variance display
    const formatVariance = (actual, target, variancePercent) => {
        const diff = actual - target;
        const sign = diff >= 0 ? '+' : '';
        return `${sign}${diff} (${sign}${variancePercent.toFixed(1)}%)`;
    };

    let planHTML = `
        <div class="card">
            <h3 class="text-xl font-bold mb-4">Your ${multiDayData.length}-Day Plan</h3>

            <div class="mb-4">
                <p class="text-sm font-semibold text-gray-700 mb-2">Daily Nutrition Targets:</p>
                <div class="grid grid-cols-4 gap-2 p-4 bg-blue-50 rounded-lg">
                    <div class="text-center"><p class="text-sm text-gray-600">Calories</p><span class="font-bold text-blue-600">${targets.calories}</span></div>
                    <div class="text-center"><p class="text-sm text-gray-600">Protein</p><span class="font-bold text-blue-600">${targets.protein}g</span></div>
                    <div class="text-center"><p class="text-sm text-gray-600">Carbs</p><span class="font-bold text-blue-600">${targets.carbs}g</span></div>
                    <div class="text-center"><p class="text-sm text-gray-600">Fat</p><span class="font-bold text-blue-600">${targets.fat}g</span></div>
                </div>
            </div>

    `;

    multiDayData.forEach((dayData, dayIndex) => {
        // Calculate per-day actual totals
        let dayTotals = { calories: 0, protein: 0, carbs: 0, fat: 0 };
        dayData.plan.forEach(meal => {
            dayTotals.calories += meal.calories || 0;
            dayTotals.protein += meal.protein || 0;
            dayTotals.carbs += meal.carbs || 0;
            dayTotals.fat += meal.fat || 0;
        });

        // Calculate per-day variance
        const dayVariance = {
            calories: ((dayTotals.calories - targets.calories) / targets.calories * 100),
            protein: ((dayTotals.protein - targets.protein) / targets.protein * 100),
            carbs: ((dayTotals.carbs - targets.carbs) / targets.carbs * 100),
            fat: ((dayTotals.fat - targets.fat) / targets.fat * 100)
        };

        planHTML += `
            <div class="day-divider" style="display: flex; justify-content: space-between; align-items: center; padding: 0.75rem 1rem;">
                <span>Day ${dayData.day}</span>
                <button data-action="regenerate-day" data-day-index="${dayIndex}" class="btn btn-secondary text-xs" style="background: rgba(255,255,255,0.2); color: white; border: 1px solid rgba(255,255,255,0.3); padding: 0.5rem 1rem;">üîÑ Regenerate Day</button>
            </div>
            <div class="mb-3 p-3 bg-gray-50 rounded-lg">
                <p class="text-xs font-semibold text-gray-600 mb-2">Day ${dayData.day} Totals:</p>
                <div class="grid grid-cols-4 gap-2 text-center">
                    <div>
                        <p class="text-xs text-gray-500">Calories</p>
                        <span class="text-sm font-bold ${getVarianceColor(dayVariance.calories)}">${dayTotals.calories}</span>
                        <p class="text-xs ${getVarianceColor(dayVariance.calories)}">${formatVariance(dayTotals.calories, targets.calories, dayVariance.calories)}</p>
                    </div>
                    <div>
                        <p class="text-xs text-gray-500">Protein</p>
                        <span class="text-sm font-bold ${getVarianceColor(dayVariance.protein)}">${dayTotals.protein}g</span>
                        <p class="text-xs ${getVarianceColor(dayVariance.protein)}">${formatVariance(dayTotals.protein, targets.protein, dayVariance.protein)}</p>
                    </div>
                    <div>
                        <p class="text-xs text-gray-500">Carbs</p>
                        <span class="text-sm font-bold ${getVarianceColor(dayVariance.carbs)}">${dayTotals.carbs}g</span>
                        <p class="text-xs ${getVarianceColor(dayVariance.carbs)}">${formatVariance(dayTotals.carbs, targets.carbs, dayVariance.carbs)}</p>
                    </div>
                    <div>
                        <p class="text-xs text-gray-500">Fat</p>
                        <span class="text-sm font-bold ${getVarianceColor(dayVariance.fat)}">${dayTotals.fat}g</span>
                        <p class="text-xs ${getVarianceColor(dayVariance.fat)}">${formatVariance(dayTotals.fat, targets.fat, dayVariance.fat)}</p>
                    </div>
                </div>
            </div>`;
        dayData.plan.forEach((meal, mealIndex) => {
            const mealNoteId = `meal-note-${dayIndex}-${mealIndex}`;
            const existingNote = meal.coach_note || '';
            const isSupplement = meal.type === 'supplement';

            if (isSupplement) {
                // Special styling for supplement items
                planHTML += `
                <div class="meal-card" style="background: linear-gradient(135deg, #e0f2fe 0%, #dbeafe 100%); border: 2px solid #0ea5e9;">
                    <h4 class="font-bold text-lg capitalize" style="color: #0369a1;">üíä Supplement</h4>
                    <p class="text-blue-700">${meal.name}</p>
                    <div class="grid grid-cols-4 gap-1 text-xs text-gray-600 my-2">
                        <span>${meal.calories} cal</span>
                        <span>${meal.protein}g P</span>
                        <span>${meal.carbs}g C</span>
                        <span>${meal.fat}g F</span>
                    </div>
                    <p class="text-xs text-gray-500 italic">${meal.instructions || 'Mix with water or milk as directed.'}</p>
                </div>`;
            } else {
                // Check if there's a previous state for undo
                const undoStateKey = `${dayIndex}-${mealIndex}`;
                const hasUndoState = previousMealStates[undoStateKey] !== undefined;
                const undoButton = hasUndoState
                    ? `<button data-action="undo-meal" data-day-index="${dayIndex}" data-meal-index="${mealIndex}" class="btn text-xs" style="background: #dc2626; color: white;" title="Undo last change">‚Ü©Ô∏è Undo</button>`
                    : '';

                planHTML += `
                <div class="meal-card">
                    <h4 class="font-bold text-lg capitalize">${meal.type}</h4>
                    <p class="text-blue-700">${meal.name}</p>
                    <div class="grid grid-cols-4 gap-1 text-xs text-gray-600 my-2">
                        <span>${meal.calories} cal</span>
                        <span>${meal.protein}g P</span>
                        <span>${meal.carbs}g C</span>
                        <span>${meal.fat}g F</span>
                    </div>
                    <div class="flex gap-2 mt-2">
                        <button data-action="change-meal" data-day-index="${dayIndex}" data-meal-index="${mealIndex}" class="btn btn-secondary text-xs flex-1">üîÑ Change</button>
                        <button data-action="revise-meal" data-day-index="${dayIndex}" data-meal-index="${mealIndex}" class="btn btn-secondary text-xs flex-1">‚úèÔ∏è Revise</button>
                        <button data-action="custom-meal" data-day-index="${dayIndex}" data-meal-index="${mealIndex}" class="btn btn-custom text-xs flex-1" title="Create exact meal from scratch">üéØ Custom</button>
                        <button data-action="get-recipe" data-meal-name="${meal.name}" class="btn btn-secondary text-xs flex-1">üìñ Recipe</button>
                        ${undoButton}
                    </div>
                    <div class="meal-note-section" style="margin-top: 12px; background: #fef3c7; padding: 10px; border-radius: 6px; border: 1px solid #fcd34d;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                            <span style="font-weight: 600; color: #92400e; font-size: 11px;">üìù Note for Client:</span>
                            <button data-action="save-meal-note" data-day-index="${dayIndex}" data-meal-index="${mealIndex}" class="btn" style="background: #f59e0b; color: white; padding: 3px 10px; font-size: 10px; border-radius: 4px;">Save</button>
                        </div>
                        <textarea id="${mealNoteId}" style="width: 100%; min-height: 50px; padding: 6px; border: 1px solid #fcd34d; border-radius: 4px; font-size: 12px; resize: vertical;" placeholder="Add a note about this meal...">${existingNote}</textarea>
                    </div>
                </div>`;
            }
        });
    });

    // Coach Notes Section
    planHTML += `
        <div class="coach-notes-section" style="margin-top: 20px; padding: 16px; background: #f0f9ff; border-radius: 8px; border: 1px solid #bae6fd;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h4 style="margin: 0; color: #0369a1; font-size: 14px; font-weight: 600;">üìù Coach Notes for Client</h4>
                <button id="saveNotesBtn" data-action="save-coach-notes" class="btn btn-secondary" style="font-size: 12px; padding: 6px 12px;">Save Notes</button>
            </div>
            <textarea id="coachNotesInput" placeholder="Add personalized notes, tips, or instructions for your client..." style="width: 100%; min-height: 80px; padding: 10px; border: 1px solid #cbd5e0; border-radius: 6px; font-size: 14px; resize: vertical;"></textarea>
            <p style="margin-top: 6px; font-size: 11px; color: #64748b;">These notes will be visible to the client when they view this plan.</p>
        </div>
    `;

    // Plan Status Banner and Submit Button
    planHTML += `
        <div id="plan-status-banner" class="plan-status-section" style="margin-top: 20px; padding: 16px; background: #fef3c7; border-radius: 8px; border: 2px solid #f59e0b;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <span style="font-size: 14px; font-weight: 600; color: #92400e;">üìù Status: <span id="plan-status-text" style="background: #f59e0b; color: white; padding: 2px 8px; border-radius: 4px;">Draft</span></span>
                    <p style="margin: 4px 0 0 0; font-size: 12px; color: #92400e;">This plan is saved but not yet visible to your client.</p>
                </div>
                <button id="submitToClientBtn" data-action="submit-to-client" class="btn btn-primary" style="background: #10b981; font-size: 14px; padding: 10px 20px; white-space: nowrap;">
                    ‚úÖ Submit to Client
                </button>
            </div>
        </div>
    `;

    planHTML += `
        <div class="flex gap-2 mt-4">
            <button data-action="check-math" class="btn btn-secondary w-full" style="background:#6c757d;">üîç Check Math</button>
            <button data-action="show-meal-prep-guide" class="btn btn-primary w-full" style="background:#ff6b6b;">üìã Meal Prep Guide</button>
            <button data-action="show-grocery-list" class="btn btn-secondary w-full">üìù Grocery List</button>
            <button data-action="download-pdf" class="btn btn-primary w-full">üì• Download PDF</button>
            <button data-action="share-plan" class="btn btn-primary w-full" style="background:#28a745;">üîó Share Plan Link</button>
        </div>
    </div>`;
    resultDiv.innerHTML = planHTML;
}

// UPDATE PLAN STATUS UI
function updatePlanStatusUI() {
    const banner = document.getElementById('plan-status-banner');
    const statusText = document.getElementById('plan-status-text');
    const submitBtn = document.getElementById('submitToClientBtn');

    if (!banner || !statusText) return;

    if (lastPlanQuery.status === 'published') {
        banner.style.background = '#d1fae5';
        banner.style.borderColor = '#10b981';
        statusText.textContent = 'Published';
        statusText.style.background = '#10b981';
        banner.querySelector('p').textContent = 'This plan is visible to your client.';
        banner.querySelector('p').style.color = '#065f46';
        banner.querySelector('div > span').style.color = '#065f46';
        if (submitBtn) {
            submitBtn.style.display = 'none';
        }
    } else {
        banner.style.background = '#fef3c7';
        banner.style.borderColor = '#f59e0b';
        statusText.textContent = 'Draft';
        statusText.style.background = '#f59e0b';
        banner.querySelector('p').textContent = 'This plan is saved but not yet visible to your client.';
        banner.querySelector('p').style.color = '#92400e';
        banner.querySelector('div > span').style.color = '#92400e';
        if (submitBtn) {
            submitBtn.style.display = 'block';
        }
    }
}

// SHOW SAVE RETRY BUTTON (when auto-save fails)
function showSaveRetryButton() {
    const banner = document.getElementById('plan-status-banner');
    if (!banner) return;

    // Update banner to show error state
    banner.style.background = '#fee2e2';
    banner.style.borderColor = '#ef4444';

    const statusText = document.getElementById('plan-status-text');
    if (statusText) {
        statusText.textContent = 'Not Saved';
        statusText.style.background = '#ef4444';
    }

    const descP = banner.querySelector('p');
    if (descP) {
        descP.textContent = 'Plan could not be saved. Click "Save Plan" to try again.';
        descP.style.color = '#991b1b';
    }

    const colorSpan = banner.querySelector('div > span');
    if (colorSpan) {
        colorSpan.style.color = '#991b1b';
    }

    // Hide submit button, show save button
    const submitBtn = document.getElementById('submitToClientBtn');
    if (submitBtn) {
        submitBtn.style.display = 'none';
    }

    // Add or show save retry button
    let saveBtn = document.getElementById('savePlanBtn');
    if (!saveBtn) {
        saveBtn = document.createElement('button');
        saveBtn.id = 'savePlanBtn';
        saveBtn.className = 'btn btn-primary';
        saveBtn.style.cssText = 'background: #3b82f6; font-size: 14px; padding: 10px 20px; white-space: nowrap;';
        saveBtn.innerHTML = 'üíæ Save Plan';
        saveBtn.onclick = retrySavePlan;
        submitBtn.parentNode.appendChild(saveBtn);
    }
    saveBtn.style.display = 'block';
}

// HIDE SAVE RETRY BUTTON (when save succeeds)
function hideSaveRetryButton() {
    const saveBtn = document.getElementById('savePlanBtn');
    if (saveBtn) {
        saveBtn.style.display = 'none';
    }
}

// RETRY SAVING PLAN
async function retrySavePlan() {
    const saveBtn = document.getElementById('savePlanBtn');
    if (saveBtn) {
        saveBtn.innerHTML = 'üíæ Saving...';
        saveBtn.disabled = true;
    }

    const success = await saveCoachPlan(lastPlanQuery, lastPlanQuery.clientName);

    if (success) {
        // Hide the save button and show normal status
        hideSaveRetryButton();
        updatePlanStatusUI();
    } else {
        // Still failed, reset button
        if (saveBtn) {
            saveBtn.innerHTML = 'üíæ Save Plan';
            saveBtn.disabled = false;
        }
        alert('Failed to save plan. Please check your connection and try again.');
    }
}

// PUBLISH PLAN TO CLIENT
async function publishPlanToClient() {
    if (!currentCoach || !lastPlanQuery.planId) {
        // Check if save failed - show more helpful message
        if (lastPlanQuery.currentPlan && !lastPlanQuery.planId) {
            alert('Plan needs to be saved first. Please click the "Save Plan" button to save your plan before submitting to client.');
        } else {
            alert('Please generate a plan first.');
        }
        return;
    }

    const submitBtn = document.getElementById('submitToClientBtn');
    const originalText = submitBtn.innerHTML;
    submitBtn.innerHTML = 'Submitting...';
    submitBtn.disabled = true;

    try {
        const response = await fetch(PUBLISH_PLAN_ENDPOINT, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                planId: lastPlanQuery.planId,
                coachId: currentCoach.id
            })
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || 'Failed to submit plan');
        }

        const data = await response.json();
        console.log('‚úÖ Plan submitted to client:', data);

        // Update local status
        lastPlanQuery.status = 'published';

        // Update UI
        updatePlanStatusUI();

        // Show success message
        alert('Plan submitted to client successfully! They can now see this plan.');

    } catch (error) {
        console.error('Error submitting plan:', error);
        alert('Failed to submit plan: ' + error.message);
        submitBtn.innerHTML = originalText;
        submitBtn.disabled = false;
    }
}

// SAVE COACH PLAN TO DATABASE
async function saveCoachPlan(planData, clientName) {
    if (!currentCoach) {
        console.warn('No coach session - plan not saved to history');
        return false;
    }

    // Validate that clientId exists and is valid
    if (!planData.clientId || isNaN(planData.clientId) || planData.clientId <= 0) {
        console.error('‚ùå Cannot save plan: Invalid or missing clientId', planData.clientId);
        alert('‚ö†Ô∏è Error: Cannot save plan without a valid client selection. Please select a client and try again.');
        return false;
    }

    try {
        console.log('Saving plan to coach history...');

        const payload = {
            coachId: currentCoach.id,
            clientName: clientName,
            planData: planData,
            clientId: planData.clientId  // Always include clientId (validated above)
        };

        const response = await fetch(SAVE_COACH_PLAN_ENDPOINT, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error || 'Failed to save plan');
        }

        const data = await response.json();
        console.log('Plan saved to history with ID:', data.planId);

        // Store the planId and status in lastPlanQuery so it can be used when sharing
        if (lastPlanQuery) {
            lastPlanQuery.planId = data.planId;
            lastPlanQuery.status = data.status || 'draft';
            console.log('‚úÖ Plan ID stored for sharing:', data.planId, 'Status:', lastPlanQuery.status);

            // Update the UI to show draft status
            updatePlanStatusUI();

            // Hide retry button if it was showing
            hideSaveRetryButton();

            // Clear unsaved changes flag
            clearUnsavedChanges();
        }

        return true; // Return success

    } catch (error) {
        console.error('Error saving plan:', error);
        // Show error to user so they know save failed
        console.error('‚ö†Ô∏è Plan save failed - user will need to retry');
        return false;
    }
}

// SAVE COACH NOTES TO PLAN
async function saveCoachNotes() {
    if (!currentCoach || !lastPlanQuery.planId) {
        alert('Please generate a plan first before saving notes.');
        return;
    }

    const notesInput = document.getElementById('coachNotesInput');
    const saveBtn = document.getElementById('saveNotesBtn');
    const notes = notesInput.value.trim();

    const originalText = saveBtn.textContent;
    saveBtn.textContent = 'Saving...';
    saveBtn.disabled = true;

    try {
        const response = await fetch(UPDATE_PLAN_NOTES_ENDPOINT, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                planId: lastPlanQuery.planId,
                coachId: currentCoach.id,
                notes: notes || null
            })
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || 'Failed to save notes');
        }

        console.log('‚úÖ Coach notes saved successfully');
        saveBtn.textContent = 'Saved!';
        saveBtn.style.background = '#28a745';
        saveBtn.style.color = 'white';

        setTimeout(() => {
            saveBtn.textContent = originalText;
            saveBtn.style.background = '';
            saveBtn.style.color = '';
            saveBtn.disabled = false;
        }, 2000);

    } catch (error) {
        console.error('Error saving notes:', error);
        alert('Failed to save notes: ' + error.message);
        saveBtn.textContent = originalText;
        saveBtn.disabled = false;
    }
}

// SAVE MEAL NOTE (per-meal coaching note)
async function saveMealNote(dayIndex, mealIndex) {
    const noteTextarea = document.getElementById(`meal-note-${dayIndex}-${mealIndex}`);
    const note = noteTextarea.value.trim();
    const saveBtn = event.target;

    // Update the meal's coach_note in the local data
    if (lastPlanQuery.currentPlan && lastPlanQuery.currentPlan[dayIndex] && lastPlanQuery.currentPlan[dayIndex].plan[mealIndex]) {
        lastPlanQuery.currentPlan[dayIndex].plan[mealIndex].coach_note = note;
    }

    // If plan is saved to database, update it
    if (!lastPlanQuery.planId) {
        // Plan not saved yet - just save locally and show feedback
        saveBtn.textContent = 'Saved!';
        saveBtn.style.background = '#28a745';
        setTimeout(() => {
            saveBtn.textContent = 'Save';
            saveBtn.style.background = '#f59e0b';
        }, 1500);
        return;
    }

    const originalText = saveBtn.textContent;
    saveBtn.textContent = '...';
    saveBtn.disabled = true;

    try {
        // Update the plan data in database with the new note
        const response = await fetch(UPDATE_PLAN_NOTES_ENDPOINT, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                planId: lastPlanQuery.planId,
                coachId: currentCoach.id,
                planData: lastPlanQuery  // Send full plan data including nutrition info
            })
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || 'Failed to save note');
        }

        console.log(`‚úÖ Meal note saved for Day ${dayIndex + 1}, Meal ${mealIndex + 1}`);
        saveBtn.textContent = 'Saved!';
        saveBtn.style.background = '#28a745';

        setTimeout(() => {
            saveBtn.textContent = originalText;
            saveBtn.style.background = '#f59e0b';
            saveBtn.disabled = false;
        }, 1500);

    } catch (error) {
        console.error('Error saving meal note:', error);
        alert('Failed to save note: ' + error.message);
        saveBtn.textContent = originalText;
        saveBtn.disabled = false;
    }
}

// RECIPE GENERATOR
async function getAIRecipe(mealName) {
    console.log('üìñ Getting recipe for:', mealName);
    const modal = document.getElementById('recipe-modal');
    const content = document.getElementById('recipe-content');

    if (!modal || !content) {
        console.error('‚ùå Recipe modal elements not found in DOM');
        alert('Error: Recipe modal not found. Please refresh the page.');
        return;
    }

    document.getElementById('recipe-title').innerText = mealName;
    modal.classList.remove('hidden');
    content.innerHTML = '<div class="loader"><div class="loader-spinner"></div></div>';

    try {
        const prompt = `Recipe for "${mealName}". Use markdown with ### Ingredients and ### Instructions headings.`;
        const recipe = await callGemini(prompt, false);

        if (recipe.error) {
            content.innerHTML = `<p class="text-red-500">${recipe.error}</p>`;
        } else if (typeof recipe !== 'string') {
            console.error('‚ùå Recipe response is not a string:', typeof recipe, recipe);
            content.innerHTML = '<p class="text-red-500">Error: Invalid recipe format received. Please try again.</p>';
        } else {
            console.log('‚úÖ Recipe generated successfully');
            let html = recipe
                .replace(/^### (.*$)/gim, '<h3>$1</h3>')
                .replace(/^\* (.*$)/gim, '<li>$1</li>')
                .replace(/^(\d+)\. (.*$)/gim, '<li>$2</li>')
                .replace(/<\/li>\n<li>/g, '</li><li>');

            html = html.replace(/(<li>.*<\/li>)/gs, (match) => {
                if(match.toLowerCase().includes('ingredient')) return `<ul>${match}</ul>`;
                return `<ol>${match}</ol>`;
            });

            content.innerHTML = html;
        }
    } catch (error) {
        console.error('‚ùå Error generating recipe:', error);
        content.innerHTML = `<p class="text-red-500">Error generating recipe: ${error.message}. Please try again.</p>`;
    }
}

// CHANGE MEAL - Generate a completely different meal
async function changeMeal(dayIndex, mealIndex) {
    const meal = lastPlanQuery.currentPlan[dayIndex].plan[mealIndex];

    // Save current meal state for undo functionality
    const stateKey = `${dayIndex}-${mealIndex}`;
    previousMealStates[stateKey] = JSON.parse(JSON.stringify(meal)); // Deep copy
    saveUndoStates(); // Persist to localStorage
    console.log(`üíæ Saved previous state for undo (change):`, previousMealStates[stateKey]);

    // IMPORTANT: Calculate CONSISTENT per-meal targets from daily nutrition
    // This prevents calorie drift after multiple exchanges
    const mealsPerDay = lastPlanQuery.currentPlan[dayIndex].plan.length || 3;
    const targetCalories = Math.round((lastPlanQuery.calories || 2000) / mealsPerDay);
    const targetProtein = Math.round((lastPlanQuery.protein || 150) / mealsPerDay);
    const targetCarbs = Math.round((lastPlanQuery.carbs || 200) / mealsPerDay);
    const targetFat = Math.round((lastPlanQuery.fat || 70) / mealsPerDay);

    console.log(`üéØ Exchange targets (from daily ${lastPlanQuery.calories}cal / ${mealsPerDay} meals): ${targetCalories}cal, ${targetProtein}P, ${targetCarbs}C, ${targetFat}F`);

    // Show loading
    displayDietPlan(lastPlanQuery.currentPlan);
    const mealCards = document.querySelectorAll('.meal-card');
    let cardIndex = 0;
    for (let d = 0; d < dayIndex; d++) {
        cardIndex += lastPlanQuery.currentPlan[d].plan.length;
    }
    cardIndex += mealIndex;
    const targetCard = mealCards[cardIndex];
    if (targetCard) {
        targetCard.innerHTML = '<div class="loader"><div class="loader-spinner"></div></div><p class="text-center">Generating different meal...</p>';
    }

    const aiPrompt = `Generate a COMPLETELY DIFFERENT ${meal.type} meal (NOT "${meal.name}").
Diet: ${lastPlanQuery.preference}
Macro Preference: ${lastPlanQuery.macroPreference}
Avoid: ${lastPlanQuery.allergies}
Disliked Foods: ${lastPlanQuery.dislikedFoods}
Preferred Foods: ${lastPlanQuery.preferredFoods}
Budget: ${lastPlanQuery.budget}
Available Equipment: ${lastPlanQuery.equipmentStr}

STRICT TARGET MACROS - the new meal MUST closely match:
- Calories: ${targetCalories} (stay within ¬±50 calories)
- Protein: ${targetProtein}g (stay within ¬±5g)
- Carbs: ${targetCarbs}g (stay within ¬±10g)
- Fat: ${targetFat}g (stay within ¬±5g)

Use ONLY foods from USDA database - you can choose from 200+ foods including:
Proteins: Chicken Breast, Salmon, Ground Turkey, Eggs, Shrimp, Tofu, Greek Yogurt
Carbs: Brown Rice, Quinoa, Sweet Potato, Oats, Whole Wheat Bread, Pasta
Fats: Olive Oil, Avocado, Almonds, Peanut Butter
Vegetables: Broccoli, Spinach, Bell Pepper, Asparagus, etc.

CRITICAL:
1. Return ingredients as ARRAY OF STRINGS with amounts in parentheses
2. DO NOT include calories/protein/carbs/fat - backend will calculate from database
3. Choose portions that CLOSELY MATCH the target macros - this is ESSENTIAL
4. If original meal was small (under 400 cal), keep new meal small. If large (over 600 cal), keep it large.
MEAL NAME FORMAT: Include ALL key ingredient portions inline in parentheses

EXAMPLE FORMAT:
{"type":"${meal.type}","name":"Grilled Chicken Breast (200g) with Quinoa (150g cooked) and Broccoli (100g)","ingredients":["Chicken Breast (200g)","Quinoa (150g cooked)","Broccoli (100g)","Olive Oil (1 tbsp)"],"instructions":"Grill chicken breast. Cook quinoa. Steam broccoli. Drizzle with olive oil."}

Return ONLY valid JSON. NO quotes in text - use apostrophes. Keep it brief.`;

    // Call backend with CONSISTENT targets (not current meal's drifted values)
    const mealTargets = {
        calories: targetCalories,
        protein: targetProtein,
        carbs: targetCarbs,
        fat: targetFat
    };

    const newMeal = await callGemini(aiPrompt, true, mealTargets, null, 1);

    if (!newMeal.error) {
        // Validate that backend returned complete meal with macros
        if (!newMeal.calories || !newMeal.protein || !newMeal.carbs || newMeal.fat === undefined) {
            console.error('‚ùå Backend returned incomplete meal:', newMeal);
            alert('Error: Backend did not calculate macros. Check console for details.');
            displayDietPlan(lastPlanQuery.currentPlan);
            return;
        }

        // Backend calculated accurate macros - use them directly
        lastPlanQuery.currentPlan[dayIndex].plan[mealIndex] = newMeal;

        // Auto-save if plan already exists in database
        if (lastPlanQuery.planId) {
            saveCoachPlan();
        }

        displayDietPlan(lastPlanQuery.currentPlan);
    } else {
        alert('Error changing meal: ' + newMeal.error);
        displayDietPlan(lastPlanQuery.currentPlan);
    }
}

// REVISE MEAL - Custom user modifications
async function reviseMeal(dayIndex, mealIndex) {
    const meal = lastPlanQuery.currentPlan[dayIndex].plan[mealIndex];
    const userRequest = window.prompt(`Revise "${meal.name}"?\n\nEnter your specific request (e.g., "make it vegetarian", "swap rice for sweet potato", "just protein shake with creatine"):`, '');

    if (!userRequest || !userRequest.trim()) return;

    // Save current meal state for undo functionality
    const stateKey = `${dayIndex}-${mealIndex}`;
    previousMealStates[stateKey] = JSON.parse(JSON.stringify(meal)); // Deep copy
    saveUndoStates(); // Persist to localStorage
    console.log(`üíæ Saved previous state for undo (revise):`, previousMealStates[stateKey]);

    // Show loading
    displayDietPlan(lastPlanQuery.currentPlan);
    const mealCards = document.querySelectorAll('.meal-card');
    let cardIndex = 0;
    for (let d = 0; d < dayIndex; d++) {
        cardIndex += lastPlanQuery.currentPlan[d].plan.length;
    }
    cardIndex += mealIndex;
    const targetCard = mealCards[cardIndex];
    if (targetCard) {
        targetCard.innerHTML = '<div class="loader"><div class="loader-spinner"></div></div><p class="text-center">Revising meal...</p>';
    }

    const aiPrompt = `Revise this meal based on user request: "${meal.name}" (${meal.type})

USER REQUEST: ${userRequest}

CURRENT MEAL:
- Calories: ${meal.calories}
- Protein: ${meal.protein}g
- Carbs: ${meal.carbs}g
- Fat: ${meal.fat}g
- Ingredients: ${meal.ingredients ? meal.ingredients.map(ing => typeof ing === 'string' ? ing : `${ing.amount} ${ing.food}`).join(', ') : 'N/A'}

REVISION RULES - Follow these carefully:

1. EXPLICIT AMOUNTS: If user specifies exact amount (e.g., "make salmon 200g", "use 2 eggs"),
   use EXACTLY that amount even if it changes the meal's total calories.

2. VAGUE INCREASE: If user says "increase salmon" or "more protein" (no specific amount),
   increase by a reasonable amount (~30-50%) AND reduce other ingredients to keep total calories similar.

3. SWAP INGREDIENT: If user says "swap salmon for chicken" or "replace rice with quinoa",
   calculate the NEW ingredient amount to match the CALORIES of the original ingredient.
   Example: 130g salmon (230 cal) ‚Üí ~140g chicken breast to match ~230 cal

4. ADD NEW INGREDIENT: If user says "add chicken" to a meal that has none,
   ADD it on top - the meal will be bigger. Don't reduce other ingredients.

5. COMPLETE REPLACEMENT: If user specifies an entirely new meal or uses words like
   "just", "only", "make it", "change to", or "replace with", use ONLY the ingredients
   they specify. Do NOT add extra ingredients to match the original meal's calories.
   The new calorie total will be whatever the specified ingredients naturally add up to.
   Example: "just a protein shake with creatine" = ONLY protein powder + creatine, nothing else.

Diet: ${lastPlanQuery.preference}
Macro Preference: ${lastPlanQuery.macroPreference}
Avoid: ${lastPlanQuery.allergies}
Disliked Foods: ${lastPlanQuery.dislikedFoods}
Preferred Foods: ${lastPlanQuery.preferredFoods}
Budget: ${lastPlanQuery.budget}
Available Equipment: ${lastPlanQuery.equipmentStr}

Use ONLY foods from USDA database - you can choose from 200+ foods including:
Proteins: Chicken Breast, Salmon, Ground Turkey, Eggs, Shrimp, Tofu, Greek Yogurt
Carbs: Brown Rice, Quinoa, Sweet Potato, Oats, Whole Wheat Bread, Pasta
Fats: Olive Oil, Avocado, Almonds, Peanut Butter
Vegetables: Broccoli, Spinach, Bell Pepper, Asparagus, etc.

CRITICAL:
1. Return ingredients as ARRAY OF STRINGS with amounts in parentheses
2. DO NOT include calories/protein/carbs/fat - backend will calculate from database
MEAL NAME FORMAT: Include ALL key ingredient portions inline in parentheses

EXAMPLE FORMAT:
{"type":"${meal.type}","name":"Baked Turkey Breast (200g) with Sweet Potato (150g) and Green Beans (100g)","ingredients":["Turkey Breast (200g)","Sweet Potato (150g)","Green Beans (100g)","Olive Oil (1 tsp)"],"instructions":"Bake turkey at 375F for 25 mins. Roast sweet potato. Steam green beans."}

Return ONLY valid JSON. NO quotes in text - use apostrophes. Keep it brief.`;

    // Pass current meal macros as targets, with skipAutoScale for revisions
    const mealTargets = {
        calories: meal.calories,
        protein: meal.protein,
        carbs: meal.carbs,
        fat: meal.fat
    };

    const revisedMeal = await callGemini(aiPrompt, true, mealTargets, null, 1, true); // true = skipAutoScale

    if (!revisedMeal.error) {
        // Validate that backend returned complete meal with macros
        if (!revisedMeal.calories || !revisedMeal.protein || !revisedMeal.carbs || revisedMeal.fat === undefined) {
            console.error('‚ùå Backend returned incomplete meal:', revisedMeal);
            alert('Error: Backend did not calculate macros. Check console for details.');
            displayDietPlan(lastPlanQuery.currentPlan);
            return;
        }

        // Backend calculated accurate macros - use them directly
        lastPlanQuery.currentPlan[dayIndex].plan[mealIndex] = revisedMeal;

        // Auto-save if plan already exists in database
        if (lastPlanQuery.planId) {
            saveCoachPlan();
        }

        displayDietPlan(lastPlanQuery.currentPlan);
    } else {
        alert('Error revising meal: ' + revisedMeal.error);
        displayDietPlan(lastPlanQuery.currentPlan);
    }
}

// UNDO MEAL - Restore previous meal state
function undoMeal(dayIndex, mealIndex) {
    const stateKey = `${dayIndex}-${mealIndex}`;
    const previousState = previousMealStates[stateKey];

    if (!previousState) {
        alert('No previous state to undo');
        return;
    }

    console.log(`‚Ü©Ô∏è Undoing meal change for ${stateKey}:`, previousState);

    // Restore the previous meal state
    lastPlanQuery.currentPlan[dayIndex].plan[mealIndex] = JSON.parse(JSON.stringify(previousState));

    // Remove the undo state (can only undo once)
    delete previousMealStates[stateKey];
    saveUndoStates(); // Persist to localStorage

    // Auto-save if plan already exists in database
    if (lastPlanQuery.planId) {
        saveCoachPlan();
    }

    // Re-render the plan
    displayDietPlan(lastPlanQuery.currentPlan);

    // Show success message
    alert('Undo successful! Meal restored to previous state.');
}

// ========================================
// CUSTOM MEAL MODAL FUNCTIONALITY
// ========================================

// State for custom meal modal
let customMealDayIndex = null;
let customMealMealIndex = null;
let customMealSelectedIngredients = [];
let foodSearchTimeout = null;
let foodSearchResults = [];
const FOOD_SEARCH_ENDPOINT = '/.netlify/functions/usda-search';

// CUSTOM MEAL - Opens the modal instead of prompt
function customMeal(dayIndex, mealIndex) {
    customMealDayIndex = dayIndex;
    customMealMealIndex = mealIndex;
    customMealSelectedIngredients = [];

    // Reset modal state
    document.getElementById('foodSearchInput').value = '';
    document.getElementById('foodSearchResults').classList.remove('active');
    document.getElementById('foodSearchResults').innerHTML = '';
    document.getElementById('calculatedMealName').value = '';
    document.getElementById('manualMealName').value = '';
    document.getElementById('manualCalories').value = '';
    document.getElementById('manualProtein').value = '';
    document.getElementById('manualCarbs').value = '';
    document.getElementById('manualFat').value = '';
    document.getElementById('manualInstructions').value = '';

    // Reset to calculate tab
    switchCustomMealTab('calculate');

    // Update UI
    renderCustomMealIngredients();
    updateCustomMealTotals();

    // Show modal
    document.getElementById('customMealModal').classList.add('show');
}

function closeCustomMealModal() {
    document.getElementById('customMealModal').classList.remove('show');
    customMealDayIndex = null;
    customMealMealIndex = null;
    customMealSelectedIngredients = [];

    // Reset form fields
    document.getElementById('foodSearchInput').value = '';
    document.getElementById('foodSearchResults').classList.remove('active');
    document.getElementById('calculatedMealName').value = '';
    document.getElementById('manualMealName').value = '';
    document.getElementById('manualCalories').value = '';
    document.getElementById('manualProtein').value = '';
    document.getElementById('manualCarbs').value = '';
    document.getElementById('manualFat').value = '';
    document.getElementById('manualInstructions').value = '';

    // Reset save for later checkboxes
    document.getElementById('saveCalculatedForLater').checked = false;
    document.getElementById('saveManualForLater').checked = false;

    // Reset to first tab
    switchCustomMealTab('calculate');
}

function switchCustomMealTab(tab) {
    // Update tab active states
    document.querySelectorAll('.custom-meal-tab').forEach((t, i) => {
        t.classList.toggle('active',
            (tab === 'calculate' && i === 0) ||
            (tab === 'manual' && i === 1) ||
            (tab === 'saved' && i === 2)
        );
    });

    // Update panel visibility
    document.getElementById('calculatePanel').classList.toggle('active', tab === 'calculate');
    document.getElementById('manualPanel').classList.toggle('active', tab === 'manual');
    document.getElementById('savedPanel').classList.toggle('active', tab === 'saved');

    // Render saved meals when switching to saved tab
    if (tab === 'saved') {
        renderSavedMeals();
    }
}

// Saved Meals Management
const SAVED_MEALS_KEY = 'savedCustomMeals';

function getSavedMeals() {
    try {
        const saved = localStorage.getItem(SAVED_MEALS_KEY);
        return saved ? JSON.parse(saved) : [];
    } catch (e) {
        console.error('Error loading saved meals:', e);
        return [];
    }
}

function saveMealToLibrary(meal) {
    const savedMeals = getSavedMeals();
    const mealWithId = {
        ...meal,
        id: Date.now().toString(),
        savedAt: new Date().toISOString()
    };
    savedMeals.unshift(mealWithId); // Add to beginning
    localStorage.setItem(SAVED_MEALS_KEY, JSON.stringify(savedMeals));
    console.log('üíæ Meal saved to library:', mealWithId.name);
    return mealWithId;
}

function deleteSavedMeal(mealId) {
    const savedMeals = getSavedMeals();
    const filtered = savedMeals.filter(m => m.id !== mealId);
    localStorage.setItem(SAVED_MEALS_KEY, JSON.stringify(filtered));
    renderSavedMeals();
    console.log('üóëÔ∏è Meal deleted from library:', mealId);
}

function useSavedMeal(mealId) {
    const savedMeals = getSavedMeals();
    const meal = savedMeals.find(m => m.id === mealId);
    if (!meal) {
        alert('Meal not found');
        return;
    }

    // Get meal type from original meal
    const originalMeal = lastPlanQuery.currentPlan[customMealDayIndex].plan[customMealMealIndex];
    const mealType = originalMeal.type || 'meal';

    // Save for undo
    const stateKey = `${customMealDayIndex}-${customMealMealIndex}`;
    previousMealStates[stateKey] = JSON.parse(JSON.stringify(originalMeal));
    saveUndoStates(); // Persist to localStorage

    // Create the meal (without id and savedAt)
    const newMeal = {
        type: mealType,
        name: meal.name,
        ingredients: meal.ingredients,
        calories: meal.calories,
        protein: meal.protein,
        carbs: meal.carbs,
        fat: meal.fat,
        instructions: meal.instructions || 'Prepare as desired.',
        source: meal.source || 'Saved Meal',
        isCustom: true
    };

    // Update the meal in the plan
    lastPlanQuery.currentPlan[customMealDayIndex].plan[customMealMealIndex] = newMeal;

    // Auto-save if plan already exists
    if (lastPlanQuery.planId) {
        saveCoachPlan();
    }

    // Close modal and refresh display
    closeCustomMealModal();
    displayDietPlan(lastPlanQuery.currentPlan);
    console.log('‚úÖ Used saved meal:', newMeal.name);
}

function renderSavedMeals() {
    const container = document.getElementById('savedMealsList');
    const savedMeals = getSavedMeals();

    if (savedMeals.length === 0) {
        container.innerHTML = '<div class="no-saved-meals">No saved meals yet. Create a meal and check "Save for future use" to add it here.</div>';
        return;
    }

    container.innerHTML = savedMeals.map(meal => `
        <div class="saved-meal-item">
            <div class="saved-meal-info">
                <div class="saved-meal-name">${escapeHtmlCustomMeal(meal.name)}</div>
                <div class="saved-meal-macros">${meal.calories} cal | ${meal.protein}g P | ${meal.carbs}g C | ${meal.fat}g F</div>
            </div>
            <div class="saved-meal-actions">
                <button class="btn-use-saved" onclick="useSavedMeal('${meal.id}')">Use</button>
                <button class="btn-delete-saved" onclick="deleteSavedMeal('${meal.id}')">üóëÔ∏è</button>
            </div>
        </div>
    `).join('');
}

// Food search functionality
function handleFoodSearch(query) {
    const resultsDiv = document.getElementById('foodSearchResults');

    if (foodSearchTimeout) {
        clearTimeout(foodSearchTimeout);
    }

    if (!query || query.trim().length < 2) {
        resultsDiv.classList.remove('active');
        resultsDiv.innerHTML = '';
        foodSearchResults = [];
        return;
    }

    // Show loading state
    resultsDiv.classList.add('active');
    resultsDiv.innerHTML = '<div class="food-search-loading">Searching foods...</div>';

    // Debounce the search
    foodSearchTimeout = setTimeout(async () => {
        try {
            const response = await fetch(`${FOOD_SEARCH_ENDPOINT}?query=${encodeURIComponent(query)}`);
            const data = await response.json();

            if (!response.ok) {
                throw new Error(data.error || 'Search failed');
            }

            if (data.foods && data.foods.length > 0) {
                foodSearchResults = data.foods;

                resultsDiv.innerHTML = data.foods.map((food, index) => {
                    let macroDisplay;
                    if (food.servingSize && food.caloriesPerServing !== undefined) {
                        macroDisplay = `${escapeHtmlCustomMeal(food.servingSize)}: ${food.caloriesPerServing} cal | ${food.proteinPerServing}g P | ${food.carbsPerServing}g C | ${food.fatPerServing}g F`;
                    } else {
                        macroDisplay = `Per 100g: ${food.caloriesPer100g} cal | ${food.proteinPer100g}g P | ${food.carbsPer100g}g C | ${food.fatPer100g}g F`;
                    }

                    return `
                    <div class="food-search-item" onclick="selectFoodItem(${index})">
                        <div class="food-name">${escapeHtmlCustomMeal(food.name)}${food.brand ? ` <span style="color: #888; font-size: 12px;">(${escapeHtmlCustomMeal(food.brand)})</span>` : ''}</div>
                        <div class="food-macros">${macroDisplay}</div>
                    </div>
                `}).join('');
            } else {
                foodSearchResults = [];
                resultsDiv.innerHTML = '<div class="food-search-empty">No foods found. Try a different search term.</div>';
            }
        } catch (error) {
            console.error('Food search error:', error);
            foodSearchResults = [];
            resultsDiv.innerHTML = '<div class="food-search-empty">Search failed. Please try again.</div>';
        }
    }, 300);
}

function escapeHtmlCustomMeal(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function selectFoodItem(index) {
    const food = foodSearchResults[index];
    if (!food) return;

    // Use serving size if available, otherwise default to 100g
    const hasServing = food.servingSize && food.servingGrams;
    const defaultQty = hasServing ? food.servingGrams : 100;

    customMealSelectedIngredients.push({
        fdcId: food.fdcId,
        name: food.name,
        quantity: defaultQty,
        caloriesPer100g: food.caloriesPer100g,
        proteinPer100g: food.proteinPer100g,
        carbsPer100g: food.carbsPer100g,
        fatPer100g: food.fatPer100g,
        servingSize: food.servingSize || null,
        servingGrams: food.servingGrams || null
    });

    // Clear search
    document.getElementById('foodSearchInput').value = '';
    document.getElementById('foodSearchResults').classList.remove('active');
    document.getElementById('foodSearchResults').innerHTML = '';

    // Update UI
    renderCustomMealIngredients();
    updateCustomMealTotals();
}

function removeCustomMealIngredient(index) {
    customMealSelectedIngredients.splice(index, 1);
    renderCustomMealIngredients();
    updateCustomMealTotals();
}

function updateCustomMealIngredientQty(index, quantity) {
    const qty = parseFloat(quantity) || 0;
    customMealSelectedIngredients[index].quantity = qty;
    updateCustomMealTotals();
}

function renderCustomMealIngredients() {
    const listDiv = document.getElementById('ingredientsList');
    const countSpan = document.getElementById('ingredientCount');

    countSpan.textContent = `(${customMealSelectedIngredients.length})`;

    if (customMealSelectedIngredients.length === 0) {
        listDiv.innerHTML = '<div class="no-ingredients">No ingredients added yet</div>';
        return;
    }

    listDiv.innerHTML = customMealSelectedIngredients.map((ing, index) => {
        const servingHint = ing.servingSize ? ` (${ing.servingSize} = ${ing.servingGrams}g)` : '';
        const titleText = `${escapeHtmlCustomMeal(ing.name)}${servingHint}`;
        const displayName = ing.name.length > 25 ? ing.name.substring(0, 22) + '...' : ing.name;

        return `
        <div class="ingredient-item">
            <span class="ingredient-name" title="${titleText}">${escapeHtmlCustomMeal(displayName)}</span>
            <input type="number" class="ingredient-qty" value="${ing.quantity}" min="1"
                   onchange="updateCustomMealIngredientQty(${index}, this.value)"
                   onclick="event.stopPropagation()">
            <span class="ingredient-unit">g</span>
            <button class="ingredient-remove" onclick="removeCustomMealIngredient(${index})" title="Remove">√ó</button>
        </div>
    `}).join('');
}

function updateCustomMealTotals() {
    let totalCal = 0, totalProtein = 0, totalCarbs = 0, totalFat = 0;

    customMealSelectedIngredients.forEach(ing => {
        const factor = ing.quantity / 100;
        totalCal += ing.caloriesPer100g * factor;
        totalProtein += ing.proteinPer100g * factor;
        totalCarbs += ing.carbsPer100g * factor;
        totalFat += ing.fatPer100g * factor;
    });

    document.getElementById('totalCalories').textContent = Math.round(totalCal);
    document.getElementById('totalProtein').textContent = Math.round(totalProtein) + 'g';
    document.getElementById('totalCarbs').textContent = Math.round(totalCarbs) + 'g';
    document.getElementById('totalFat').textContent = Math.round(totalFat) + 'g';

    // Enable/disable create button
    const createBtn = document.getElementById('createCalculatedMealBtn');
    createBtn.disabled = customMealSelectedIngredients.length === 0;
}

async function submitCalculatedMeal() {
    if (customMealSelectedIngredients.length === 0) {
        alert('Please add at least one ingredient');
        return;
    }

    // Calculate totals
    let totalCal = 0, totalProtein = 0, totalCarbs = 0, totalFat = 0;
    const ingredients = [];

    customMealSelectedIngredients.forEach(ing => {
        const factor = ing.quantity / 100;
        totalCal += ing.caloriesPer100g * factor;
        totalProtein += ing.proteinPer100g * factor;
        totalCarbs += ing.carbsPer100g * factor;
        totalFat += ing.fatPer100g * factor;
        ingredients.push(`${ing.name} (${ing.quantity}g)`);
    });

    // Get meal name
    let mealName = document.getElementById('calculatedMealName').value.trim();
    if (!mealName) {
        mealName = ingredients.length <= 2
            ? ingredients.map(i => i.split(' (')[0]).join(' & ')
            : ingredients.slice(0, 2).map(i => i.split(' (')[0]).join(' & ') + ' + More';
    }

    // Get meal type from original meal
    const originalMeal = lastPlanQuery.currentPlan[customMealDayIndex].plan[customMealMealIndex];
    const mealType = originalMeal.type || 'meal';

    // Save for undo
    const stateKey = `${customMealDayIndex}-${customMealMealIndex}`;
    previousMealStates[stateKey] = JSON.parse(JSON.stringify(originalMeal));
    saveUndoStates(); // Persist to localStorage

    // Create the custom meal
    const customMealData = {
        type: mealType,
        name: mealName,
        ingredients: ingredients,
        calories: Math.round(totalCal),
        protein: Math.round(totalProtein),
        carbs: Math.round(totalCarbs),
        fat: Math.round(totalFat),
        instructions: 'Prepare as desired.',
        source: 'Food Database',
        isCustom: true
    };

    // Save to library if checkbox is checked
    const saveForLater = document.getElementById('saveCalculatedForLater').checked;
    if (saveForLater) {
        saveMealToLibrary(customMealData);
    }

    // Update the meal in the plan
    lastPlanQuery.currentPlan[customMealDayIndex].plan[customMealMealIndex] = customMealData;

    // Auto-save if plan already exists in database
    if (lastPlanQuery.planId) {
        saveCoachPlan();
    }

    // Close modal and refresh display
    closeCustomMealModal();
    displayDietPlan(lastPlanQuery.currentPlan);
    console.log('‚úÖ Custom meal created:', customMealData);
}

function submitManualMeal() {
    const mealName = document.getElementById('manualMealName').value.trim();
    const calories = parseInt(document.getElementById('manualCalories').value) || 0;
    const protein = parseInt(document.getElementById('manualProtein').value) || 0;
    const carbs = parseInt(document.getElementById('manualCarbs').value) || 0;
    const fat = parseInt(document.getElementById('manualFat').value) || 0;
    const instructions = document.getElementById('manualInstructions').value.trim() || 'Prepare as desired.';

    if (!mealName) {
        alert('Please enter a meal name');
        return;
    }

    if (calories === 0 && protein === 0 && carbs === 0 && fat === 0) {
        alert('Please enter at least some nutritional information');
        return;
    }

    // Validate macro math (calories should roughly equal P*4 + C*4 + F*9)
    if (calories > 0 && (protein > 0 || carbs > 0 || fat > 0)) {
        const calculatedCal = (protein * 4) + (carbs * 4) + (fat * 9);
        const variance = Math.abs(calories - calculatedCal);
        const variancePercent = (variance / calories) * 100;

        if (variancePercent > 25) {
            const proceed = confirm(
                `‚ö†Ô∏è Macro Math Check\n\n` +
                `Entered: ${calories} calories\n` +
                `Calculated from macros: ${calculatedCal} cal\n` +
                `(Protein√ó4 + Carbs√ó4 + Fat√ó9)\n\n` +
                `Difference: ${variance} cal (${Math.round(variancePercent)}%)\n\n` +
                `This seems off. Continue anyway?`
            );
            if (!proceed) return;
        }
    }

    // Get meal type from original meal
    const originalMeal = lastPlanQuery.currentPlan[customMealDayIndex].plan[customMealMealIndex];
    const mealType = originalMeal.type || 'meal';

    // Save for undo
    const stateKey = `${customMealDayIndex}-${customMealMealIndex}`;
    previousMealStates[stateKey] = JSON.parse(JSON.stringify(originalMeal));
    saveUndoStates(); // Persist to localStorage

    // Create the custom meal
    const customMealData = {
        type: mealType,
        name: mealName,
        ingredients: [mealName],
        calories: calories,
        protein: protein,
        carbs: carbs,
        fat: fat,
        instructions: instructions,
        source: 'Manual Entry',
        isCustom: true
    };

    // Save to library if checkbox is checked
    const saveForLater = document.getElementById('saveManualForLater').checked;
    if (saveForLater) {
        saveMealToLibrary(customMealData);
    }

    // Update the meal in the plan
    lastPlanQuery.currentPlan[customMealDayIndex].plan[customMealMealIndex] = customMealData;

    // Auto-save if plan already exists in database
    if (lastPlanQuery.planId) {
        saveCoachPlan();
    }

    // Close modal and refresh display
    closeCustomMealModal();
    displayDietPlan(lastPlanQuery.currentPlan);
    console.log('‚úÖ Manual meal created:', customMealData);
}

// REGENERATE ENTIRE DAY - Generate all new meals for a specific day
async function regenerateDay(dayIndex) {
    const dayData = lastPlanQuery.currentPlan[dayIndex];
    const dayNumber = dayData.day;

    // Filter out supplements and custom meals - they are preserved
    const mealsToRegenerate = dayData.plan.filter(m => m.type !== 'supplement' && !m.isCustom);
    const supplementItem = dayData.plan.find(m => m.type === 'supplement');
    const customMeals = dayData.plan.filter(m => m.isCustom);

    // If all meals are custom, nothing to regenerate
    if (mealsToRegenerate.length === 0) {
        alert('All meals in this day are custom meals. Nothing to regenerate!');
        return;
    }

    // Calculate targets for meals to regenerate (subtract custom meal macros)
    let customCalories = 0, customProtein = 0, customCarbs = 0, customFat = 0;
    customMeals.forEach(m => {
        customCalories += m.calories || 0;
        customProtein += m.protein || 0;
        customCarbs += m.carbs || 0;
        customFat += m.fat || 0;
    });

    const numMeals = mealsToRegenerate.length;
    const targets = {
        calories: Math.max(0, dayData.targets.calories - customCalories),
        protein: Math.max(0, dayData.targets.protein - customProtein),
        carbs: Math.max(0, dayData.targets.carbs - customCarbs),
        fat: Math.max(0, dayData.targets.fat - customFat)
    };

    if (customMeals.length > 0) {
        console.log(`üìå Preserving ${customMeals.length} custom meal(s), regenerating ${numMeals} meal(s)`);
    }

    // Get meal structure from meals to regenerate (excluding supplements and custom)
    const mealTypes = mealsToRegenerate.map(m => m.type);
    let mealStructure = '';
    let expectedMealTypes = mealTypes;

    if (mealTypes.filter(t => t === 'snack').length === 1) {
        mealStructure = `EXACTLY ${numMeals} items: ${mealTypes.join(', ')}`;
    } else if (mealTypes.filter(t => t === 'snack').length === 2) {
        mealStructure = `EXACTLY ${numMeals} items: ${mealTypes.join(', ')}`;
    } else if (mealTypes.filter(t => t === 'snack').length === 3) {
        mealStructure = `EXACTLY ${numMeals} items: ${mealTypes.join(', ')}`;
    } else {
        mealStructure = `EXACTLY ${numMeals} items: ${mealTypes.join(', ')}`;
    }

    // Show loading state
    displayDietPlan(lastPlanQuery.currentPlan);

    // Find the day section and show loading
    const dayDividers = document.querySelectorAll('.day-divider');
    if (dayDividers[dayIndex]) {
        const daySection = dayDividers[dayIndex].parentElement;
        // Get all meal cards after this day divider until the next day divider
        let currentElement = dayDividers[dayIndex].nextElementSibling; // Skip the totals div
        if (currentElement) currentElement = currentElement.nextElementSibling; // Move to first meal

        while (currentElement && !currentElement.classList.contains('day-divider')) {
            if (currentElement.classList.contains('meal-card')) {
                currentElement.innerHTML = '<div class="loader"><div class="loader-spinner"></div></div><p class="text-center text-sm">Regenerating day...</p>';
            }
            currentElement = currentElement.nextElementSibling;
        }
    }

    // Build list of meals from other days to avoid repetition
    let otherDaysMeals = [];
    lastPlanQuery.currentPlan.forEach((d, idx) => {
        if (idx !== dayIndex) {
            d.plan.forEach(meal => {
                otherDaysMeals.push(meal.name);
            });
        }
    });
    const previousMealsText = otherDaysMeals.length > 0
        ? `\n\nDO NOT repeat these meals from other days: ${otherDaysMeals.join(', ')}`
        : '';

    const dayPrompt = `Create 1-day meal plan for Day ${dayNumber} (REGENERATING - must be COMPLETELY DIFFERENT).
Stats: ${lastPlanQuery.age}yo ${lastPlanQuery.gender}, ${lastPlanQuery.weight}kg, ${lastPlanQuery.height}cm
Goal: ${lastPlanQuery.goal}, Diet: ${lastPlanQuery.preference}
Macro Preference: ${lastPlanQuery.macroPreference}
Avoid: ${lastPlanQuery.allergies}
Disliked Foods: ${lastPlanQuery.dislikedFoods}
Preferred Foods/Cuisines: ${lastPlanQuery.preferredFoods}
Budget: ${lastPlanQuery.budget}
Available Equipment: ${lastPlanQuery.equipmentStr}${previousMealsText}

Daily targets: ${targets.calories} cal, ${targets.protein}g protein, ${targets.carbs}g carbs, ${targets.fat}g fat

CRITICAL TARGET REQUIREMENT:
Your meals MUST add up to approximately these daily targets. This is NOT optional.
- Acceptable variance: ¬±10% for calories, ¬±15% for macros
- Each meal should average ~${Math.round(targets.calories / numMeals)} calories

CRITICAL MEAL STRUCTURE:
Generate ${mealStructure}. DO NOT generate more or fewer items.
The array should have EXACTLY ${numMeals} objects.

Use ONLY foods from USDA database including:
Proteins: Chicken Breast, Salmon, Ground Turkey, Eggs, Shrimp, Tofu, Greek Yogurt
Carbs: Brown Rice, Quinoa, Sweet Potato, Oats, Whole Wheat Bread, Pasta
Fats: Olive Oil, Avocado, Almonds, Peanut Butter
Vegetables: Broccoli, Spinach, Bell Pepper, Asparagus, etc.

CRITICAL: Return ingredients as ARRAY OF STRINGS in natural language format.
Include food name AND amount in parentheses.
DO NOT include calories/protein/carbs/fat - backend will calculate from database.
MEAL NAME FORMAT: Include ALL key ingredient portions inline in parentheses

Return ONLY valid JSON array of ${numMeals} meal objects. Each object must have:
{"type":"meal_type","name":"Meal Name (portions)","ingredients":["Item (amount)",...],"instructions":"Brief cooking steps"}

NO markdown, NO backticks, NO extra text. ONLY the JSON array.`;

    try {
        const result = await callGemini(dayPrompt, true, targets, expectedMealTypes, numMeals);

        if (result.error) {
            alert('Error regenerating day: ' + result.error);
            displayDietPlan(lastPlanQuery.currentPlan);
            return;
        }

        // Result should be an array of meals
        let newMeals = Array.isArray(result) ? result : [result];

        // Validate we got the right number of meals
        if (newMeals.length !== numMeals) {
            console.warn(`Expected ${numMeals} meals, got ${newMeals.length}. Using what we got.`);
        }

        // Add back custom meals (preserved)
        if (customMeals.length > 0) {
            newMeals = [...newMeals, ...customMeals];
            console.log(`üìå Restored ${customMeals.length} custom meal(s) to Day ${dayNumber}`);
        }

        // Add back the supplement if there was one
        if (supplementItem) {
            newMeals.push(supplementItem);
            console.log(`‚úÖ Re-added protein powder supplement to Day ${dayNumber}`);
        }

        // Update the day's meals
        lastPlanQuery.currentPlan[dayIndex].plan = newMeals;

        // Auto-save if plan already exists in database
        if (lastPlanQuery.planId) {
            saveCoachPlan();
        }

        // Refresh the display
        displayDietPlan(lastPlanQuery.currentPlan);

        console.log(`‚úÖ Day ${dayNumber} regenerated successfully`);

    } catch (error) {
        console.error('Error regenerating day:', error);
        alert('Error regenerating day. Please try again.');
        displayDietPlan(lastPlanQuery.currentPlan);
    }
}

// GROCERY LIST AGGREGATION

// Helper function to parse fractions and mixed numbers
function parseFraction(str) {
    // Handle mixed numbers like "1 1/2" or "2 3/4"
    const mixedMatch = str.match(/(\d+)\s+(\d+)\/(\d+)/);
    if (mixedMatch) {
        const whole = parseInt(mixedMatch[1]);
        const numerator = parseInt(mixedMatch[2]);
        const denominator = parseInt(mixedMatch[3]);
        return whole + (numerator / denominator);
    }

    // Handle simple fractions like "1/2" or "3/4"
    const fractionMatch = str.match(/(\d+)\/(\d+)/);
    if (fractionMatch) {
        const numerator = parseInt(fractionMatch[1]);
        const denominator = parseInt(fractionMatch[2]);
        return numerator / denominator;
    }

    // Handle decimals like "1.5" or whole numbers like "2"
    return parseFloat(str) || 0;
}

function parseIngredient(ingredientStr) {
    // NEW FORMAT: "Food Name (amount)" - e.g., "Chicken Breast (200g)" or "Eggs (2 whole)"
    // Pattern 1: "Food Name (quantity unit)" - e.g., "Chicken Breast (200g)" or "Olive Oil (1 tbsp)"
    const parenthesesPattern = /^(.+?)\s*\(([\d\s\/\.]+)\s*(oz|ounces?|pounds?|lbs?|g|grams?|kg|cups?|tbsp|tsp|teaspoons?|tablespoons?|pieces?|medium|large|small|whole|slices?|scoops?|servings?|dry|cooked|ml|l|liters?)?\)$/i;
    const parenthesesMatch = ingredientStr.match(parenthesesPattern);

    if (parenthesesMatch) {
        const name = parenthesesMatch[1].trim();
        const quantityStr = parenthesesMatch[2].trim();
        const quantity = parseFraction(quantityStr);
        const unit = (parenthesesMatch[3] || 'unit').toLowerCase();

        // Filter out descriptors like "dry", "cooked", and non-measurement units
        const filteredUnit = ['dry', 'cooked', 'whole'].includes(unit) ? 'unit' : unit;

        return {
            quantity: quantity,
            unit: filteredUnit,
            name: name.toLowerCase().trim()
        };
    }

    // OLD FORMAT FALLBACK: "quantity unit food" - e.g., "200g chicken breast" or "2 eggs"
    const patterns = [
        // Pattern 1: Fractions or decimals with units - e.g., "1/4 cup" or "1 1/2 cups" or "2.5 tbsp"
        /([\d\s\/\.]+)\s*(oz|ounces?|pounds?|lbs?|g|grams?|kg|cups?|tbsp|tsp|teaspoons?|tablespoons?|pieces?|medium|large|small|scoops?|servings?)\s+(.+)/i,
        // Pattern 2: Just number with rest of string - e.g., "2 bananas"
        /([\d\s\/\.]+)\s+(.+)/i
    ];

    for (const pattern of patterns) {
        const match = ingredientStr.match(pattern);
        if (match) {
            // Parse the quantity (handles fractions, mixed numbers, decimals)
            const quantityStr = match[1].trim();
            const quantity = parseFraction(quantityStr);

            return {
                quantity: quantity,
                unit: (match[2] || 'unit').toLowerCase(),
                name: (match[3] || match[2] || ingredientStr).toLowerCase().trim()
            };
        }
    }
    return { quantity: 1, unit: 'unit', name: ingredientStr.toLowerCase().trim() };
}

function normalizeUnit(quantity, unit) {
    // Normalize unit names and keep quantities in their original units
    // Group similar units together for aggregation
    const unitNormalization = {
        // Weight units - keep in grams
        'g': 'g',
        'gram': 'g',
        'grams': 'g',
        'kg': 'g', // Convert kg to g for aggregation
        'oz': 'oz',
        'ounce': 'oz',
        'ounces': 'oz',
        'lb': 'oz', // Convert lbs to oz for aggregation
        'lbs': 'oz',
        'pound': 'oz',
        'pounds': 'oz',

        // Volume units - keep separate
        'cup': 'cup',
        'cups': 'cup',
        'tbsp': 'tbsp',
        'tablespoon': 'tbsp',
        'tablespoons': 'tbsp',
        'tsp': 'tsp',
        'teaspoon': 'tsp',
        'teaspoons': 'tsp',
        'ml': 'ml',
        'milliliter': 'ml',
        'milliliters': 'ml',
        'l': 'l',
        'liter': 'l',
        'liters': 'l',

        // Count units
        'piece': 'unit',
        'pieces': 'unit',
        'medium': 'medium',
        'large': 'large',
        'small': 'small',
        'scoop': 'scoop',
        'scoops': 'scoop',
        'serving': 'serving',
        'servings': 'serving',
        'unit': 'unit'
    };

    const normalizedUnit = unitNormalization[unit] || unit;
    let normalizedQuantity = quantity;

    // Convert kg to g (1 kg = 1000 g)
    if (unit === 'kg') {
        normalizedQuantity = quantity * 1000;
    }
    // Convert lbs to oz (1 lb = 16 oz)
    else if (unit === 'lb' || unit === 'lbs' || unit === 'pound' || unit === 'pounds') {
        normalizedQuantity = quantity * 16;
    }
    // Convert tablespoons to teaspoons if needed for consistency (optional)
    // For now, keep them separate for easier reading

    return {
        quantity: normalizedQuantity,
        unit: normalizedUnit
    };
}

function aggregateGroceryList(multiDayPlan) {
    const aggregated = {};

    multiDayPlan.forEach(dayData => {
        dayData.plan.forEach(meal => {
            if (!meal.ingredients || !Array.isArray(meal.ingredients)) return;

            meal.ingredients.forEach(ingredient => {
                // Handle both old string format and new object format
                let ingredientStr;
                if (typeof ingredient === 'string') {
                    // Old format: "3 eggs"
                    ingredientStr = ingredient;
                } else if (ingredient.food && ingredient.amount) {
                    // New format: {food: "egg", amount: "3"}
                    ingredientStr = `${ingredient.amount} ${ingredient.food}`;
                } else {
                    console.warn('Unknown ingredient format:', ingredient);
                    return;
                }

                const parsed = parseIngredient(ingredientStr);
                const normalized = normalizeUnit(parsed.quantity, parsed.unit);

                const key = `${parsed.name}|${normalized.unit}`;
                if (aggregated[key]) {
                    aggregated[key].quantity += normalized.quantity;
                } else {
                    aggregated[key] = {
                        name: parsed.name,
                        quantity: normalized.quantity,
                        unit: normalized.unit
                    };
                }
            });
        });
    });

    return Object.values(aggregated).sort((a, b) => a.name.localeCompare(b.name));
}

// Format quantity with fractions for better readability
function formatQuantity(quantity) {
    // Round to nearest 0.125 for cleaner fractions
    const rounded = Math.round(quantity * 8) / 8;

    const whole = Math.floor(rounded);
    const decimal = rounded - whole;

    // Convert common decimals to fractions
    const fractions = {
        0: '',
        0.125: '1/8',
        0.25: '1/4',
        0.333: '1/3',
        0.375: '3/8',
        0.5: '1/2',
        0.625: '5/8',
        0.666: '2/3',
        0.75: '3/4',
        0.875: '7/8'
    };

    // Find closest fraction
    let closestDecimal = 0;
    let minDiff = 1;
    for (const dec in fractions) {
        const diff = Math.abs(decimal - parseFloat(dec));
        if (diff < minDiff) {
            minDiff = diff;
            closestDecimal = dec;
        }
    }

    const fraction = fractions[closestDecimal];

    if (whole === 0 && fraction) {
        return fraction;
    } else if (whole > 0 && fraction) {
        return `${whole} ${fraction}`;
    } else if (whole > 0) {
        return whole.toString();
    } else {
        // If no clean fraction match, show decimal
        return quantity.toFixed(1);
    }
}

// Generate a summary of the meal plan for client display
function generatePlanSummary(planData) {
    if (!planData || !planData.currentPlan || !Array.isArray(planData.currentPlan)) {
        return null;
    }

    // Collect all meal names
    const allMealNames = [];
    planData.currentPlan.forEach(dayData => {
        if (dayData.plan && Array.isArray(dayData.plan)) {
            dayData.plan.forEach(meal => {
                if (meal.name) {
                    allMealNames.push(meal.name.toLowerCase());
                }
            });
        }
    });

    if (allMealNames.length === 0) return null;

    const mealText = allMealNames.join(' ');

    // Detect protein sources
    const proteinSources = [];
    const proteinKeywords = {
        'chicken': 'chicken',
        'beef': 'beef',
        'steak': 'beef',
        'salmon': 'salmon',
        'fish': 'fish',
        'tuna': 'tuna',
        'shrimp': 'shrimp',
        'turkey': 'turkey',
        'pork': 'pork',
        'tofu': 'tofu',
        'tempeh': 'tempeh',
        'eggs': 'eggs',
        'egg': 'eggs',
        'greek yogurt': 'Greek yogurt',
        'cottage cheese': 'cottage cheese',
        'beans': 'beans',
        'lentils': 'lentils',
        'quinoa': 'quinoa'
    };

    for (const [keyword, label] of Object.entries(proteinKeywords)) {
        if (mealText.includes(keyword) && !proteinSources.includes(label)) {
            proteinSources.push(label);
        }
    }

    // Detect carb sources
    const carbSources = [];
    const carbKeywords = {
        'rice': 'rice',
        'oatmeal': 'oatmeal',
        'oats': 'oats',
        'sweet potato': 'sweet potatoes',
        'potato': 'potatoes',
        'pasta': 'pasta',
        'bread': 'bread',
        'quinoa': 'quinoa',
        'whole grain': 'whole grains'
    };

    for (const [keyword, label] of Object.entries(carbKeywords)) {
        if (mealText.includes(keyword) && !carbSources.includes(label)) {
            carbSources.push(label);
        }
    }

    // Detect vegetables
    const veggies = [];
    const veggieKeywords = {
        'broccoli': 'broccoli',
        'spinach': 'spinach',
        'salad': 'salads',
        'vegetables': 'vegetables',
        'asparagus': 'asparagus',
        'green beans': 'green beans',
        'kale': 'kale',
        'zucchini': 'zucchini',
        'peppers': 'peppers',
        'carrots': 'carrots',
        'avocado': 'avocado'
    };

    for (const [keyword, label] of Object.entries(veggieKeywords)) {
        if (mealText.includes(keyword) && !veggies.includes(label)) {
            veggies.push(label);
        }
    }

    // Build summary based on macro targets
    const targets = planData.currentPlan[0]?.targets || {};
    let planStyle = '';

    if (targets.protein && targets.calories) {
        const proteinRatio = (targets.protein * 4) / targets.calories;
        if (proteinRatio > 0.35) {
            planStyle = 'High-protein';
        } else if (proteinRatio > 0.25) {
            planStyle = 'Protein-focused';
        }
    }

    if (targets.carbs && targets.calories) {
        const carbRatio = (targets.carbs * 4) / targets.calories;
        if (carbRatio < 0.25) {
            planStyle = planStyle ? planStyle + ', low-carb' : 'Low-carb';
        }
    }

    // Build the summary string
    let summary = '';

    if (planStyle) {
        summary = planStyle + ' meals';
    } else {
        summary = 'Balanced meals';
    }

    if (proteinSources.length > 0) {
        const topProteins = proteinSources.slice(0, 3);
        summary += ' featuring ' + topProteins.join(', ');
    }

    if (veggies.length > 0 && veggies.length <= 2) {
        summary += ' with ' + veggies.join(' and ');
    } else if (veggies.length > 2) {
        summary += ' with fresh vegetables';
    }

    if (carbSources.length > 0 && carbSources.length <= 2) {
        summary += ' and ' + carbSources.join(', ');
    }

    // Truncate if too long
    if (summary.length > 120) {
        summary = summary.substring(0, 117) + '...';
    }

    return summary;
}

function showGroceryList() {
    if (!lastPlanQuery.currentPlan) {
        alert('No plan available');
        return;
    }

    const groceryList = aggregateGroceryList(lastPlanQuery.currentPlan);

    let listHTML = `
        <div class="card mt-4">
            <h3 class="text-2xl font-bold mb-4">üìù Grocery List</h3>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-2">`;

    groceryList.forEach(item => {
        const formattedQty = formatQuantity(item.quantity);
        listHTML += `<div class="p-2 bg-gray-50 rounded">
            <span class="font-semibold">${formattedQty} ${item.unit}</span> ${item.name}
        </div>`;
    });

    listHTML += `</div>
        <button data-action="close-grocery-list" class="btn btn-secondary w-full mt-4">Close</button>
    </div>`;

    const resultDiv = document.getElementById('diet-plan-result');
    resultDiv.innerHTML += listHTML;
    resultDiv.lastElementChild.scrollIntoView({ behavior: 'smooth' });
}

// MATH CHECK FUNCTION
function showMathCheck() {
    if (!lastPlanQuery.currentPlan) {
        alert('No plan available');
        return;
    }

    const modal = document.getElementById('math-check-modal');
    const content = document.getElementById('math-check-content');
    const targets = lastPlanQuery.currentPlan[0].targets;

    let html = `
        <div class="bg-blue-50 p-4 rounded-lg mb-6">
            <h4 class="font-bold text-lg mb-2">Daily Targets</h4>
            <div class="grid grid-cols-4 gap-4">
                <div class="text-center">
                    <p class="text-sm text-gray-600">Calories</p>
                    <span class="font-bold text-blue-600">${targets.calories}</span>
                </div>
                <div class="text-center">
                    <p class="text-sm text-gray-600">Protein</p>
                    <span class="font-bold text-blue-600">${targets.protein}g</span>
                </div>
                <div class="text-center">
                    <p class="text-sm text-gray-600">Carbs</p>
                    <span class="font-bold text-blue-600">${targets.carbs}g</span>
                </div>
                <div class="text-center">
                    <p class="text-sm text-gray-600">Fat</p>
                    <span class="font-bold text-blue-600">${targets.fat}g</span>
                </div>
            </div>
        </div>`;

    // Analyze each day
    lastPlanQuery.currentPlan.forEach((dayData, dayIndex) => {
        html += `<div class="mb-6 border-b pb-4">
            <h4 class="font-bold text-xl mb-3">Day ${dayData.day}</h4>`;

        // Calculate daily totals
        let dayCalories = 0, dayProtein = 0, dayCarbs = 0, dayFat = 0;

        // Analyze each meal
        dayData.plan.forEach((meal, mealIndex) => {
            const isSupplement = meal.type === 'supplement';

            // Supplements get special display (user-defined, no validation needed)
            if (isSupplement) {
                html += `
                <div class="p-3 rounded-lg mb-3" style="background: linear-gradient(135deg, #e0f2fe 0%, #dbeafe 100%); border: 2px solid #0ea5e9;">
                    <div class="flex justify-between items-center mb-2">
                        <h5 class="font-bold capitalize" style="color: #0369a1;">üíä Supplement: ${meal.name}</h5>
                        <span class="text-blue-600 font-semibold">‚úÖ User Defined</span>
                    </div>
                    <div class="grid grid-cols-4 gap-2 text-sm mb-2">
                        <div><span class="text-gray-600">Calories:</span> <strong>${meal.calories}</strong></div>
                        <div><span class="text-gray-600">Protein:</span> <strong>${meal.protein}g</strong></div>
                        <div><span class="text-gray-600">Carbs:</span> <strong>${meal.carbs}g</strong></div>
                        <div><span class="text-gray-600">Fat:</span> <strong>${meal.fat}g</strong></div>
                    </div>
                </div>`;

                // Add to daily totals
                dayCalories += meal.calories;
                dayProtein += meal.protein;
                dayCarbs += meal.carbs;
                dayFat += meal.fat;
                return; // Skip normal validation for supplements
            }

            const validation = validateMeal(meal, meal.type);
            const calculatedCalories = (meal.protein * 4) + (meal.carbs * 4) + (meal.fat * 9);
            const calorieDifference = Math.abs(meal.calories - calculatedCalories);
            const percentOff = calorieDifference / meal.calories;

            // Determine status color
            let statusColor = 'green';
            let statusIcon = '‚úÖ';
            let statusText = 'Accurate';

            if (validation.issues.length > 0) {
                statusColor = 'orange';
                statusIcon = '‚ö†Ô∏è';
                statusText = 'Warning';
            }

            if (percentOff > 0.15) {
                statusColor = 'red';
                statusIcon = '‚ùå';
                statusText = 'Math Error';
            }

            html += `
                <div class="bg-gray-50 p-3 rounded-lg mb-3">
                    <div class="flex justify-between items-center mb-2">
                        <h5 class="font-bold capitalize">${meal.type}: ${meal.name}</h5>
                        <span class="text-${statusColor}-600 font-semibold">${statusIcon} ${statusText}</span>
                    </div>
                    <div class="grid grid-cols-4 gap-2 text-sm mb-2">
                        <div><span class="text-gray-600">Calories:</span> <strong>${meal.calories}</strong></div>
                        <div><span class="text-gray-600">Protein:</span> <strong>${meal.protein}g</strong></div>
                        <div><span class="text-gray-600">Carbs:</span> <strong>${meal.carbs}g</strong></div>
                        <div><span class="text-gray-600">Fat:</span> <strong>${meal.fat}g</strong></div>
                    </div>
                    <div class="text-sm">
                        <p class="text-gray-600">Macro Math: <strong>${Math.round(calculatedCalories)} cal</strong>
                        ${percentOff > 0.08 ? `<span class="text-orange-600">(${Math.round(percentOff*100)}% difference)</span>` : '<span class="text-green-600">(‚úì Within 8%)</span>'}
                        </p>
                    </div>`;

            if (validation.issues.length > 0) {
                html += `<div class="mt-2 p-2 bg-yellow-50 rounded text-sm">
                    <p class="font-semibold text-yellow-800">Validation Notes:</p>
                    <ul class="list-disc ml-5 text-yellow-700">`;
                validation.issues.forEach(issue => {
                    html += `<li>${issue}</li>`;
                });
                html += `</ul></div>`;
            }

            html += `</div>`;

            // Add to daily totals
            dayCalories += meal.calories;
            dayProtein += meal.protein;
            dayCarbs += meal.carbs;
            dayFat += meal.fat;
        });

        // Daily totals summary
        const calDiff = dayCalories - targets.calories;
        const proteinDiff = dayProtein - targets.protein;
        const carbsDiff = dayCarbs - targets.carbs;
        const fatDiff = dayFat - targets.fat;

        const calStatus = Math.abs(calDiff) <= 50 ? 'text-green-600' : 'text-orange-600';
        const proteinStatus = Math.abs(proteinDiff) <= 5 ? 'text-green-600' : 'text-orange-600';
        const carbsStatus = Math.abs(carbsDiff) <= 10 ? 'text-green-600' : 'text-orange-600';
        const fatStatus = Math.abs(fatDiff) <= 5 ? 'text-green-600' : 'text-orange-600';

        html += `
            <div class="bg-blue-50 p-3 rounded-lg mt-3">
                <h5 class="font-bold mb-2">Day ${dayData.day} Totals vs Targets</h5>
                <div class="grid grid-cols-4 gap-2 text-sm">
                    <div class="${calStatus}">
                        <strong>${dayCalories}</strong> / ${targets.calories} cal
                        <br><span class="text-xs">(${calDiff > 0 ? '+' : ''}${calDiff})</span>
                    </div>
                    <div class="${proteinStatus}">
                        <strong>${dayProtein}g</strong> / ${targets.protein}g
                        <br><span class="text-xs">(${proteinDiff > 0 ? '+' : ''}${proteinDiff}g)</span>
                    </div>
                    <div class="${carbsStatus}">
                        <strong>${dayCarbs}g</strong> / ${targets.carbs}g
                        <br><span class="text-xs">(${carbsDiff > 0 ? '+' : ''}${carbsDiff}g)</span>
                    </div>
                    <div class="${fatStatus}">
                        <strong>${dayFat}g</strong> / ${targets.fat}g
                        <br><span class="text-xs">(${fatDiff > 0 ? '+' : ''}${fatDiff}g)</span>
                    </div>
                </div>
            </div>
        </div>`;
    });

    content.innerHTML = html;
    modal.classList.remove('hidden');
}

// PDF EXPORT
function downloadPlanAsPDF() {
    const { jsPDF } = window.jspdf;
    if (!lastPlanQuery.currentPlan) {
        alert('No plan to download');
        return;
    }

    const pdf = new jsPDF();
    const margin = 15;
    const pageWidth = pdf.internal.pageSize.getWidth();
    const maxWidth = pageWidth - (margin * 2);
    let y = 20;

    // Title
    pdf.setFontSize(24);
    pdf.setTextColor(102, 126, 234);
    pdf.text('Personalized Meal Plan', margin, y);
    y += 10;

    // Client Name
    if (lastPlanQuery.clientName) {
        pdf.setFontSize(16);
        pdf.setTextColor(0, 0, 0);
        pdf.text(`For: ${lastPlanQuery.clientName}`, margin, y);
        y += 12;
    }

    // Daily Nutrition Summary - use original targets (includes protein powder)
    const displayTargets = lastPlanQuery.originalTargets || {
        calories: lastPlanQuery.calories,
        protein: lastPlanQuery.protein,
        carbs: lastPlanQuery.carbs,
        fat: lastPlanQuery.fat
    };
    pdf.setFontSize(14);
    pdf.setTextColor(0, 0, 0);
    pdf.text('Daily Nutrition Targets:', margin, y);
    y += 8;
    pdf.setFontSize(11);
    pdf.text(`Calories: ${displayTargets.calories} | Protein: ${displayTargets.protein}g | Carbs: ${displayTargets.carbs}g | Fat: ${displayTargets.fat}g`, margin, y);
    y += 8;
    pdf.text(`Macro Split: ${lastPlanQuery.macroPreference}`, margin, y);
    y += 15;

    // Supplement Protocol Section
    if (lastPlanQuery.proteinPowderInfo) {
        if (y > 240) {
            pdf.addPage();
            y = 20;
        }
        pdf.setFontSize(16);
        pdf.setTextColor(102, 126, 234);
        pdf.text('Supplement Protocol', margin, y);
        y += 8;
        pdf.setFontSize(10);
        pdf.setTextColor(0, 0, 0);
        const pp = lastPlanQuery.proteinPowderInfo;
        const supplementText = `${pp.brand}: ${pp.calories} cal, ${pp.protein}g protein, ${pp.carbs}g carbs, ${pp.fat}g fat (included in daily totals)`;
        const supplementLines = pdf.splitTextToSize(supplementText, maxWidth);
        pdf.text(supplementLines, margin, y);
        y += supplementLines.length * 5 + 10;
    }

    // Meal Plans by Day
    lastPlanQuery.currentPlan.forEach(dayData => {
        if (y > 250) {
            pdf.addPage();
            y = 20;
        }

        // Day Header
        pdf.setFontSize(18);
        pdf.setTextColor(118, 75, 162);
        pdf.text(`Day ${dayData.day}`, margin, y);
        y += 10;

        dayData.plan.forEach(meal => {
            if (y > 230) {
                pdf.addPage();
                y = 20;
            }

            // Meal Name
            pdf.setFontSize(14);
            pdf.setTextColor(102, 126, 234);
            const mealNameLines = pdf.splitTextToSize(`${meal.type.toUpperCase()}: ${meal.name}`, maxWidth);
            pdf.text(mealNameLines, margin, y);
            y += mealNameLines.length * 6;

            // Macros
            pdf.setFontSize(10);
            pdf.setTextColor(100, 100, 100);
            pdf.text(`${meal.calories} cal | ${meal.protein}g protein | ${meal.carbs}g carbs | ${meal.fat}g fat`, margin + 5, y);
            y += 7;

            // Ingredients
            if (meal.ingredients && Array.isArray(meal.ingredients) && meal.ingredients.length > 0) {
                pdf.setFontSize(11);
                pdf.setTextColor(0, 0, 0);
                pdf.setFont(undefined, 'bold');
                pdf.text('Ingredients:', margin + 5, y);
                y += 5;
                pdf.setFont(undefined, 'normal');
                pdf.setFontSize(9);
                meal.ingredients.forEach(ingredient => {
                    if (y > 270) {
                        pdf.addPage();
                        y = 20;
                    }
                    // Handle both string and object ingredient formats
                    const ingredientText = typeof ingredient === 'string'
                        ? ingredient
                        : `${ingredient.amount} ${ingredient.food}`;
                    const ingredientLines = pdf.splitTextToSize(`‚Ä¢ ${ingredientText}`, maxWidth - 10);
                    pdf.text(ingredientLines, margin + 10, y);
                    y += ingredientLines.length * 4;
                });
                y += 3;
            }

            // Full Cooking Instructions
            if (meal.instructions) {
                if (y > 260) {
                    pdf.addPage();
                    y = 20;
                }
                pdf.setFontSize(11);
                pdf.setFont(undefined, 'bold');
                pdf.text('Cooking Instructions:', margin + 5, y);
                y += 5;
                pdf.setFont(undefined, 'normal');
                pdf.setFontSize(9);
                const instructionLines = pdf.splitTextToSize(meal.instructions, maxWidth - 10);
                pdf.text(instructionLines, margin + 10, y);
                y += instructionLines.length * 4 + 8;
            }

            y += 5; // Space between meals
        });
        y += 10; // Space between days
    });

    // Grocery List
    pdf.addPage();
    y = 20;
    pdf.setFontSize(20);
    pdf.setTextColor(102, 126, 234);
    pdf.text('Shopping List', margin, y);
    y += 12;

    const groceryList = aggregateGroceryList(lastPlanQuery.currentPlan);
    pdf.setFontSize(10);
    pdf.setTextColor(0, 0, 0);
    groceryList.forEach(item => {
        if (y > 270) {
            pdf.addPage();
            y = 20;
        }
        const formattedQty = formatQuantity(item.quantity);
        const itemText = `- ${formattedQty} ${item.unit} ${item.name}`;
        pdf.text(itemText, margin, y);
        y += 6;
    });

    // Footer on last page
    y += 10;
    if (y > 260) {
        pdf.addPage();
        y = 20;
    }
    pdf.setFontSize(8);
    pdf.setTextColor(150, 150, 150);
    pdf.text(`Generated on ${new Date().toLocaleDateString()}`, margin, y);

    pdf.save('meal-plan.pdf');
}

// SHARE PLAN FUNCTIONALITY
async function sharePlan() {
    if (!lastPlanQuery.currentPlan) {
        alert('No plan to share. Please generate a plan first.');
        return;
    }

    // Prepare the plan data for sharing
    const shareData = {
        clientName: lastPlanQuery.clientName || 'Client',
        nutrition: {
            calories: lastPlanQuery.calories,
            protein: lastPlanQuery.protein,
            carbs: lastPlanQuery.carbs,
            fat: lastPlanQuery.fat
        },
        meals: [],
        preferences: {
            goal: document.getElementById('dp_goal')?.value || 'maintain',
            dietType: lastPlanQuery.preference || 'omnivore',
            allergies: lastPlanQuery.allergies || 'none',
            mealsPerDay: lastPlanQuery.currentPlan.length > 0 ? lastPlanQuery.currentPlan[0].plan.length : 3
        },
        generatedAt: new Date().toISOString()
    };

    // Flatten multi-day plan into single meals array
    lastPlanQuery.currentPlan.forEach(dayData => {
        dayData.plan.forEach(meal => {
            shareData.meals.push(meal);
        });
    });

    // Show modal with loading state
    const modal = document.getElementById('share-modal');
    const linkText = document.getElementById('share-link-text');
    linkText.textContent = 'Generating share link...';
    modal.classList.remove('hidden');

    try {
        console.log('Saving plan for sharing...');

        // Prepare request body
        const requestBody = { planData: shareData };

        // If this plan was saved to history (has planId), include it
        // This links the shared plan to the coach plan for cascade deletion
        if (lastPlanQuery.planId) {
            requestBody.coachPlanId = lastPlanQuery.planId;
            console.log('Linking shared plan to coach plan:', lastPlanQuery.planId);
        }

        const response = await fetch(SAVE_PLAN_ENDPOINT, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            throw new Error('Failed to generate share link');
        }

        const data = await response.json();
        currentShareUrl = data.shareUrl;

        console.log('Share link generated:', currentShareUrl);

        linkText.textContent = currentShareUrl;

    } catch (error) {
        console.error('Error generating share link:', error);
        linkText.textContent = 'Failed to generate link. Please try again.';
        alert('Failed to generate share link. Please try again.');
    }
}

async function copyShareLink() {
    if (!currentShareUrl) {
        alert('No share link available');
        return;
    }

    try {
        await navigator.clipboard.writeText(currentShareUrl);

        // Update button text temporarily
        const copyBtn = event.target;
        const originalText = copyBtn.textContent;
        copyBtn.textContent = '‚úÖ Copied!';
        copyBtn.style.background = '#28a745';

        setTimeout(() => {
            copyBtn.textContent = originalText;
            copyBtn.style.background = '';
        }, 2000);

    } catch (error) {
        console.error('Copy error:', error);
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = currentShareUrl;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        alert('Link copied to clipboard!');
    }
}

function closeShareModal() {
    const modal = document.getElementById('share-modal');
    modal.classList.add('hidden');
}

// MEAL PREP GUIDE GENERATOR
async function showMealPrepGuide() {
    const modal = document.getElementById('meal-prep-modal');
    const content = document.getElementById('meal-prep-content');

    // Show modal with loading state
    modal.classList.remove('hidden');
    content.innerHTML = `
        <div class="flex items-center justify-center py-12">
            <div class="loader"><div class="loader-spinner"></div></div>
            <p class="ml-4 text-gray-600">Generating your comprehensive meal prep guide...</p>
        </div>
    `;

    try {
        // Collect all meals from the plan
        const allMeals = [];
        if (lastPlanQuery.currentPlan && Array.isArray(lastPlanQuery.currentPlan)) {
            lastPlanQuery.currentPlan.forEach(dayData => {
                if (dayData.plan && Array.isArray(dayData.plan)) {
                    dayData.plan.forEach(meal => {
                        allMeals.push({
                            day: dayData.day,
                            type: meal.type,
                            name: meal.name,
                            calories: meal.calories,
                            protein: meal.protein,
                            carbs: meal.carbs,
                            fat: meal.fat
                        });
                    });
                }
            });
        }

        if (allMeals.length === 0) {
            content.innerHTML = '<p class="text-center text-gray-600">No meal plan found. Please generate a meal plan first.</p>';
            return;
        }

        const numDays = lastPlanQuery.currentPlan.length;
        const mealsList = allMeals.map(m => `Day ${m.day} ${m.type}: ${m.name}`).join('\n');

        const prompt = `You are a professional meal prep consultant. Create a comprehensive meal prep guide for the following ${numDays}-day meal plan:

${mealsList}

Create a detailed, actionable meal prep guide with the following sections:

## üìù Shopping List
Group all ingredients by category (Proteins, Vegetables, Fruits, Grains/Carbs, Dairy, Pantry Items, etc.)
Combine quantities where meals share ingredients
Be specific with quantities and measurements

## ‚è∞ Meal Prep Timeline
Provide a day-by-day prep schedule (e.g., "Sunday: Cook all proteins", "Monday: Prep vegetables")
Include which meals to batch cook together
Suggest which components can be prepared ahead
Include estimated time for each prep session

## ü•° Storage Instructions
For EACH meal, specify:
- How long it keeps in the refrigerator (be specific: 3-4 days, 5-6 days, etc.)
- Whether it can be frozen and for how long
- Best storage containers (airtight, glass, etc.)
- Any special storage notes

## üî• Reheating Instructions
For EACH meal type (not every individual meal, but each unique recipe), provide:
- Microwave instructions (time and power level)
- Oven/stovetop instructions if better quality
- Tips to maintain texture and flavor

## üí° Time-Saving Tips
- Batch cooking strategies (cook all chicken at once, prep all vegetables together, etc.)
- Make-ahead components (cook rice/grains in bulk, pre-chop vegetables, etc.)
- Kitchen shortcuts and efficiency tips
- Which meals taste better fresh vs reheated

Format the response in clean, readable markdown with clear headings and bullet points.
Be specific, practical, and actionable. Focus on making meal prep as easy and efficient as possible.`;

        const response = await callGemini(prompt, false);

        // Format the response nicely
        content.innerHTML = `
            <div class="prose prose-sm max-w-none">
                ${formatMarkdown(response)}
            </div>
        `;

    } catch (error) {
        console.error('Error generating meal prep guide:', error);
        content.innerHTML = `
            <div class="text-center text-red-600 py-8">
                <p class="font-semibold">Error generating meal prep guide</p>
                <p class="text-sm mt-2">${error.message}</p>
            </div>
        `;
    }
}

// Simple markdown formatter
function formatMarkdown(text) {
    // Handle non-string inputs
    if (typeof text !== 'string') {
        console.warn('formatMarkdown received non-string input:', typeof text);
        text = String(text);
    }

    return text
        .replace(/^## (.+)$/gm, '<h2 class="text-2xl font-bold mt-6 mb-4 text-gray-800">$1</h2>')
        .replace(/^### (.+)$/gm, '<h3 class="text-xl font-semibold mt-4 mb-3 text-gray-700">$1</h3>')
        .replace(/^\* (.+)$/gm, '<li class="ml-4">$1</li>')
        .replace(/^- (.+)$/gm, '<li class="ml-4">$1</li>')
        .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
        .replace(/\n\n/g, '</p><p class="mb-3">')
        .replace(/^(?!<[hl]|<li)/gm, '<p class="mb-3">')
        .replace(/<\/li>\n<li/g, '</li><li');
}

// UNIT SYSTEM STATE
let currentUnitSystem = 'imperial';

function toggleUnitSystem(system) {
    currentUnitSystem = system;
    document.getElementById('unit-imperial').className = system === 'imperial' ? 'btn btn-primary text-sm py-1 px-3' : 'btn btn-secondary text-sm py-1 px-3';
    document.getElementById('unit-metric').className = system === 'metric' ? 'btn btn-primary text-sm py-1 px-3' : 'btn btn-secondary text-sm py-1 px-3';

    // Update labels
    const weightLabel = system === 'imperial' ? 'Weight (lbs)' : 'Weight (kg)';
    const heightLabel1 = system === 'imperial' ? 'Height (ft)' : 'Height (cm)';
    const heightLabel2 = system === 'imperial' ? 'Height (in)' : '';

    document.querySelector('label[for="dp_weight"]').textContent = weightLabel;
    document.querySelector('label[for="dp_height_ft"]').textContent = heightLabel1;
    document.querySelector('label[for="dp_height_in"]').textContent = heightLabel2;
    document.getElementById('dp_height_in').style.display = system === 'imperial' ? 'block' : 'none';
}

// EVENT HANDLERS
document.addEventListener('click', function(event) {
    const actionTarget = event.target.closest('[data-action]');
    if (!actionTarget) return;

    const actions = {
        'generate-plan': generateDietPlan,
        'close-modal': () => document.getElementById('recipe-modal').classList.add('hidden'),
        'get-recipe': () => {
            const target = event.target.closest('[data-meal-name]');
            if (!target) {
                console.error('Recipe button clicked but no data-meal-name attribute found');
                return;
            }
            const mealName = target.dataset.mealName;
            if (mealName) {
                console.log('Opening recipe for:', mealName);
                getAIRecipe(mealName);
            } else {
                console.error('Recipe button has data-meal-name attribute but no value');
            }
        },
        'change-meal': () => {
            const target = event.target.closest('[data-day-index]');
            const dayIndex = parseInt(target.dataset.dayIndex);
            const mealIndex = parseInt(target.dataset.mealIndex);
            changeMeal(dayIndex, mealIndex);
        },
        'revise-meal': () => {
            const target = event.target.closest('[data-day-index]');
            const dayIndex = parseInt(target.dataset.dayIndex);
            const mealIndex = parseInt(target.dataset.mealIndex);
            reviseMeal(dayIndex, mealIndex);
        },
        'custom-meal': () => {
            const target = event.target.closest('[data-day-index]');
            const dayIndex = parseInt(target.dataset.dayIndex);
            const mealIndex = parseInt(target.dataset.mealIndex);
            customMeal(dayIndex, mealIndex);
        },
        'undo-meal': () => {
            const target = event.target.closest('[data-day-index]');
            const dayIndex = parseInt(target.dataset.dayIndex);
            const mealIndex = parseInt(target.dataset.mealIndex);
            undoMeal(dayIndex, mealIndex);
        },
        'regenerate-day': () => {
            const target = event.target.closest('[data-day-index]');
            const dayIndex = parseInt(target.dataset.dayIndex);
            regenerateDay(dayIndex);
        },
        'check-math': showMathCheck,
        'close-math-modal': () => document.getElementById('math-check-modal').classList.add('hidden'),
        'show-grocery-list': showGroceryList,
        'close-grocery-list': () => {
            event.target.closest('.card').remove();
        },
        'show-meal-prep-guide': showMealPrepGuide,
        'close-meal-prep-modal': () => document.getElementById('meal-prep-modal').classList.add('hidden'),
        'download-pdf': downloadPlanAsPDF,
        'share-plan': sharePlan,
        'copy-share-link': copyShareLink,
        'close-share-modal': closeShareModal,
        'save-coach-notes': saveCoachNotes,
        'save-meal-note': () => {
            const target = event.target.closest('[data-day-index]');
            const dayIndex = parseInt(target.dataset.dayIndex);
            const mealIndex = parseInt(target.dataset.mealIndex);
            saveMealNote(dayIndex, mealIndex);
        },
        'submit-to-client': publishPlanToClient
    };

    if (actions[actionTarget.dataset.action]) actions[actionTarget.dataset.action]();
});

// Unit system toggle
document.getElementById('unit-imperial').addEventListener('click', () => toggleUnitSystem('imperial'));
document.getElementById('unit-metric').addEventListener('click', () => toggleUnitSystem('metric'));

// Protein powder checkbox toggle
document.getElementById('dp_use_protein').addEventListener('change', function() {
    const fields = document.getElementById('protein-powder-fields');
    if (this.checked) {
        fields.style.display = 'grid';  // Use grid to match the class
    } else {
        fields.style.display = 'none';
    }
});
</script>
</body>
</html>
