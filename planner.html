<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="/js/theme.js"></script>
    <meta name="theme-color" content="#0d9488">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Zique Fitness">
    <link rel="manifest" href="/manifest.json">
    <link rel="apple-touch-icon" href="/icons/icon.svg">
    <title>AI Meal Planner - Zique Fitness Nutrition</title>
    <!-- Prevent caching to avoid stale data on back navigation -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <link rel="stylesheet" href="/css/coach-layout.css">
    <style>
        * {
            -webkit-overflow-scrolling: touch !important;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #0d9488 0%, #0284c7 100%);
            min-height: 100vh;
            overflow-y: auto !important;
        }

        .app-container {
            max-width: 1200px;
            margin: 1rem auto;
            padding: 0.5rem;
        }

        .card {
            background-color: white;
            border-radius: 1rem;
            padding: 2rem;
            box-shadow: 0 10px 15px -3px rgba(0,0,0,0.1);
            margin-bottom: 1rem;
        }

        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-primary {
            background-color: #0d9488;
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            background-color: #5568d3;
        }

        .btn-secondary {
            background-color: #E3E9F5;
            color: #0d9488;
        }

        .btn-secondary:hover:not(:disabled) {
            background-color: #D3DBF0;
        }

        .btn-custom {
            background: #7c3aed;
            color: white;
        }

        .btn-custom:hover:not(:disabled) {
            background: #6d28d9;
        }

        .btn-portions {
            background: #0891b2;
            color: white;
        }

        .btn-portions:hover:not(:disabled) {
            background: #0e7490;
        }

        .btn-edit {
            background: #0d9488;
            color: white;
        }

        .btn-edit:hover:not(:disabled) {
            background: #0f766e;
        }

        .portions-dropdown {
            position: absolute;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            min-width: 120px;
            overflow: hidden;
        }

        .portions-dropdown button {
            display: block;
            width: 100%;
            padding: 10px 16px;
            text-align: left;
            border: none;
            background: white;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        .portions-dropdown button:hover {
            background: #f0f9ff;
        }

        /* Portions Stepper Styles */
        .portions-stepper {
            position: fixed;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            z-index: 1000;
            padding: 12px 16px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .portions-stepper-label {
            font-size: 11px;
            color: #6b7280;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .portions-stepper-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .portions-step-btn {
            width: 36px;
            height: 36px;
            border: 2px solid #0891b2;
            background: white;
            color: #0891b2;
            font-size: 20px;
            font-weight: bold;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .portions-step-btn:hover {
            background: #0891b2;
            color: white;
        }

        .portions-step-btn:disabled {
            border-color: #d1d5db;
            color: #d1d5db;
            cursor: not-allowed;
        }

        .portions-step-btn:disabled:hover {
            background: white;
            color: #d1d5db;
        }

        .portions-value {
            min-width: 60px;
            text-align: center;
            font-size: 18px;
            font-weight: 600;
            color: #0891b2;
        }

        .portions-stepper-apply {
            width: 100%;
            padding: 8px 16px;
            background: #0891b2;
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
            margin-top: 4px;
        }

        .portions-stepper-apply:hover {
            background: #0e7490;
        }

        .portions-presets {
            display: flex;
            gap: 6px;
            margin-top: 4px;
        }

        .portions-preset-btn {
            padding: 4px 10px;
            background: #f0f9ff;
            border: 1px solid #0891b2;
            border-radius: 4px;
            font-size: 12px;
            color: #0891b2;
            cursor: pointer;
            transition: all 0.2s;
        }

        .portions-preset-btn:hover {
            background: #0891b2;
            color: white;
        }

        .hidden {
            display: none;
        }

        .input-field {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
            margin-top: 0.5rem;
        }

        .radio-label, .checkbox-label {
            display: flex;
            align-items: center;
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        input[type="radio"]:checked + .radio-label,
        input[type="checkbox"]:checked + .checkbox-label {
            background-color: #E3E9F5;
            border-color: #0d9488;
        }

        .loader {
            width: 80px;
            height: 80px;
            margin: 2rem auto;
            position: relative;
        }

        .loader-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #0d9488;
            border-radius: 50%;
            animation: spin 2s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .meal-card {
            border: 1px solid #e5e7eb;
            padding: 1.5rem;
            border-radius: 0.75rem;
            margin-bottom: 1rem;
            display: flex;
            gap: 1rem;
        }

        .meal-card-image {
            width: 120px;
            height: 120px;
            min-width: 120px;
            border-radius: 0.5rem;
            object-fit: cover;
            background: #f3f4f6;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .meal-card-image:hover {
            transform: scale(1.05);
        }

        .meal-card-image.loading {
            animation: pulse 1.5s infinite;
        }

        .meal-card-image-placeholder {
            width: 120px;
            height: 120px;
            min-width: 120px;
            border-radius: 0.5rem;
            background: linear-gradient(135deg, #e0f2fe 0%, #dbeafe 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            cursor: pointer;
        }

        .meal-image-container {
            position: relative;
            width: 120px;
            min-width: 120px;
        }

        .meal-image-container .regenerate-btn {
            position: absolute;
            bottom: 4px;
            right: 4px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            border: none;
            cursor: pointer;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .meal-image-container:hover .regenerate-btn {
            opacity: 1;
        }

        .meal-image-container .regenerate-btn:hover {
            background: rgba(139, 92, 246, 0.9);
        }

        .meal-image-container .regenerate-btn.loading {
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .meal-card-content {
            flex: 1;
            min-width: 0;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .meal-card .text-blue-700 {
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: normal;
            font-size: 1.25rem;
            font-weight: 600;
            line-height: 1.4;
        }

        /* Image modal */
        .image-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            cursor: pointer;
        }

        .image-modal img {
            max-width: 90%;
            max-height: 90%;
            border-radius: 0.5rem;
        }

        .day-divider {
            background: linear-gradient(135deg, #0d9488 0%, #0284c7 100%);
            color: white;
            padding: 1rem;
            border-radius: 0.75rem;
            margin: 2rem 0 1rem 0;
            font-weight: 700;
            font-size: 1.25rem;
            text-align: center;
        }

        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }

        .prose h3 { margin-bottom: 0.5em; }
        .prose ul { list-style-type: disc; padding-left: 1.5em; }
        .prose ol { list-style-type: decimal; padding-left: 1.5em; }

        /* Custom Meal Modal Styles */
        .custom-meal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .custom-meal-overlay.show {
            display: flex;
        }

        .custom-meal-modal {
            background: white;
            border-radius: 20px;
            padding: 30px;
            max-width: 450px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            box-sizing: border-box;
            overflow: hidden;
            max-height: 90vh;
            overflow-y: auto;
        }

        .custom-meal-header {
            text-align: center;
            margin-bottom: 20px;
        }

        .custom-meal-header h2 {
            color: #0d9488;
            font-size: 1.5em;
            margin-bottom: 5px;
        }

        .custom-meal-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .custom-meal-tab {
            flex: 1;
            padding: 15px 10px;
            border: 2px solid #e0e7ff;
            border-radius: 12px;
            background: white;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }

        .custom-meal-tab:hover {
            border-color: #0d9488;
        }

        .custom-meal-tab.active {
            background: linear-gradient(135deg, #0d9488 0%, #0891b2 100%);
            border-color: transparent;
            color: white;
        }

        .custom-meal-tab-icon {
            display: block;
            font-size: 1.5em;
            margin-bottom: 5px;
        }

        .custom-meal-tab-label {
            font-size: 0.85em;
            font-weight: 600;
        }

        .custom-meal-panel {
            display: none;
        }

        .custom-meal-panel.active {
            display: block;
        }

        .custom-meal-hint {
            background: #f0fdf4;
            border: 1px solid #86efac;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
            font-size: 0.9em;
            color: #166534;
        }

        .custom-meal-input {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e0e7ff;
            border-radius: 10px;
            font-size: 1em;
            margin-bottom: 15px;
            box-sizing: border-box;
        }

        .custom-meal-input:focus {
            outline: none;
            border-color: #0d9488;
        }

        .food-search-container {
            position: relative;
            margin-bottom: 15px;
        }

        .food-search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #e0e7ff;
            border-top: none;
            border-radius: 0 0 10px 10px;
            max-height: 250px;
            overflow-y: auto;
            z-index: 100;
            display: none;
        }

        .food-search-results.active {
            display: block;
        }

        .food-search-item {
            padding: 10px 12px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
        }

        .food-search-item:hover {
            background: #f0fdf4;
        }

        .food-search-item:last-child {
            border-bottom: none;
        }

        .food-name {
            font-weight: 600;
            color: #333;
            margin-bottom: 2px;
        }

        .food-macros {
            font-size: 0.8em;
            color: #666;
        }

        .food-search-loading, .food-search-empty {
            padding: 15px;
            text-align: center;
            color: #888;
        }

        .selected-ingredients {
            margin-bottom: 15px;
        }

        .selected-ingredients-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #e0e7ff;
            margin-bottom: 10px;
            font-weight: 600;
            color: #333;
        }

        .ingredients-list {
            max-height: 150px;
            overflow-y: auto;
        }

        .ingredient-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: #f8fafc;
            border-radius: 8px;
            margin-bottom: 6px;
        }

        .ingredient-name {
            flex: 1;
            font-size: 0.9em;
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: normal;
        }

        .ingredient-qty {
            width: 60px;
            padding: 4px 8px;
            border: 1px solid #e0e7ff;
            border-radius: 6px;
            text-align: center;
            font-size: 0.9em;
            -moz-appearance: textfield;
        }

        .ingredient-qty::-webkit-outer-spin-button,
        .ingredient-qty::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .qty-stepper {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .qty-step-btn {
            width: 28px;
            height: 28px;
            border: 1px solid #e0e7ff;
            border-radius: 6px;
            background: white;
            color: #6366f1;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
            user-select: none;
        }

        .qty-step-btn:hover {
            background: #6366f1;
            color: white;
            border-color: #6366f1;
        }

        .qty-step-btn:active {
            transform: scale(0.95);
        }

        .qty-step-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .ingredient-unit {
            font-size: 0.85em;
            color: #666;
        }

        .ingredient-unit-select {
            padding: 4px 6px;
            border: 1px solid #e0e7ff;
            border-radius: 6px;
            font-size: 0.8em;
            background: white;
            cursor: pointer;
            max-width: 90px;
        }

        .ingredient-unit-select:focus {
            outline: none;
            border-color: #6366f1;
        }

        .ingredient-remove {
            background: #fee2e2;
            border: none;
            color: #dc2626;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            font-weight: bold;
        }

        .no-ingredients {
            text-align: center;
            color: #888;
            padding: 15px;
            font-style: italic;
        }

        .calculated-totals {
            background: linear-gradient(135deg, #ecfdf5 0%, #d1fae5 100%);
            border: 2px solid #10b981;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
        }

        .totals-header {
            font-weight: 700;
            color: #065f46;
            margin-bottom: 10px;
            font-size: 0.9em;
        }

        .totals-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            text-align: center;
        }

        .total-item {
            background: white;
            padding: 8px;
            border-radius: 8px;
        }

        .total-value {
            font-weight: 700;
            color: #0d9488;
            font-size: 1.1em;
        }

        .total-label {
            font-size: 0.75em;
            color: #666;
        }

        .macro-inputs-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-bottom: 15px;
        }

        .macro-input-group label {
            display: block;
            font-size: 0.85em;
            color: #666;
            margin-bottom: 5px;
            font-weight: 600;
        }

        .macro-input-group input {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #e0e7ff;
            border-radius: 8px;
            font-size: 1em;
            text-align: center;
            box-sizing: border-box;
        }

        .macro-input-group input:focus {
            outline: none;
            border-color: #0d9488;
        }

        .btn-submit-custom {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #0d9488 0%, #0891b2 100%);
            border: none;
            border-radius: 12px;
            color: white;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .btn-submit-custom:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(13, 148, 136, 0.4);
        }

        .btn-submit-custom:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-cancel-custom {
            width: 100%;
            padding: 12px;
            background: #6b7280;
            border: none;
            border-radius: 12px;
            color: white;
            font-size: 1em;
            cursor: pointer;
            margin-top: 10px;
        }

        /* Saved Meals Styles */
        .saved-meals-list {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 15px;
        }

        .saved-meal-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            border: 1px solid #e5e7eb;
            border-radius: 10px;
            margin-bottom: 8px;
            background: #fafafa;
        }

        .saved-meal-item:hover {
            background: #f0fdf4;
            border-color: #86efac;
        }

        .saved-meal-info {
            flex: 1;
            min-width: 0;
        }

        .saved-meal-name {
            font-weight: 600;
            color: #1f2937;
            word-wrap: break-word;
            overflow-wrap: break-word;
            white-space: normal;
        }

        .saved-meal-macros {
            font-size: 0.8em;
            color: #6b7280;
            margin-top: 2px;
        }

        .saved-meal-actions {
            display: flex;
            gap: 8px;
            margin-left: 10px;
        }

        .btn-use-saved {
            padding: 6px 12px;
            background: linear-gradient(135deg, #0d9488 0%, #0891b2 100%);
            border: none;
            border-radius: 6px;
            color: white;
            font-size: 0.85em;
            cursor: pointer;
        }

        .btn-delete-saved {
            padding: 6px 10px;
            background: #fee2e2;
            border: none;
            border-radius: 6px;
            color: #dc2626;
            font-size: 0.85em;
            cursor: pointer;
        }

        .btn-delete-saved:hover {
            background: #fecaca;
        }

        .btn-edit-saved {
            padding: 6px 10px;
            background: #dbeafe;
            border: none;
            border-radius: 6px;
            color: #2563eb;
            font-size: 0.85em;
            cursor: pointer;
        }

        .btn-edit-saved:hover {
            background: #bfdbfe;
        }

        .no-saved-meals {
            text-align: center;
            padding: 30px;
            color: #9ca3af;
        }

        .save-for-later-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 15px;
            padding: 10px;
            background: #fffbeb;
            border: 1px solid #fcd34d;
            border-radius: 8px;
        }

        .save-for-later-row input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .save-for-later-row label {
            font-size: 0.9em;
            color: #92400e;
            cursor: pointer;
        }

        /* Mobile Responsive Styles */
        @media (max-width: 768px) {
            /* Smooth transitions for everything */
            * {
                -webkit-tap-highlight-color: transparent;
            }

            body {
                -webkit-overflow-scrolling: touch;
            }

            /* Main layout - stack vertically */
            .flex.gap-8 {
                flex-direction: column !important;
                gap: 1rem !important;
            }

            /* Hide sidebar on mobile - show client list as collapsible */
            .w-80 {
                width: 100% !important;
                max-height: none;
                overflow: visible;
                background: rgba(255,255,255,0.95);
                border-radius: 12px;
                padding: 12px;
            }

            /* Client list scrollable horizontally */
            .w-80 > div {
                max-height: 200px;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }

            /* Main content area */
            .flex-1 {
                width: 100% !important;
                padding: 0 !important;
            }

            /* White content cards */
            .bg-white {
                border-radius: 16px !important;
                margin: 0 -8px;
                padding: 16px !important;
            }

            /* Meal cards - cleaner mobile layout */
            .meal-card {
                flex-direction: row;
                align-items: flex-start;
                text-align: left;
                padding: 12px;
                gap: 12px;
                border-radius: 12px;
                box-shadow: 0 1px 3px rgba(0,0,0,0.1);
                margin-bottom: 12px;
            }

            .meal-card-image,
            .meal-card-image-placeholder,
            .meal-image-container {
                width: 70px !important;
                height: 70px !important;
                min-width: 70px !important;
                border-radius: 10px !important;
            }

            .meal-card-content {
                width: 100%;
                min-width: 0;
            }

            .meal-card-content h4 {
                font-size: 0.9rem !important;
                margin-bottom: 2px;
            }

            .meal-card-content .text-blue-700 {
                font-size: 0.85rem !important;
                line-height: 1.3;
            }

            /* Macros - compact row */
            .meal-card .flex.gap-4.text-sm {
                display: flex;
                flex-wrap: nowrap;
                justify-content: flex-start;
                gap: 8px;
                font-size: 0.7rem;
                margin: 6px 0;
                overflow-x: auto;
            }

            /* Buttons - horizontal scroll */
            .meal-card .flex.gap-2 {
                flex-wrap: nowrap;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                gap: 6px;
                padding-bottom: 4px;
            }

            .meal-card .btn {
                padding: 6px 10px;
                font-size: 0.7rem;
                white-space: nowrap;
                flex-shrink: 0;
                border-radius: 6px;
            }

            /* Generate Image button smaller */
            button[data-action="generate-meal-image"] {
                padding: 5px 8px !important;
                font-size: 0.65rem !important;
            }

            /* Navigation - cleaner */
            nav {
                padding: 10px 12px !important;
                position: sticky;
                top: 0;
                z-index: 100;
            }

            nav span {
                font-size: 0.95rem !important;
            }

            nav > a > div:first-child {
                width: 32px !important;
                height: 32px !important;
                font-size: 1rem !important;
            }

            /* Client info form - single column */
            .grid.grid-cols-2 {
                grid-template-columns: 1fr !important;
                gap: 8px !important;
            }

            /* Regenerate button always visible on mobile */
            .meal-image-container .regenerate-btn {
                opacity: 0.9;
                width: 20px;
                height: 20px;
                font-size: 10px;
            }

            /* Note sections compact */
            .meal-note-section {
                padding: 8px !important;
                margin-top: 8px !important;
            }

            .meal-note-section textarea {
                font-size: 14px !important;
                padding: 8px !important;
                min-height: 50px !important;
            }

            /* Target form inputs - prevent zoom */
            input[type="number"],
            input[type="text"],
            select,
            textarea {
                font-size: 16px !important;
            }

            /* Day tabs scrollable */
            .day-tabs, [style*="display: flex"][style*="gap"] {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
                flex-wrap: nowrap !important;
            }

            /* Generate All button full width */
            button[onclick*="generateAllMealImages"] {
                width: 100%;
                padding: 12px !important;
                font-size: 0.9rem !important;
            }

            /* Modal adjustments */
            .modal-content, [style*="position: fixed"] > div {
                width: 95% !important;
                max-width: 95% !important;
                max-height: 85vh !important;
                overflow-y: auto !important;
                margin: 10px !important;
            }

            /* Headers smaller */
            h2 {
                font-size: 1.3rem !important;
            }

            h3 {
                font-size: 1.1rem !important;
            }
        }

        /* Extra small screens */
        @media (max-width: 480px) {
            .meal-card {
                padding: 10px;
            }

            .meal-card-image,
            .meal-card-image-placeholder,
            .meal-image-container {
                width: 60px !important;
                height: 60px !important;
                min-width: 60px !important;
            }

            .meal-card .btn {
                padding: 5px 8px;
                font-size: 0.65rem;
            }

            .meal-card .flex.gap-4.text-sm {
                font-size: 0.65rem;
            }

            nav {
                padding: 8px 10px !important;
            }
        }

        /* Dark mode overrides for form labels and text */
        [data-theme="dark"] .text-gray-700,
        [data-theme="dark"] .text-gray-800 {
            color: #e2e8f0 !important;
        }

        [data-theme="dark"] .text-gray-600,
        [data-theme="dark"] .text-gray-500 {
            color: #94a3b8 !important;
        }

        [data-theme="dark"] .card {
            background: #1e293b !important;
            border-color: #334155;
        }

        [data-theme="dark"] .bg-gray-50 {
            background: #334155 !important;
        }

        [data-theme="dark"] .bg-teal-50 {
            background: rgba(13, 148, 136, 0.15) !important;
        }

        [data-theme="dark"] .bg-blue-50 {
            background: rgba(59, 130, 246, 0.15) !important;
        }

        [data-theme="dark"] .text-teal-900,
        [data-theme="dark"] .text-blue-900 {
            color: #f1f5f9 !important;
        }

        [data-theme="dark"] .border-teal-400,
        [data-theme="dark"] .border-blue-400 {
            border-color: rgba(255, 255, 255, 0.2) !important;
        }

        /* Dark mode for input fields and selects */
        [data-theme="dark"] .input-field {
            background: #1e293b !important;
            border-color: #475569 !important;
            color: #f1f5f9 !important;
        }

        [data-theme="dark"] .input-field::placeholder {
            color: #64748b !important;
        }

        [data-theme="dark"] select.input-field option {
            background: #1e293b;
            color: #f1f5f9;
        }

        [data-theme="dark"] .border-teal-500,
        [data-theme="dark"] .border-blue-500 {
            border-color: #0d9488 !important;
        }

        /* Fix for yellow custom targets box */
        [data-theme="dark"] .bg-yellow-50 {
            background: rgba(234, 179, 8, 0.15) !important;
        }

        [data-theme="dark"] .text-yellow-800 {
            color: #fde047 !important;
        }

        [data-theme="dark"] .border-yellow-200 {
            border-color: rgba(234, 179, 8, 0.3) !important;
        }
    </style>
</head>
<body>
    <!-- Sidebar -->
    <aside class="sidebar">
        <div class="sidebar-header">
            <a href="dashboard.html" class="sidebar-logo">
                <img src="https://qewqcjzlfqamqwbccapr.supabase.co/storage/v1/object/public/assets/Untitled%20design%20(3).svg" alt="Zique Fitness" class="sidebar-logo-img">
            </a>
        </div>
        <nav class="sidebar-nav">
            <div class="sidebar-nav-section" data-section="menu">
                <div class="sidebar-nav-label" onclick="toggleSidebarSection(this)">
                    Menu
                    <svg class="collapse-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/>
                    </svg>
                </div>
                <div class="sidebar-nav-items">
                    <a href="dashboard.html" class="sidebar-nav-item">
                        <span class="sidebar-nav-icon">üìä</span>
                        Dashboard
                    </a>
                    <a href="manage-clients.html" class="sidebar-nav-item">
                        <span class="sidebar-nav-icon">üë•</span>
                        Clients
                    </a>
                    <a href="manage-recipes.html" class="sidebar-nav-item">
                        <span class="sidebar-nav-icon">üìñ</span>
                        Recipes
                    </a>
                    <a href="planner.html" class="sidebar-nav-item active">
                        <span class="sidebar-nav-icon">üçΩÔ∏è</span>
                        AI Planner
                    </a>
                </div>
            </div>
            <div class="sidebar-nav-section" data-section="settings">
                <div class="sidebar-nav-label" onclick="toggleSidebarSection(this)">
                    Settings
                    <svg class="collapse-icon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/>
                    </svg>
                </div>
                <div class="sidebar-nav-items">
                    <a href="coach-profile.html" class="sidebar-nav-item">
                        <span class="sidebar-nav-icon">üë§</span>
                        My Profile
                    </a>
                    <a href="supplement-protocols.html" class="sidebar-nav-item">
                        <span class="sidebar-nav-icon">üíä</span>
                        Supplements
                    </a>
                    <a href="reminder-settings.html" class="sidebar-nav-item">
                        <span class="sidebar-nav-icon">üîî</span>
                        Reminders
                    </a>
                </div>
            </div>
        </nav>
        <div class="sidebar-footer">
            <div class="sidebar-user">
                <div class="sidebar-user-avatar">C</div>
                <div class="sidebar-user-info">
                    <div class="sidebar-user-name" id="sidebarEmail">Loading...</div>
                    <div class="sidebar-user-role">Coach</div>
                </div>
                <button class="sidebar-logout" onclick="logout()" title="Logout">
                    <svg width="20" height="20" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1"></path>
                    </svg>
                </button>
            </div>
        </div>
    </aside>

    <div class="sidebar-overlay" id="sidebarOverlay"></div>

    <main class="main-content" style="background: linear-gradient(135deg, #0d9488 0%, #0284c7 100%); min-height: 100vh;">
        <header class="main-header" style="background: rgba(255,255,255,0.15); backdrop-filter: blur(10px); border-bottom: 1px solid rgba(255,255,255,0.2);">
            <button class="mobile-menu-btn" id="mobileMenuBtn" style="color: white;">
                <svg width="24" height="24" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
                </svg>
            </button>
            <h1 class="main-header-title" style="color: white;">üçΩÔ∏è AI Meal Planner</h1>
            <div class="main-header-actions"></div>
        </header>

        <div class="app-container">


    <!-- DIET PLAN VIEW -->
    <div id="diet-plan-view">
        <div class="card">
            <h2 class="text-2xl font-bold text-gray-800 mb-6" style="display: flex; align-items: center; gap: 12px;"><span style="width: 40px; height: 40px; background: linear-gradient(135deg, #0d9488 0%, #0284c7 100%); border-radius: 10px; display: flex; align-items: center; justify-content: center; color: white; font-size: 1.2rem;">&#127869;</span> Full Diet Plan Generator</h2>

            <!-- Unit System Toggle -->
            <div class="flex justify-center items-center gap-3 mb-6 p-3 bg-gray-50 rounded-lg">
                <span class="text-sm font-semibold text-gray-700">Unit System:</span>
                <div class="flex gap-2">
                    <button id="unit-imperial" class="btn btn-primary text-sm py-1 px-3">Imperial (lbs/ft)</button>
                    <button id="unit-metric" class="btn btn-secondary text-sm py-1 px-3">Metric (kg/cm)</button>
                </div>
            </div>

            <div class="space-y-6">
                <!-- Client Selector Section -->
                <div class="p-4 bg-teal-50 border-2 border-teal-400 rounded-lg">
                    <label class="font-bold text-teal-900 block mb-2">üë§ Select Client</label>
                    <div class="grid grid-cols-1 gap-3">
                        <select id="dp_client_selector" class="input-field border-2 border-teal-500" required>
                            <option value="">Loading clients...</option>
                        </select>
                        <div id="new_client_form" class="hidden">
                            <input type="text" id="dp_new_client_name" class="input-field border-2 border-teal-500" placeholder="Enter new client name" required>
                            <input type="hidden" id="dp_selected_client_id">
                        </div>
                    </div>
                </div>

                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div><label for="dp_age" class="font-semibold text-gray-700">Age</label><input type="number" id="dp_age" class="input-field" placeholder="30" required></div>
                    <div><label for="dp_gender" class="font-semibold text-gray-700">Gender</label><select id="dp_gender" class="input-field"><option value="male">Male</option><option value="female">Female</option></select></div>
                    <div><label for="dp_weight" class="font-semibold text-gray-700">Weight (lbs)</label><input type="number" id="dp_weight" class="input-field" placeholder="155" required></div>
                    <div><label for="dp_height_ft" class="font-semibold text-gray-700">Height (ft)</label><input type="number" id="dp_height_ft" class="input-field" placeholder="5" required></div>
                    <div><label for="dp_height_in" class="font-semibold text-gray-700">Height (in)</label><input type="number" id="dp_height_in" class="input-field" placeholder="10" required></div>
                    <div><label for="dp_activity" class="font-semibold text-gray-700">Activity</label><select id="dp_activity" class="input-field"><option value="1.2">Sedentary</option><option value="1.55" selected>Moderate</option><option value="1.725">Very Active</option></select></div>
                </div>

                <div class="p-4 bg-blue-50 border-2 border-blue-400 rounded-lg">
                    <label class="font-bold text-blue-900 block mb-2">üìÖ Number of Days</label>
                    <select id="dp_days" class="input-field border-2 border-blue-500">
                        <option value="1">1 Day</option>
                        <option value="2">2 Days</option>
                        <option value="3" selected>3 Days</option>
                        <option value="4">4 Days</option>
                        <option value="5">5 Days</option>
                        <option value="6">6 Days</option>
                        <option value="7">7 Days (Full Week)</option>
                    </select>
                </div>

                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div><label class="font-semibold text-gray-700">Goal</label><select id="dp_goal" class="input-field"><option value="lose weight">Lose Weight</option><option value="maintain weight" selected>Maintain</option><option value="gain muscle">Gain Muscle</option></select></div>
                    <div><label class="font-semibold text-gray-700">Calorie Adjustment</label><select id="dp_calorie_adjustment" class="input-field"><option value="0" selected>Standard (Recommended)</option><option value="-250">Slightly Aggressive (-250 cals)</option><option value="-500">Aggressive (-500 cals)</option><option value="-750">Most Aggressive (-750 cals)</option><option value="250">Slight Surplus (+250 cals)</option><option value="500">Moderate Surplus (+500 cals)</option></select></div>
                    <div><label class="font-semibold text-gray-700">Diet Type</label><select id="dp_preference" class="input-field"><option value="omnivore" selected>Omnivore</option><option value="vegetarian">Vegetarian</option><option value="vegan">Vegan</option><option value="keto">Keto</option></select></div>
                    <div><label class="font-semibold text-gray-700">Macronutrient Preference</label><select id="dp_macro_preference" class="input-field"><option value="balanced" selected>Balanced (Default)</option><option value="lower-carb">Lower Carb</option><option value="higher-carb">Higher Carb / Lower Fat</option></select></div>
                    <div><label for="dp_allergies" class="font-semibold text-gray-700">Allergies</label><input type="text" id="dp_allergies" class="input-field" placeholder="e.g., dairy, nuts"></div>
                    <div><label for="dp_disliked_foods" class="font-semibold text-gray-700">Disliked Foods</label><input type="text" id="dp_disliked_foods" class="input-field" placeholder="e.g., mushrooms, olives"></div>
                    <div><label for="dp_preferred_foods" class="font-semibold text-gray-700">Preferred Foods or Cuisines</label><input type="text" id="dp_preferred_foods" class="input-field" placeholder="e.g., Italian, Mexican"></div>
                    <div><label for="dp_budget" class="font-semibold text-gray-700">Budget (Optional)</label><input type="text" id="dp_budget" class="input-field" placeholder="e.g., $50/week"></div>
                    <div><label class="font-semibold text-gray-700">Meals Per Day</label><select id="dp_meals" class="input-field"><option value="3 meals">3 Meals</option><option value="3 meals, 1 snack" selected>3 Meals + 1 Snack</option><option value="3 meals, 2 snacks">3 Meals + 2 Snacks</option><option value="3 meals, 3 snacks">3 Meals + 3 Snacks</option></select></div>
                </div>

                <!-- Custom Targets Override -->
                <div class="p-4 bg-amber-50 border-2 border-amber-400 rounded-lg">
                    <div class="flex items-center mb-3">
                        <input type="checkbox" id="dp_custom_targets" class="mr-2 h-5 w-5">
                        <label for="dp_custom_targets" class="font-bold text-amber-900">üéØ Set Custom Targets</label>
                    </div>
                    <p class="text-sm text-amber-700 mb-3">Override the calculated targets with your own specific macros.</p>
                    <div id="custom-targets-fields" class="hidden">
                        <!-- Calories Input -->
                        <div class="mb-4">
                            <label for="dp_custom_calories" class="text-sm font-semibold text-amber-800">Total Calories</label>
                            <input type="number" id="dp_custom_calories" class="input-field border-amber-400 text-lg font-bold" placeholder="2200">
                        </div>

                        <!-- Percentage Inputs -->
                        <div class="grid grid-cols-3 gap-3">
                            <div class="bg-blue-50 p-3 rounded-lg border border-blue-200">
                                <label for="dp_protein_pct" class="text-sm font-semibold text-blue-800">Protein %</label>
                                <div class="flex items-center gap-2">
                                    <input type="number" id="dp_protein_pct" class="input-field border-blue-400 text-center font-bold" placeholder="30" min="0" max="100">
                                    <span class="text-blue-600 font-bold">%</span>
                                </div>
                                <div class="mt-2 text-center">
                                    <span class="text-lg font-bold text-blue-800" id="protein-grams-display">0g</span>
                                    <div class="text-xs text-blue-600">(<span id="protein-cals-display">0</span> cal)</div>
                                </div>
                            </div>
                            <div class="bg-green-50 p-3 rounded-lg border border-green-200">
                                <label for="dp_carbs_pct" class="text-sm font-semibold text-green-800">Carbs %</label>
                                <div class="flex items-center gap-2">
                                    <input type="number" id="dp_carbs_pct" class="input-field border-green-400 text-center font-bold" placeholder="40" min="0" max="100">
                                    <span class="text-green-600 font-bold">%</span>
                                </div>
                                <div class="mt-2 text-center">
                                    <span class="text-lg font-bold text-green-800" id="carbs-grams-display">0g</span>
                                    <div class="text-xs text-green-600">(<span id="carbs-cals-display">0</span> cal)</div>
                                </div>
                            </div>
                            <div class="bg-yellow-50 p-3 rounded-lg border border-yellow-200">
                                <label for="dp_fat_pct" class="text-sm font-semibold text-yellow-800">Fat %</label>
                                <div class="flex items-center gap-2">
                                    <input type="number" id="dp_fat_pct" class="input-field border-yellow-400 text-center font-bold" placeholder="30" min="0" max="100">
                                    <span class="text-yellow-600 font-bold">%</span>
                                </div>
                                <div class="mt-2 text-center">
                                    <span class="text-lg font-bold text-yellow-800" id="fat-grams-display">0g</span>
                                    <div class="text-xs text-yellow-600">(<span id="fat-cals-display">0</span> cal)</div>
                                </div>
                            </div>
                        </div>

                        <!-- Percentage Status Bar -->
                        <div id="pct-status-bar" class="mt-3 p-3 rounded-lg bg-gray-100 border border-gray-300">
                            <div class="flex justify-between items-center">
                                <span class="text-sm font-semibold text-gray-700">Total: <span id="total-pct" class="text-lg">0</span>%</span>
                                <span id="pct-status" class="text-sm font-bold"></span>
                            </div>
                            <div class="mt-2 h-3 bg-gray-200 rounded-full overflow-hidden">
                                <div id="pct-progress-bar" class="h-full transition-all duration-300" style="width: 0%; background: linear-gradient(to right, #3b82f6 0%, #3b82f6 33%, #22c55e 33%, #22c55e 66%, #eab308 66%, #eab308 100%);"></div>
                            </div>
                        </div>

                        <!-- Hidden fields for actual gram values (used by generateDietPlan) -->
                        <input type="hidden" id="dp_custom_protein" value="">
                        <input type="hidden" id="dp_custom_carbs" value="">
                        <input type="hidden" id="dp_custom_fat" value="">

                        <p class="text-xs text-amber-600 mt-3">üí° Enter calories and any 2 percentages - the 3rd will auto-fill to reach 100%.</p>
                    </div>
                </div>

                <!-- Cooking Equipment -->
                <div class="p-4 bg-teal-50 border-2 border-teal-400 rounded-lg">
                    <label class="font-bold text-teal-900 block mb-2">üç≥ Available Cooking Equipment</label>
                    <div class="grid grid-cols-2 md:grid-cols-3 gap-2">
                        <label class="flex items-center"><input type="checkbox" id="equip_stove" value="Stove" class="mr-2 h-4 w-4" checked> Stove</label>
                        <label class="flex items-center"><input type="checkbox" id="equip_oven" value="Oven" class="mr-2 h-4 w-4" checked> Oven</label>
                        <label class="flex items-center"><input type="checkbox" id="equip_microwave" value="Microwave" class="mr-2 h-4 w-4" checked> Microwave</label>
                        <label class="flex items-center"><input type="checkbox" id="equip_airfryer" value="Air Fryer" class="mr-2 h-4 w-4"> Air Fryer</label>
                        <label class="flex items-center"><input type="checkbox" id="equip_grill" value="Grill" class="mr-2 h-4 w-4"> Grill</label>
                        <label class="flex items-center"><input type="checkbox" id="equip_blender" value="Blender" class="mr-2 h-4 w-4" checked> Blender</label>
                    </div>
                </div>

                <!-- Branded Fitness Foods Preference -->
                <div class="p-4 bg-purple-50 border-2 border-purple-400 rounded-lg">
                    <div class="flex items-center">
                        <input type="checkbox" id="dp_use_branded_foods" class="mr-2 h-5 w-5">
                        <label for="dp_use_branded_foods" class="font-bold text-purple-900">üèãÔ∏è Use Branded Fitness Foods</label>
                    </div>
                    <p class="text-sm text-purple-700 mt-1">Include popular fitness brands like Quest Bars, Premier Protein, Fairlife, Oikos, Halo Top, and more in meal plans.</p>
                </div>

                <!-- Start from Scratch Option -->
                <div class="p-4 bg-slate-50 border-2 border-slate-400 rounded-lg">
                    <div class="flex items-center">
                        <input type="checkbox" id="dp_start_from_scratch" class="mr-2 h-5 w-5">
                        <label for="dp_start_from_scratch" class="font-bold text-slate-900">üìù DIY Meal Plan</label>
                    </div>
                    <p class="text-sm text-slate-600 mt-2">Skip auto-generated meals and get a blank template instead. You'll manually add each breakfast, lunch, dinner, and snack yourself ‚Äî ideal for clients with very specific meal preferences.</p>
                </div>

                <!-- Plan Templates -->
                <div class="p-4 bg-purple-50 border-2 border-purple-400 rounded-lg">
                    <div class="flex items-center mb-3">
                        <input type="checkbox" id="dp_use_template" class="mr-2 h-5 w-5">
                        <label for="dp_use_template" class="font-bold text-purple-900">üìã Use Plan Template</label>
                    </div>
                    <p class="text-sm text-purple-700 mb-3">Apply a saved template to quickly create a meal plan structure.</p>
                    <div id="template-selector-fields" class="hidden">
                        <div class="flex gap-2 items-center">
                            <select id="dp_template_select" class="input-field border-purple-400 flex-1">
                                <option value="">Select a template...</option>
                            </select>
                            <button id="edit-template-btn" onclick="editSelectedTemplate()" class="btn" style="background: #7c3aed; color: white; padding: 8px 12px; font-size: 12px;" title="Edit template" disabled>‚úèÔ∏è</button>
                            <button id="delete-template-btn" onclick="deleteSelectedTemplate()" class="btn" style="background: #dc2626; color: white; padding: 8px 12px; font-size: 12px;" title="Delete template" disabled>üóëÔ∏è</button>
                        </div>
                        <div id="template-preview" class="mt-2 text-sm text-purple-600 hidden"></div>
                    </div>
                </div>

                <button data-action="generate-plan" id="generate-plan-btn" class="btn btn-primary w-full text-lg">‚ú® Create Diet Plan</button>
            </div>
        </div>
        <div id="diet-plan-result"></div>
    </div>

    <!-- RECIPE MODAL -->
    <div id="recipe-modal" class="modal-overlay hidden">
        <div class="card w-11/12 md:max-w-2xl max-h-[80vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-4">
                <h3 id="recipe-title" class="text-2xl font-bold">Recipe</h3>
                <button data-action="close-modal" class="text-2xl font-bold">&times;</button>
            </div>
            <div id="recipe-content" class="text-gray-700 space-y-4 prose"></div>
        </div>
    </div>

    <!-- SHARE MODAL -->
    <div id="share-modal" class="modal-overlay hidden">
        <div class="card w-11/12 md:max-w-2xl">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-2xl font-bold text-blue-600">üîó Share Meal Plan</h3>
                <button data-action="close-share-modal" class="text-2xl font-bold">&times;</button>
            </div>
            <p class="text-gray-600 mb-4">Share this link with your client. They'll be able to view, change, and revise meals.</p>
            <div class="bg-blue-50 p-4 rounded-lg mb-4 break-all">
                <div id="share-link-text" class="text-blue-600 font-semibold">Generating link...</div>
            </div>
            <button data-action="copy-share-link" class="btn btn-primary w-full mb-2">üìã Copy Link</button>
            <button data-action="close-share-modal" class="btn btn-secondary w-full">Close</button>
        </div>
    </div>

    <!-- CUSTOM IMAGE PROMPT MODAL -->
    <div id="image-prompt-modal" class="modal-overlay hidden">
        <div class="card w-11/12 md:max-w-lg">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold text-purple-600">üì∑ Customize Image</h3>
                <button onclick="closeImagePromptModal()" class="text-2xl font-bold">&times;</button>
            </div>
            <p class="text-gray-600 mb-2">Meal: <strong id="image-prompt-meal-name"></strong></p>
            <p class="text-gray-600 mb-3">Describe how you want the image to look:</p>
            <input type="text" id="custom-image-prompt" class="input-field w-full mb-3"
                   placeholder="e.g., Shaker cup with protein shake and a banana on the side">
            <p class="text-xs text-gray-500 mb-4">üí° Tip: Be specific - mention shaker cups, plates, bowls, arrangement, etc.</p>
            <div class="flex gap-2">
                <button onclick="closeImagePromptModal()" class="btn btn-secondary flex-1">Cancel</button>
                <button onclick="submitCustomImagePrompt()" id="generate-custom-image-btn" class="btn btn-primary flex-1">üé® Generate</button>
            </div>
        </div>
    </div>

    <!-- MEAL PREP GUIDE MODAL -->
    <div id="meal-prep-modal" class="modal-overlay hidden">
        <div class="card w-11/12 md:max-w-4xl max-h-[85vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-6">
                <h3 class="text-3xl font-bold text-gray-800">üìã Meal Prep Guide</h3>
                <button data-action="close-meal-prep-modal" class="text-2xl font-bold">&times;</button>
            </div>
            <div id="meal-prep-content" class="text-gray-700 space-y-6">
                <div class="flex items-center justify-center py-12">
                    <div class="loader"><div class="loader-spinner"></div></div>
                    <p class="ml-4 text-gray-600">Generating your comprehensive meal prep guide...</p>
                </div>
            </div>
            <div class="mt-6 flex justify-end">
                <button data-action="close-meal-prep-modal" class="btn btn-secondary">Close</button>
            </div>
        </div>
    </div>

</div>

<!-- Custom Meal Modal -->
<div id="customMealModal" class="custom-meal-overlay">
    <div class="custom-meal-modal">
        <div class="custom-meal-header">
            <h2>üéØ Custom Meal</h2>
            <p style="color: #666; margin: 0;">Create your own meal</p>
        </div>

        <!-- Tabs -->
        <div class="custom-meal-tabs">
            <div class="custom-meal-tab active" onclick="switchCustomMealTab('calculate')">
                <span class="custom-meal-tab-icon">üßÆ</span>
                <span class="custom-meal-tab-label">Calculate</span>
            </div>
            <div class="custom-meal-tab" onclick="switchCustomMealTab('manual')">
                <span class="custom-meal-tab-icon">‚úèÔ∏è</span>
                <span class="custom-meal-tab-label">Manual</span>
            </div>
            <div class="custom-meal-tab" onclick="switchCustomMealTab('saved')">
                <span class="custom-meal-tab-icon">üìö</span>
                <span class="custom-meal-tab-label">My Saved</span>
            </div>
        </div>

        <!-- Calculate Panel -->
        <div id="calculatePanel" class="custom-meal-panel active">
            <div class="custom-meal-hint">
                üí° Search our food database for ingredients. Add them with quantities to calculate macros.
            </div>

            <!-- Food Search Input -->
            <div class="food-search-container">
                <input
                    type="text"
                    id="foodSearchInput"
                    class="custom-meal-input"
                    placeholder="Search foods (e.g., chicken breast, rice, Quest bar)..."
                    oninput="handleFoodSearch(this.value)"
                    autocomplete="off"
                    style="margin-bottom: 0;"
                >
                <div id="foodSearchResults" class="food-search-results"></div>
            </div>

            <!-- Selected Ingredients List -->
            <div class="selected-ingredients">
                <div class="selected-ingredients-header">
                    <span>Selected Ingredients</span>
                    <span id="ingredientCount">(0)</span>
                </div>
                <div id="ingredientsList" class="ingredients-list">
                    <div class="no-ingredients">No ingredients added yet</div>
                </div>
            </div>

            <!-- Calculated Totals -->
            <div class="calculated-totals">
                <div class="totals-header">üìä Calculated Totals</div>
                <div class="totals-grid">
                    <div class="total-item">
                        <div class="total-value" id="totalCalories">0</div>
                        <div class="total-label">Calories</div>
                    </div>
                    <div class="total-item">
                        <div class="total-value" id="totalProtein">0g</div>
                        <div class="total-label">Protein</div>
                    </div>
                    <div class="total-item">
                        <div class="total-value" id="totalCarbs">0g</div>
                        <div class="total-label">Carbs</div>
                    </div>
                    <div class="total-item">
                        <div class="total-value" id="totalFat">0g</div>
                        <div class="total-label">Fat</div>
                    </div>
                </div>
            </div>

            <!-- Meal Name -->
            <input
                type="text"
                id="calculatedMealName"
                class="custom-meal-input"
                placeholder="Meal name (optional - auto-generated if blank)"
            >

            <!-- Instructions -->
            <textarea
                id="calculatedMealInstructions"
                class="custom-meal-input"
                placeholder="Cooking instructions (optional)"
                rows="3"
                style="resize: vertical; min-height: 60px;"
            ></textarea>

            <div class="save-for-later-row">
                <input type="checkbox" id="saveCalculatedForLater">
                <label for="saveCalculatedForLater">üíæ Save this meal for future use</label>
            </div>

            <button class="btn-submit-custom" onclick="submitCalculatedMeal()" id="createCalculatedMealBtn" disabled>
                üßÆ Create Meal
            </button>
        </div>

        <!-- Manual Panel -->
        <div id="manualPanel" class="custom-meal-panel">
            <div class="custom-meal-hint">
                üí° Enter the meal name and macros directly. Use nutrition labels or apps like MyFitnessPal.
            </div>
            <input
                type="text"
                id="manualMealName"
                class="custom-meal-input"
                placeholder="Meal name (e.g., Protein Shake, Chipotle Bowl)"
            >
            <div class="macro-inputs-grid">
                <div class="macro-input-group">
                    <label>Calories</label>
                    <input type="number" id="manualCalories" placeholder="0">
                </div>
                <div class="macro-input-group">
                    <label>Protein (g)</label>
                    <input type="number" id="manualProtein" placeholder="0">
                </div>
                <div class="macro-input-group">
                    <label>Carbs (g)</label>
                    <input type="number" id="manualCarbs" placeholder="0">
                </div>
                <div class="macro-input-group">
                    <label>Fat (g)</label>
                    <input type="number" id="manualFat" placeholder="0">
                </div>
            </div>
            <textarea
                id="manualInstructions"
                class="custom-meal-input"
                placeholder="Cooking instructions (optional)"
                rows="3"
                style="resize: vertical; min-height: 60px;"
            ></textarea>

            <div class="save-for-later-row">
                <input type="checkbox" id="saveManualForLater">
                <label for="saveManualForLater">üíæ Save this meal for future use</label>
            </div>

            <button class="btn-submit-custom" onclick="submitManualMeal()">
                ‚úÖ Create Meal
            </button>
        </div>

        <!-- Saved Meals Panel -->
        <div id="savedPanel" class="custom-meal-panel">
            <div class="custom-meal-hint">
                üìö Your saved custom meals. Click "Use" to add to your plan.
            </div>
            <div id="savedMealsList" class="saved-meals-list">
                <div class="no-saved-meals">No saved meals yet. Create a meal and check "Save for future use" to add it here.</div>
            </div>
        </div>

        <button class="btn-cancel-custom" onclick="closeCustomMealModal()">Cancel</button>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script>
// Sidebar section collapse functionality
function toggleSidebarSection(label) {
    const section = label.parentElement;
    section.classList.toggle('collapsed');
    const sectionName = section.dataset.section;
    const collapsedSections = JSON.parse(localStorage.getItem('sidebarCollapsed') || '{}');
    collapsedSections[sectionName] = section.classList.contains('collapsed');
    localStorage.setItem('sidebarCollapsed', JSON.stringify(collapsedSections));
}

// Restore sidebar collapsed state on load
(function restoreSidebarState() {
    const collapsedSections = JSON.parse(localStorage.getItem('sidebarCollapsed') || '{}');
    document.querySelectorAll('.sidebar-nav-section').forEach(section => {
        const sectionName = section.dataset.section;
        if (collapsedSections[sectionName]) {
            section.classList.add('collapsed');
        }
    });
})();

// Initialize Supabase client
const SUPABASE_URL = 'https://qewqcjzlfqamqwbccapr.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFld3FjanpsZnFhbXF3YmNjYXByIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjM2OTg0NzAsImV4cCI6MjA3OTI3NDQ3MH0.mQnMC33O88oLkLLGWD2oG-oaSHGI-NfHmtQCZxnxSLs';
const { createClient } = supabase;
const supabaseClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

const API_ENDPOINT = '/.netlify/functions/generate-meal-plan';
const TOGGLE_FAVORITE_ENDPOINT = '/.netlify/functions/toggle-favorite';

// Fetch favorites for a client
async function getClientFavorites(clientId) {
    try {
        const response = await fetch(`${TOGGLE_FAVORITE_ENDPOINT}?clientId=${clientId}`);
        if (!response.ok) return [];
        const data = await response.json();
        return data.favorites || [];
    } catch (error) {
        console.error('Error fetching favorites:', error);
        return [];
    }
}
const SAVE_PLAN_ENDPOINT = '/.netlify/functions/save-shared-plan';
const SAVE_COACH_PLAN_ENDPOINT = '/.netlify/functions/save-coach-plan';
const UPDATE_PLAN_NOTES_ENDPOINT = '/.netlify/functions/update-plan-notes';
const PUBLISH_PLAN_ENDPOINT = '/.netlify/functions/publish-plan';
let lastMealQuery = {};
let lastPlanQuery = {};
let currentShareUrl = '';
let currentCoach = null;
let clientsList = [];
// Store previous meal states for undo functionality - persisted to localStorage
const UNDO_STATES_KEY = 'plannerUndoStates';
let previousMealStates = {};

// Load undo states from localStorage
function loadUndoStates() {
    try {
        const saved = localStorage.getItem(UNDO_STATES_KEY);
        if (saved) {
            previousMealStates = JSON.parse(saved);
            console.log('üìÇ Loaded undo states from localStorage');
        }
    } catch (e) {
        console.error('Error loading undo states:', e);
        previousMealStates = {};
    }
}

// Save undo states to localStorage
function saveUndoStates() {
    try {
        localStorage.setItem(UNDO_STATES_KEY, JSON.stringify(previousMealStates));
    } catch (e) {
        console.error('Error saving undo states:', e);
    }
}

// Clear all undo states (called when generating new plan)
function clearUndoStates() {
    previousMealStates = {};
    localStorage.removeItem(UNDO_STATES_KEY);
    console.log('üóëÔ∏è Cleared all undo states');
}

// Load undo states on page load
loadUndoStates();

// Warn user before leaving page with unsaved changes
let hasUnsavedChanges = false;

window.addEventListener('beforeunload', function(e) {
    // Check if there's a plan that hasn't been saved to database
    if (hasUnsavedChanges && lastPlanQuery.currentPlan && !lastPlanQuery.planId) {
        e.preventDefault();
        e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
        return e.returnValue;
    }
});

// Track when changes are made
function markUnsavedChanges() {
    hasUnsavedChanges = true;
    updateSaveButtonState();
}

// Clear unsaved changes flag after save
function clearUnsavedChanges() {
    hasUnsavedChanges = false;
    updateSaveButtonState();
}

// Update save button to reflect current state
function updateSaveButtonState() {
    const saveBtn = document.getElementById('savePlanBtn');
    if (!saveBtn) return;

    if (hasUnsavedChanges) {
        saveBtn.innerHTML = 'üíæ Save Changes*';
        saveBtn.style.background = '#f59e0b'; // Orange for unsaved
    } else {
        saveBtn.innerHTML = 'üíæ Saved';
        saveBtn.style.background = '#10b981'; // Green for saved
    }
}

// Load clients from database
async function loadClients() {
    try {
        if (!currentCoach) return;

        const response = await fetch(`/.netlify/functions/get-clients?coachId=${currentCoach.id}`);
        const data = await response.json();

        if (!response.ok) {
            throw new Error(data.error || 'Failed to load clients');
        }

        clientsList = data.clients || [];

        // Populate dropdown
        const clientSelector = document.getElementById('dp_client_selector');
        clientSelector.innerHTML = '<option value="">-- Select a Client --</option>';

        clientsList.forEach(client => {
            const option = document.createElement('option');
            option.value = client.id;
            option.textContent = client.client_name;
            clientSelector.appendChild(option);
        });

        console.log(`‚úÖ Loaded ${clientsList.length} clients`);

        // Check for clientId URL parameter and auto-select
        const urlParams = new URLSearchParams(window.location.search);
        const clientId = urlParams.get('clientId');
        if (clientId) {
            clientSelector.value = clientId;
            // Trigger change event to auto-populate fields
            clientSelector.dispatchEvent(new Event('change'));
            console.log(`‚úÖ Auto-selected client from URL: ${clientId}`);
        }

    } catch (error) {
        console.error('Error loading clients:', error);
        const clientSelector = document.getElementById('dp_client_selector');
        clientSelector.innerHTML = '<option value="new">Enter Client Name</option>';
        document.getElementById('new_client_form').classList.remove('hidden');
    }
}

// Handle client selection
document.addEventListener('DOMContentLoaded', () => {
    const clientSelector = document.getElementById('dp_client_selector');
    const newClientForm = document.getElementById('new_client_form');
    const newClientNameInput = document.getElementById('dp_new_client_name');
    const selectedClientIdInput = document.getElementById('dp_selected_client_id');

    clientSelector.addEventListener('change', (e) => {
        const selectedValue = e.target.value;

        if (selectedValue === '') {
            // No selection
            selectedClientIdInput.value = '';
        } else {
            // Client selected
            selectedClientIdInput.value = selectedValue;

            // Find the selected client and auto-populate ALL fields
            const client = clientsList.find(c => c.id === parseInt(selectedValue));
            if (client) {
                console.log('‚úÖ Auto-filling data for client:', client.client_name);

                // Physical stats
                if (client.age) document.getElementById('dp_age').value = client.age;
                if (client.gender) document.getElementById('dp_gender').value = client.gender;
                if (client.weight) document.getElementById('dp_weight').value = client.weight;
                if (client.height_ft) document.getElementById('dp_height_ft').value = client.height_ft;
                if (client.height_in) document.getElementById('dp_height_in').value = client.height_in;
                if (client.activity_level) document.getElementById('dp_activity').value = client.activity_level;

                // Goals & nutrition
                if (client.default_goal) {
                    const goalMap = {
                        'lose_weight': 'lose weight',
                        'maintain': 'maintain weight',
                        'gain_muscle': 'gain muscle'
                    };
                    const goalValue = goalMap[client.default_goal];
                    if (goalValue) document.getElementById('dp_goal').value = goalValue;
                }

                if (client.calorie_adjustment) document.getElementById('dp_calorie_adjustment').value = client.calorie_adjustment;
                if (client.diet_type) document.getElementById('dp_preference').value = client.diet_type;
                if (client.macro_preference) document.getElementById('dp_macro_preference').value = client.macro_preference;
                if (client.meal_count) document.getElementById('dp_meals').value = client.meal_count;

                // Food preferences
                if (client.allergies) document.getElementById('dp_allergies').value = client.allergies;
                if (client.disliked_foods) document.getElementById('dp_disliked_foods').value = client.disliked_foods;
                if (client.preferred_foods) document.getElementById('dp_preferred_foods').value = client.preferred_foods;
                if (client.budget) document.getElementById('dp_budget').value = client.budget;

                // Cooking equipment
                if (client.cooking_equipment && Array.isArray(client.cooking_equipment)) {
                    // Uncheck all first
                    document.querySelectorAll('input[id^="equip_"]').forEach(cb => cb.checked = false);
                    // Check the ones from client profile
                    client.cooking_equipment.forEach(equip => {
                        const equipId = 'equip_' + equip.toLowerCase().replace(/\s+/g, '');
                        const checkbox = document.getElementById(equipId);
                        if (checkbox) checkbox.checked = true;
                    });
                }

                // Branded fitness foods preference
                if (client.use_branded_foods) {
                    document.getElementById('dp_use_branded_foods').checked = true;
                } else {
                    document.getElementById('dp_use_branded_foods').checked = false;
                }

                console.log('‚úÖ All fields auto-populated from client profile');
            }
        }
    });
});

// Listen for auth state changes to handle session expiration
supabaseClient.auth.onAuthStateChange((event, session) => {
    console.log('Auth state changed:', event, session ? 'Session exists' : 'No session');

    if (event === 'SIGNED_OUT') {
        console.log('User signed out, clearing current coach');
        currentCoach = null;
    } else if (event === 'TOKEN_REFRESHED' && currentCoach) {
        console.log('Token refreshed for existing coach');
        // Reload clients if we have a coach
        loadClients();
    }
});

// Detect if page was loaded from back/forward cache and force reload
window.addEventListener('pageshow', function(event) {
    if (event.persisted) {
        // Page was loaded from bfcache (back/forward cache)
        console.log('Page loaded from cache, forcing reload...');
        window.location.reload();
    }
});

// Check authentication on page load
document.addEventListener('DOMContentLoaded', async () => {
    try {
        // Try to refresh the session to get a fresh token
        const { data: refreshData, error: refreshError } = await supabaseClient.auth.refreshSession();

        let session = null;

        // If refresh succeeded and we have a valid session with access token, use it
        if (!refreshError && refreshData?.session?.access_token) {
            session = refreshData.session;
            console.log('Session refreshed successfully');
        } else {
            // If refresh failed, session is likely expired
            console.warn('Session refresh failed or returned invalid session:', refreshError);
            session = null;
        }

        if (session) {
            currentCoach = session.user;
            console.log("Coach logged in:", currentCoach.email);

            // Update sidebar email
            const sidebarEmailEl = document.getElementById('sidebarEmail');
            if (sidebarEmailEl) {
                sidebarEmailEl.textContent = currentCoach.email;
            }

            // Load clients for the dropdown
            await loadClients();

            // Load saved meals for this coach
            await loadSavedMeals();
        } else {
            console.warn("No active session - plans will not be saved to history");
            // If no session, just show a simple text input
            const clientSelector = document.getElementById('dp_client_selector');
            clientSelector.innerHTML = '<option value="new">Enter Client Name</option>';
            document.getElementById('new_client_form').classList.remove('hidden');
        }
    } catch (error) {
        console.error("Auth error:", error);
        currentCoach = null;
    }
});

// DIRECT NETLIFY FUNCTION CALL - Now using Claude 3.5 Sonnet
async function callClaude(prompt, targets, previousAttempt = null) {
    try {
        const response = await fetch(API_ENDPOINT, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                prompt,
                targets,
                previousAttempt
            })
        });

        if (!response.ok) {
            const errorData = await response.json();
            const errorMsg = errorData.message
                ? `${errorData.error}: ${errorData.message}`
                : errorData.error || 'API request failed';
            console.error('API Error Details:', errorData);
            throw new Error(errorMsg);
        }

        const result = await response.json();

        // Claude function returns: { success: true, data: {...}, rawResponse: "..." }
        if (result.success && result.data) {
            // üîç DETAILED LOGGING FOR DEBUGGING
            console.log('\n========================================');
            console.log('üì• BACKEND RESPONSE RECEIVED');
            console.log('========================================');

            // Check if JavaScript optimizer was used
            if (result.jsOptimized) {
                console.log('‚úÖ JavaScript Optimizer: ACTIVE');
            } else {
                console.log('‚ö†Ô∏è JavaScript Optimizer: NOT DETECTED');
            }

            // Log each meal's details
            if (result.data.plan && Array.isArray(result.data.plan)) {
                console.log(`\nüìã Meals Generated: ${result.data.plan.length}`);
                result.data.plan.forEach((meal, index) => {
                    console.log(`\n--- Meal ${index + 1}: ${meal.name} ---`);
                    console.log(`   Type: ${meal.type || 'N/A'}`);
                    console.log(`   Macros: ${meal.calories}cal, ${meal.protein}P, ${meal.carbs}C, ${meal.fat}F`);

                    if (meal.ingredients && Array.isArray(meal.ingredients)) {
                        console.log(`   Ingredients (${meal.ingredients.length}):`);
                        meal.ingredients.forEach(ing => {
                            if (typeof ing === 'string') {
                                console.log(`      - ${ing}`);
                            } else if (ing.food && ing.amount) {
                                console.log(`      - ${ing.amount} ${ing.food}`);
                            }
                        });
                    }

                    if (meal.calculation_notes) {
                        console.log(`   üßÆ JS Calculation:`, meal.calculation_notes);
                    }

                    if (meal.breakdown && Array.isArray(meal.breakdown)) {
                        console.log(`   üìä Detailed Breakdown:`);
                        meal.breakdown.forEach(item => {
                            console.log(`      - ${item.amount} ${item.food}: ${item.macros.calories}cal, ${item.macros.protein}P, ${item.macros.carbs}C, ${item.macros.fat}F (√ó${item.multiplier})`);
                        });
                    }
                });

                // Log totals if available
                if (result.data.targets) {
                    console.log('\nüéØ Target Macros:');
                    console.log(`   ${result.data.targets.calories}cal, ${result.data.targets.protein}P, ${result.data.targets.carbs}C, ${result.data.targets.fat}F`);
                }
            }
            console.log('========================================\n');

            return result.data;
        } else if (result.error) {
            throw new Error(result.error);
        } else {
            throw new Error('Invalid response from Claude API');
        }
    } catch (error) {
        console.error('Claude API Error:', error);
        return { error: error.message };
    }
}

// Backwards compatibility wrapper - gradually replace callGemini with callClaude
async function callGemini(prompt, isJson = true, targets = null, previousAttempt = null, mealsPerDay = null, skipAutoScale = false) {
    // Use hybrid Gemini + Claude approach (Gemini creates, Claude optimizes)
    try {
        const requestBody = {
            prompt,
            isJson // üÜï CRITICAL: Send isJson flag to backend
        };
        if (targets) requestBody.targets = targets;
        if (mealsPerDay) requestBody.mealsPerDay = mealsPerDay;
        if (skipAutoScale) requestBody.skipAutoScale = true; // Don't auto-scale for revisions

        const response = await fetch('/.netlify/functions/generate-meal-plan', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            throw new Error('API request failed');
        }

        const data = await response.json();

        // NEW: Handle new backend format (with Claude corrections)
        if (data.success && data.data) {
            console.log('‚úÖ Using new format with Claude corrections');
            console.log('üì¶ Raw backend response:', JSON.stringify(data.data).substring(0, 500));

            // Log macros if it's a single meal
            if (data.data.calories !== undefined) {
                console.log(`üî¢ Meal macros: ${data.data.calories}cal, ${data.data.protein}P, ${data.data.carbs}C, ${data.data.fat}F`);
            }

            // Backend already parsed and corrected the meal
            if (isJson) {
                return data.data; // Already parsed JSON
            } else {
                // For text responses (like Recipe or Meal Prep Guide), return the raw text
                return data.data; // This is the raw markdown text from Gemini
            }
        }

        // FALLBACK: Old Gemini format (for backwards compatibility)
        console.log('‚ö†Ô∏è Using old Gemini format');
        let text = data.candidates[0].content.parts[0].text;

        // Clean response - remove markdown code blocks
        text = text.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim();
        text = text.replace(/:\s*NaN/g, ': null');
        text = text.replace(/,\s*\.\.\./g, '');

        if (isJson) {
            // Extract JSON array or object
            const jsonMatch = text.match(/[\[{][\s\S]*[\]}]/);
            if (jsonMatch) text = jsonMatch[0];

            try {
                return JSON.parse(text);
            } catch (parseError) {
                console.warn('First parse failed, attempting to fix JSON:', parseError.message);
                text = text.replace(/"instructions":\s*"([^"]*(?:"[^"]*)*)"}/g, (match, content) => {
                    const fixed = content.replace(/"/g, "'");
                    return `"instructions": "${fixed}"}`;
                });
                text = text.replace(/,(\s*[}\]])/g, '$1');
                return JSON.parse(text);
            }
        }
        return text;
    } catch (error) {
        console.error('AI Error:', error);
        return { error: error.message };
    }
}

// FOOD DATABASE - Real nutritional values per standard portion
const FOOD_DATABASE = {
    // Proteins
    'chicken breast': { per: '4oz', cal: 185, protein: 35, carbs: 0, fat: 4 },
    'ground turkey': { per: '4oz', cal: 200, protein: 28, carbs: 0, fat: 11 },
    'ground beef 90/10': { per: '4oz', cal: 200, protein: 24, carbs: 0, fat: 11 },
    'salmon': { per: '4oz', cal: 200, protein: 23, carbs: 0, fat: 12 },
    'tilapia': { per: '4oz', cal: 145, protein: 30, carbs: 0, fat: 3 },
    'shrimp': { per: '4oz', cal: 120, protein: 26, carbs: 0, fat: 1 },
    'egg': { per: '1 large', cal: 70, protein: 6, carbs: 0, fat: 5 },
    'greek yogurt': { per: '1 cup', cal: 150, protein: 20, carbs: 10, fat: 4 },
    'cottage cheese': { per: '1 cup', cal: 200, protein: 28, carbs: 8, fat: 5 },
    'whey protein': { per: '1 scoop', cal: 120, protein: 25, carbs: 3, fat: 1 },

    // Carbs
    'brown rice': { per: '1 cup cooked', cal: 215, protein: 5, carbs: 45, fat: 2 },
    'white rice': { per: '1 cup cooked', cal: 205, protein: 4, carbs: 45, fat: 0 },
    'quinoa': { per: '1 cup cooked', cal: 222, protein: 8, carbs: 39, fat: 4 },
    'sweet potato': { per: '1 medium', cal: 115, protein: 2, carbs: 27, fat: 0 },
    'oats': { per: '1 cup cooked', cal: 150, protein: 6, carbs: 27, fat: 3 },
    'whole wheat bread': { per: '1 slice', cal: 80, protein: 4, carbs: 14, fat: 1 },
    'pasta': { per: '1 cup cooked', cal: 220, protein: 8, carbs: 43, fat: 1 },

    // Fats
    'avocado': { per: '1/2 medium', cal: 120, protein: 1, carbs: 6, fat: 10 },
    'olive oil': { per: '1 tbsp', cal: 120, protein: 0, carbs: 0, fat: 14 },
    'almond butter': { per: '1 tbsp', cal: 95, protein: 3, carbs: 3, fat: 9 },
    'almonds': { per: '1 oz (23 nuts)', cal: 160, protein: 6, carbs: 6, fat: 14 },
    'cheese cheddar': { per: '1 oz', cal: 115, protein: 7, carbs: 0, fat: 9 },

    // Vegetables
    'broccoli': { per: '100g', cal: 35, protein: 3, carbs: 7, fat: 0 },
    'spinach': { per: '100g', cal: 23, protein: 3, carbs: 4, fat: 0 },
    'bell pepper': { per: '100g', cal: 26, protein: 1, carbs: 6, fat: 0 },

    // Fruits
    'banana': { per: '1 medium', cal: 105, protein: 1, carbs: 27, fat: 0 },
    'apple': { per: '1 medium', cal: 95, protein: 0, carbs: 25, fat: 0 },
    'blueberries': { per: '1 cup', cal: 85, protein: 1, carbs: 21, fat: 0 }
};

// MEAL VALIDATION FUNCTION
function validateMeal(meal, mealType) {
    const issues = [];

    // Skip validation for supplement items (user-defined values)
    if (mealType === 'supplement' || meal.type === 'supplement') {
        return { valid: true, issues: [] };
    }

    // Validation 1: Macro math check - ALIGNED with Claude's 8% tolerance
    const calculatedCalories = (meal.protein * 4) + (meal.carbs * 4) + (meal.fat * 9);
    const calorieDifference = Math.abs(meal.calories - calculatedCalories);
    const percentOff = calorieDifference / meal.calories;

    if (percentOff > 0.08) { // More than 8% off - matches Claude's training
        issues.push(`Macro math error: ${meal.calories} cal listed but macros calculate to ${Math.round(calculatedCalories)} cal (${Math.round(percentOff*100)}% error)`);
    }

    // Validation 2: Minimum calorie check - catch single-ingredient "meals"
    const mealCalories = (typeof meal.calories === 'number' && !isNaN(meal.calories)) ? meal.calories : 0;
    const mealTypeForCal = (mealType || meal.type || '').toLowerCase();
    let minCalories = 50; // Default minimum
    if (mealTypeForCal === 'breakfast') {
        minCalories = 200; // Breakfast: at least 200 cal
    } else if (mealTypeForCal === 'lunch' || mealTypeForCal === 'dinner') {
        minCalories = 300; // Main meals: at least 300 cal
    } else if (mealTypeForCal === 'snack' || mealTypeForCal.includes('snack')) {
        minCalories = 100; // Snacks: at least 100 cal
    }

    if (mealCalories < minCalories) {
        issues.push(`Insufficient calories for ${mealTypeForCal}: ${mealCalories} cal (minimum ${minCalories} cal required)`);
    }

    // Validation 3: Minimum ingredient count - real meals have multiple ingredients
    const ingredientCount = (meal.ingredients && Array.isArray(meal.ingredients)) ? meal.ingredients.length : 0;
    let minIngredients = 1;
    if (mealTypeForCal === 'breakfast' || mealTypeForCal === 'lunch' || mealTypeForCal === 'dinner') {
        minIngredients = 2; // Main meals should have at least 2 ingredients
    }

    if (ingredientCount < minIngredients) {
        issues.push(`Insufficient ingredients for ${mealTypeForCal}: ${ingredientCount} (minimum ${minIngredients} required)`);
    }

    // Validation 4: Sanity check on macros
    if (meal.protein < 0 || meal.carbs < 0 || meal.fat < 0) {
        issues.push('Negative macro values detected');
    }

    if (meal.protein > 100 || meal.carbs > 150 || meal.fat > 80) {
        issues.push('Unrealistically high macro values in single meal');
    }

    // Validation 4b: Minimum protein check - main meals should have adequate protein
    // This catches AI failures that generate vegetable-only meals without protein sources
    const mealTypeLower = (mealType || meal.type || '').toLowerCase();
    let minProtein = 0;
    if (mealTypeLower === 'breakfast') {
        minProtein = 10; // Breakfast: at least 10g protein
    } else if (mealTypeLower === 'lunch' || mealTypeLower === 'dinner') {
        minProtein = 15; // Main meals: at least 15g protein
    } else if (mealTypeLower === 'snack' || mealTypeLower.includes('snack')) {
        minProtein = 3; // Snacks: at least 3g protein (allows fruit-based snacks)
    }

    // Handle undefined/null/NaN protein values - treat as 0
    const mealProtein = (typeof meal.protein === 'number' && !isNaN(meal.protein)) ? meal.protein : 0;
    if (minProtein > 0 && mealProtein < minProtein) {
        issues.push(`Insufficient protein for ${mealTypeLower}: ${mealProtein}g (minimum ${minProtein}g required)`);
    }

    // Validation 5: Protein source validation - catch impossible protein claims
    const mealNameLower = meal.name.toLowerCase();

    // Check protein limits based on portion sizes in meal name
    const proteinChecks = [
        // Whey protein - STRICT LIMIT
        { regex: /1\s*scoop.*(?:whey|protein powder)/i, maxProtein: 30, name: '1 scoop protein' },
        { regex: /2\s*scoop.*(?:whey|protein powder)/i, maxProtein: 55, name: '2 scoops protein' },

        // Chicken breast
        { regex: /4\s*oz.*chicken/i, maxProtein: 40, name: '4oz chicken' },
        { regex: /6\s*oz.*chicken/i, maxProtein: 55, name: '6oz chicken' },
        { regex: /8\s*oz.*chicken/i, maxProtein: 75, name: '8oz chicken' },

        // Ground turkey
        { regex: /4\s*oz.*(?:ground\s*)?turkey/i, maxProtein: 32, name: '4oz turkey' },
        { regex: /6\s*oz.*(?:ground\s*)?turkey/i, maxProtein: 48, name: '6oz turkey' },

        // Salmon/fish
        { regex: /4\s*oz.*(?:salmon|fish)/i, maxProtein: 28, name: '4oz salmon/fish' },
        { regex: /6\s*oz.*(?:salmon|fish)/i, maxProtein: 40, name: '6oz salmon/fish' },

        // Eggs
        { regex: /2\s*(?:large\s*)?egg/i, maxProtein: 14, name: '2 eggs' },
        { regex: /3\s*(?:large\s*)?egg/i, maxProtein: 20, name: '3 eggs' },
        { regex: /4\s*(?:large\s*)?egg/i, maxProtein: 26, name: '4 eggs' },

        // Greek yogurt
        { regex: /1\s*cup.*greek yogurt/i, maxProtein: 22, name: '1 cup Greek yogurt' },
        { regex: /2\s*cup.*greek yogurt/i, maxProtein: 42, name: '2 cups Greek yogurt' }
    ];

    for (const check of proteinChecks) {
        if (check.regex.test(mealNameLower)) {
            if (meal.protein > check.maxProtein) {
                issues.push(`Protein impossible for ${check.name}: ${meal.protein}g claimed but max ~${check.maxProtein}g from that portion`);
            }
        }
    }

    // Validation 6: Realistic portion sizes for common high-calorie foods
    const calorieFloorChecks = [
        { keywords: ['burrito', 'wrap with'], minCal: 400, name: 'Burrito/Large wrap' },
        { keywords: ['pizza', 'slice'], minCal: 250, name: 'Pizza' },
        { keywords: ['burger', 'cheeseburger'], minCal: 400, name: 'Burger' },
        { keywords: ['pasta', 'spaghetti', 'fettuccine', 'penne'], minCal: 350, name: 'Pasta dish' },
        { keywords: ['fried'], minCal: 300, name: 'Fried food' },
        { keywords: ['quesadilla'], minCal: 400, name: 'Quesadilla' },
        { keywords: ['sandwich with'], minCal: 350, name: 'Large sandwich' },
        { keywords: ['steak', 'ribeye', 'sirloin'], minCal: 300, name: 'Steak meal' },
        { keywords: ['bacon'], minCal: 200, name: 'Meal with bacon' }
    ];

    for (const check of calorieFloorChecks) {
        if (check.keywords.some(kw => mealNameLower.includes(kw))) {
            if (meal.calories < check.minCal) {
                issues.push(`${check.name} is unrealistically low: ${meal.calories} cal (minimum ${check.minCal} cal expected)`);
            }
        }
    }

    // CRITICAL: Flag meals as invalid if they have no actual content
    // This catches AI failures that return empty/placeholder meals
    const isEmptyMeal = (
        meal.calories === 0 ||
        !meal.ingredients ||
        !Array.isArray(meal.ingredients) ||
        meal.ingredients.length === 0 ||
        !meal.name ||
        meal.name === 'Meal' ||
        meal.name === 'Unnamed Meal' ||
        meal.name.toLowerCase().startsWith('[add ')
    );

    if (isEmptyMeal) {
        issues.unshift('Empty or placeholder meal detected - needs regeneration');
    }

    // Check for blocking issues - any of these should trigger regeneration
    const hasInsufficientProtein = issues.some(issue => issue.includes('Insufficient protein'));
    const hasInsufficientCalories = issues.some(issue => issue.includes('Insufficient calories'));
    const hasInsufficientIngredients = issues.some(issue => issue.includes('Insufficient ingredients'));

    const hasBlockingIssue = isEmptyMeal || hasInsufficientProtein || hasInsufficientCalories || hasInsufficientIngredients;

    return {
        valid: !hasBlockingIssue, // Any blocking issue makes meal invalid
        issues: issues,
        meal: meal
    };
}

// VALIDATE ENTIRE DAY'S TOTALS
function validateDayTotals(dayData) {
    const targets = dayData.targets;
    const plan = dayData.plan;

    // Calculate actual totals
    const actualCals = plan.reduce((sum, meal) => sum + meal.calories, 0);
    const actualProtein = plan.reduce((sum, meal) => sum + meal.protein, 0);
    const actualCarbs = plan.reduce((sum, meal) => sum + meal.carbs, 0);
    const actualFat = plan.reduce((sum, meal) => sum + meal.fat, 0);

    // DISABLED: Trust Claude optimization + USDA database instead of strict validation
    // Claude optimizes each meal to hit targets using accurate database
    // Validation was causing false negatives and blocking good meal plans
    console.log(`üìä Daily totals: ${actualCals} cal, ${actualProtein}g P, ${actualCarbs}g C, ${actualFat}g F`);
    console.log(`üéØ Targets:      ${targets.calories} cal, ${targets.protein}g P, ${targets.carbs}g C, ${targets.fat}g F`);

    const calDiff = Math.abs(actualCals - targets.calories) / targets.calories;
    const proteinDiff = Math.abs(actualProtein - targets.protein) / targets.protein;
    const carbsDiff = Math.abs(actualCarbs - targets.carbs) / targets.carbs;
    const fatDiff = Math.abs(actualFat - targets.fat) / targets.fat;

    console.log(`üìà Variance: ${(calDiff * 100).toFixed(1)}% cal, ${(proteinDiff * 100).toFixed(1)}% P, ${(carbsDiff * 100).toFixed(1)}% C, ${(fatDiff * 100).toFixed(1)}% F`);

    // Always return valid - trust the optimization
    return {
        valid: true,
        issues: [],
        totals: { calories: actualCals, protein: actualProtein, carbs: actualCarbs, fat: actualFat }
    };
}

// MULTI-DAY DIET PLAN GENERATOR
async function generateDietPlan() {
    const resultDiv = document.getElementById('diet-plan-result');
    const button = document.getElementById('generate-plan-btn');

    const age = document.getElementById('dp_age').value;
    const weight = document.getElementById('dp_weight').value;
    const heightFt = document.getElementById('dp_height_ft').value;
    const heightIn = document.getElementById('dp_height_in').value;

    if (!age || !weight || !heightFt) {
        alert('Please fill in all required fields');
        return;
    }

    // Show animated progress loader
    resultDiv.innerHTML = `
        <div class="card" style="text-align: center; padding: 40px;">
            <div class="loader"><div class="loader-spinner"></div></div>
            <p id="generation-status" class="text-center text-gray-700 font-semibold mt-4" style="font-size: 1.1rem;">Initializing meal plan generator...</p>
            <p id="generation-substatus" class="text-center text-gray-500 mt-2" style="font-size: 0.9rem;">This usually takes 15-30 seconds</p>
            <div style="margin-top: 20px; background: #e5e7eb; border-radius: 10px; height: 8px; overflow: hidden;">
                <div id="generation-progress-bar" style="width: 5%; height: 100%; background: linear-gradient(90deg, #0d9488, #0ea5e9); transition: width 0.5s ease;"></div>
            </div>
        </div>
    `;
    button.disabled = true;

    // Animated progress messages
    const progressMessages = [
        { msg: "Analyzing client preferences...", sub: "Reviewing dietary requirements", progress: 10 },
        { msg: "Calculating optimal nutrition targets...", sub: "BMR, TDEE, and macro ratios", progress: 20 },
        { msg: "Generating breakfast options...", sub: "Finding the perfect morning meals", progress: 35 },
        { msg: "Creating lunch ideas...", sub: "Balanced midday nutrition", progress: 50 },
        { msg: "Planning dinner selections...", sub: "Satisfying evening meals", progress: 65 },
        { msg: "Adding snacks...", sub: "Healthy options between meals", progress: 75 },
        { msg: "Optimizing macro balance...", sub: "Fine-tuning protein, carbs, and fats", progress: 85 },
        { msg: "Finalizing your meal plan...", sub: "Almost ready!", progress: 95 }
    ];

    let messageIndex = 0;
    const progressInterval = setInterval(() => {
        if (messageIndex < progressMessages.length) {
            const status = document.getElementById('generation-status');
            const substatus = document.getElementById('generation-substatus');
            const progressBar = document.getElementById('generation-progress-bar');

            if (status && substatus && progressBar) {
                status.textContent = progressMessages[messageIndex].msg;
                substatus.textContent = progressMessages[messageIndex].sub;
                progressBar.style.width = progressMessages[messageIndex].progress + '%';
            }
            messageIndex++;
        }
    }, 3000);

    // Store interval ID to clear later
    window.currentProgressInterval = progressInterval;

    // Clear undo states from previous plan
    clearUndoStates();

    // Get client from selector
    let clientName = 'Client';
    let clientId = null;
    const clientSelector = document.getElementById('dp_client_selector');
    const selectedValue = clientSelector.value;

    if (!selectedValue || selectedValue === "") {
        // No client selected
        alert('‚ö†Ô∏è Please select a client from the dropdown before generating a plan.');
        button.disabled = false;
        resultDiv.innerHTML = '';
        return;
    }

    // Parse and validate client ID
    clientId = parseInt(selectedValue);
    if (isNaN(clientId) || clientId <= 0) {
        alert('‚ö†Ô∏è Invalid client selection. Please select a valid client from the dropdown.');
        button.disabled = false;
        resultDiv.innerHTML = '';
        return;
    }

    // Ensure client exists in the list
    const client = clientsList.find(c => c.id === clientId);
    if (!client) {
        alert('‚ö†Ô∏è Selected client not found. Please refresh the page and try again.');
        button.disabled = false;
        resultDiv.innerHTML = '';
        return;
    }

    clientName = client.client_name;

    // Fetch client's favorite meals
    const clientFavorites = await getClientFavorites(clientId);
    let favoriteMealsText = '';
    if (clientFavorites.length > 0) {
        const favoriteMealsList = clientFavorites.slice(0, 10).map(f => {
            return `- ${f.meal_name} (${f.meal_type || 'meal'}: ${f.calories || '?'} cal, ${f.protein || '?'}g protein)`;
        }).join('\n');
        favoriteMealsText = `\n\nCLIENT'S FAVORITE MEALS (try to include 1-2 of these or similar variations):\n${favoriteMealsList}`;
        console.log(`Loaded ${clientFavorites.length} favorites for client ${clientId}`);
    }

    const gender = document.getElementById('dp_gender').value;
    const activity = parseFloat(document.getElementById('dp_activity').value);
    const goal = document.getElementById('dp_goal').value;
    const calorieAdjustment = parseInt(document.getElementById('dp_calorie_adjustment').value);
    const preference = document.getElementById('dp_preference').value;
    const macroPreference = document.getElementById('dp_macro_preference').value;
    const allergies = document.getElementById('dp_allergies').value || 'none';
    const dislikedFoods = document.getElementById('dp_disliked_foods').value || 'none';
    const preferredFoods = document.getElementById('dp_preferred_foods').value || 'none';
    const budget = document.getElementById('dp_budget').value || 'none';
    const meals = document.getElementById('dp_meals').value;
    const numDays = parseInt(document.getElementById('dp_days').value);

    // Get cooking equipment
    const equipment = [];
    if (document.getElementById('equip_stove').checked) equipment.push('Stove');
    if (document.getElementById('equip_oven').checked) equipment.push('Oven');
    if (document.getElementById('equip_microwave').checked) equipment.push('Microwave');
    if (document.getElementById('equip_airfryer').checked) equipment.push('Air Fryer');
    if (document.getElementById('equip_grill').checked) equipment.push('Grill');
    if (document.getElementById('equip_blender').checked) equipment.push('Blender');
    const equipmentStr = equipment.length > 0 ? equipment.join(', ') : 'basic kitchen tools';

    // Get branded fitness foods preference
    const useBrandedFoods = document.getElementById('dp_use_branded_foods').checked;
    console.log('üèãÔ∏è Branded foods preference:', useBrandedFoods);

    // Calculate nutrition (Mifflin-St Jeor)
    let weightKg, heightCm;
    if (currentUnitSystem === 'imperial') {
        weightKg = parseFloat(weight) * 0.453592;
        heightCm = (parseInt(heightFt) * 30.48) + (parseInt(heightIn || 0) * 2.54);
    } else {
        weightKg = parseFloat(weight);
        heightCm = parseFloat(heightFt);
    }

    let bmr;
    if (gender === 'male') {
        bmr = (10 * weightKg) + (6.25 * heightCm) - (5 * parseInt(age)) + 5;
    } else {
        bmr = (10 * weightKg) + (6.25 * heightCm) - (5 * parseInt(age)) - 161;
    }

    let tdee = bmr * activity;
    if (goal === 'lose weight') tdee -= 500;
    if (goal === 'gain muscle') tdee += 300;

    // Apply calorie adjustment
    tdee += calorieAdjustment;

    let calories = Math.round(tdee);

    // Calculate macros based on macro preference
    let proteinRatio, carbRatio, fatRatio;
    if (macroPreference === 'lower-carb') {
        proteinRatio = 0.35;
        carbRatio = 0.25;
        fatRatio = 0.40;
    } else if (macroPreference === 'higher-carb') {
        proteinRatio = 0.25;
        carbRatio = 0.50;
        fatRatio = 0.25;
    } else { // balanced
        proteinRatio = 0.30;
        carbRatio = 0.40;
        fatRatio = 0.30;
    }

    let protein = Math.round((calories * proteinRatio) / 4);
    let carbs = Math.round((calories * carbRatio) / 4);
    let fat = Math.round((calories * fatRatio) / 9);

    // Check for custom targets override
    if (document.getElementById('dp_custom_targets').checked) {
        const customCalories = parseInt(document.getElementById('dp_custom_calories').value);
        const customProtein = parseInt(document.getElementById('dp_custom_protein').value);
        const customCarbs = parseInt(document.getElementById('dp_custom_carbs').value);
        const customFat = parseInt(document.getElementById('dp_custom_fat').value);

        // Only override if valid values are provided
        if (customCalories > 0) calories = customCalories;
        if (customProtein > 0) protein = customProtein;
        if (customCarbs > 0) carbs = customCarbs;
        if (customFat > 0) fat = customFat;

        console.log('Using custom targets:', { calories, protein, carbs, fat });
    }

    // Store original targets
    const originalTargets = {
        calories: calories,
        protein: protein,
        carbs: carbs,
        fat: fat
    };

    lastPlanQuery = {
        clientName,
        clientId,
        calories: Math.round(tdee),
        protein,
        carbs,
        fat,
        preference,
        macroPreference,
        allergies,
        dislikedFoods,
        preferredFoods,
        budget,
        equipmentStr,
        meals,
        originalTargets,
        useBrandedFoods
    };

    // Check for Start from Scratch mode
    const startFromScratch = document.getElementById('dp_start_from_scratch').checked;

    if (startFromScratch) {
        console.log('üìù Starting from scratch - creating empty meal plan structure');

        // Determine meal types based on selection
        let expectedMealTypes = [];
        if (meals === '3 meals') {
            expectedMealTypes = ['breakfast', 'lunch', 'dinner'];
        } else if (meals === '3 meals, 1 snack') {
            expectedMealTypes = ['breakfast', 'lunch', 'dinner', 'snack'];
        } else if (meals === '3 meals, 2 snacks') {
            expectedMealTypes = ['breakfast', 'lunch', 'dinner', 'snack', 'snack'];
        } else if (meals === '3 meals, 3 snacks') {
            expectedMealTypes = ['breakfast', 'lunch', 'dinner', 'snack', 'snack', 'snack'];
        } else {
            expectedMealTypes = ['breakfast', 'lunch', 'dinner', 'snack'];
        }

        const allDays = [];
        for (let day = 1; day <= numDays; day++) {
            const dayPlan = expectedMealTypes.map((mealType, idx) => {
                const mealLabel = mealType === 'snack'
                    ? `Snack ${expectedMealTypes.slice(0, idx + 1).filter(t => t === 'snack').length}`
                    : mealType.charAt(0).toUpperCase() + mealType.slice(1);
                return {
                    type: mealType,
                    name: `[Add ${mealLabel}]`,
                    calories: 0,
                    protein: 0,
                    carbs: 0,
                    fat: 0,
                    ingredients: [],
                    instructions: 'Click "Replace" or "Add Custom" to add a meal here.',
                    isPlaceholder: true
                };
            });

            allDays.push({
                day: day,
                targets: originalTargets,
                plan: dayPlan
            });
        }

        lastPlanQuery.currentPlan = allDays;
        lastPlanQuery.startedFromScratch = true;
        markUnsavedChanges();
        lastPlanQuery.summary = generatePlanSummary(lastPlanQuery);

        // Clear progress animation
        if (window.currentProgressInterval) clearInterval(window.currentProgressInterval);

        displayDietPlan(allDays);

        const saveSuccess = await saveCoachPlan(lastPlanQuery, lastPlanQuery.clientName);
        if (!saveSuccess) {
            showSaveRetryButton();
        }

        button.disabled = false;
        return; // Exit early - skip AI generation
    }

    // Check for template application
    const useTemplate = document.getElementById('dp_use_template').checked;
    const selectedTemplateId = document.getElementById('dp_template_select').value;

    if (useTemplate && selectedTemplateId) {
        console.log('üìã Applying template:', selectedTemplateId);

        const templatePlan = applyTemplate(selectedTemplateId);
        if (templatePlan) {
            // Adjust template to match requested number of days
            const allDays = [];
            for (let day = 1; day <= numDays; day++) {
                // Use template day if available, otherwise cycle through template days
                const templateDayIndex = (day - 1) % templatePlan.length;
                const templateDay = templatePlan[templateDayIndex];

                const dayPlan = templateDay.plan.map(meal => ({
                    ...meal,
                    // Keep meal data but reset any client-specific info
                }));

                allDays.push({
                    day: day,
                    targets: originalTargets,
                    plan: dayPlan
                });
            }

            lastPlanQuery.currentPlan = allDays;
            lastPlanQuery.fromTemplate = selectedTemplateId;
            markUnsavedChanges();
            lastPlanQuery.summary = generatePlanSummary(lastPlanQuery);

            // Clear progress animation
            if (window.currentProgressInterval) clearInterval(window.currentProgressInterval);

            displayDietPlan(allDays);

            const saveSuccess = await saveCoachPlan(lastPlanQuery, lastPlanQuery.clientName);
            if (!saveSuccess) {
                showSaveRetryButton();
            }

            button.disabled = false;
            return; // Exit early - skip AI generation
        }
    }

    // Generate each day separately
    const allDays = [];
    for (let day = 1; day <= numDays; day++) {
        // Build a list of previously used meals to ensure variety
        let previousMealsText = '';
        if (allDays.length > 0) {
            const previousMeals = [];
            allDays.forEach(dayData => {
                dayData.plan.forEach(meal => {
                    previousMeals.push(meal.name);
                });
            });
            previousMealsText = `\n\nPREVIOUS DAYS MEALS (DO NOT REPEAT):\n${previousMeals.join('\n')}\n\nIMPORTANT: Create COMPLETELY DIFFERENT meals from the previous days listed above. Provide variety in proteins, cuisines, and cooking methods.`;
        }

        // Build branded fitness foods note if applicable
        let brandedFoodsNote = '';
        if (useBrandedFoods) {
            brandedFoodsNote = `

‚ö†Ô∏è MANDATORY BRANDED FITNESS FOODS REQUIREMENT ‚ö†Ô∏è
YOU MUST include branded fitness products in this meal plan. This is NOT optional.

REQUIRED: Include AT LEAST 2-3 of these branded items per day:
‚Ä¢ SNACKS: Use Quest Bar, RXBar, Built Bar, ONE Bar, or Barebells protein bar
‚Ä¢ PROTEIN DRINKS: Use Premier Protein shake, Fairlife protein shake, or Core Power
‚Ä¢ YOGURT: Use Oikos Triple Zero, Chobani Zero Sugar, Two Good, or Siggi's
‚Ä¢ BREAKFAST: Use Kodiak Cakes pancakes/waffles or Magic Spoon cereal
‚Ä¢ BREAD: Use Dave's Killer Bread or Ezekiel bread for sandwiches/toast

Example meal names that USE branded foods correctly:
- "Quest Bar (1 bar) with Banana (1 medium)" for snack
- "Premier Protein Chocolate Shake (1 bottle) with Almonds (28g)" for snack
- "Oikos Triple Zero Vanilla (170g) with Berries (100g) and Granola (30g)" for breakfast
- "Kodiak Cakes Protein Pancakes (2 cakes) with Maple Syrup (30ml) and Eggs (2)" for breakfast

DO NOT just use generic "Greek Yogurt" or "Protein Bar" - use the SPECIFIC BRAND NAMES listed above.
FAILURE to include branded products will be considered an error.`;
        }

        // Parse meal structure to be explicit
        let mealStructure = '';
        let expectedMealTypes = [];

        if (meals === '3 meals') {
            mealStructure = 'EXACTLY 3 meals: breakfast, lunch, dinner';
            expectedMealTypes = ['breakfast', 'lunch', 'dinner'];
        } else if (meals === '3 meals, 1 snack') {
            mealStructure = 'EXACTLY 4 items: breakfast, lunch, dinner, and 1 snack';
            expectedMealTypes = ['breakfast', 'lunch', 'dinner', 'snack'];
        } else if (meals === '3 meals, 2 snacks') {
            mealStructure = 'EXACTLY 5 items: breakfast, lunch, dinner, and 2 snacks';
            expectedMealTypes = ['breakfast', 'lunch', 'dinner', 'snack', 'snack'];
        } else if (meals === '3 meals, 3 snacks') {
            mealStructure = 'EXACTLY 6 items: breakfast, lunch, dinner, and 3 snacks';
            expectedMealTypes = ['breakfast', 'lunch', 'dinner', 'snack', 'snack', 'snack'];
        } else {
            // Default fallback if meals value is invalid
            console.warn(`Invalid meals value: "${meals}". Defaulting to 3 meals + 1 snack`);
            mealStructure = 'EXACTLY 4 items: breakfast, lunch, dinner, and 1 snack';
            expectedMealTypes = ['breakfast', 'lunch', 'dinner', 'snack'];
        }

        const variationSeed = Math.floor(Math.random() * 1000000);

        // Goal-based fat/oil guidance - STRICT LIMITS
        const fatPerMeal = Math.round(fat / expectedMealTypes.length);
        const fatGuidance = goal === 'lose weight'
            ? `4. FATS - STRICT LIMITS (WEIGHT LOSS):
   üö® DAILY FAT BUDGET: ${fat}g total = ~${fatPerMeal}g per meal MAX

   HARD RULES:
   - Nuts: MAX 28g per serving (NEVER 40g+!)
   - Avocado: MAX 50g per meal
   - Oils/Butter: MAX 1 tsp per meal (5g fat)
   - DO NOT STACK: If meal has eggs, skip nuts. If meal has salmon, skip avocado.

   üç≥ BREAKFAST FAT STACKING PREVENTION:
   - Eggs + Ground Meat = ALREADY HIGH FAT ‚Üí NO butter/oil allowed!
   - Eggs (2) = 10g fat + Ground Turkey (100g) = 10g fat = 20g already!
   - If using eggs + meat: cook with spray or non-stick, NOT butter/oil
   - CHOOSE: Eggs alone (can use 1 tsp butter) OR Eggs + lean meat (no added fat)

   üêü FATTY FISH STACKING PREVENTION:
   - Salmon, Mackerel, Sardines = HIGH FAT ‚Üí NO butter/oil allowed!
   - Salmon (150g) = 17g fat already ‚Üí NO olive oil, NO butter!
   - Mackerel (150g) = 21g fat already ‚Üí NO added fats!
   - ONLY add oil/butter to LEAN fish: cod, tilapia, halibut, shrimp, tuna

   CHOOSE ONE FAT SOURCE PER MEAL:
   ‚úÖ Eggs (3 whole) = 15g fat - no other fat needed
   ‚úÖ Salmon (150g) = 17g fat - no other fat needed
   ‚úÖ Nuts (28g) = 14g fat - don't add with eggs
   ‚ùå Eggs + Ground Meat + Butter = 25g+ fat - TOO MUCH!
   ‚ùå Salmon + Olive Oil = 22g+ fat - TOO MUCH!
   ‚ùå Eggs + Avocado + Nuts = TOO MUCH FAT!`
            : `4. FATS - STRICT LIMITS (STAY WITHIN ${fat}g DAILY):
   üö® DAILY FAT BUDGET: ${fat}g total = ~${fatPerMeal}g per meal MAX

   HARD RULES - MUST FOLLOW:
   - Nuts: MAX 28-35g per serving (NEVER 50g+!)
   - Avocado: MAX 75g per meal
   - Oils/Butter: MAX 1 tsp per meal
   - Eggs: Count 5g fat per egg

   üç≥ BREAKFAST FAT STACKING PREVENTION:
   - Eggs + Ground Meat = HIGH FAT COMBO ‚Üí limit or skip butter/oil!
   - Eggs (2) = 10g fat + Ground Turkey (100g) = 10g fat = 20g already!
   - Eggs (3) + Ground Beef (100g) = 25g fat ‚Üí NO room for oil!
   - If using eggs + any ground meat: use cooking spray, NOT butter/oil
   - BETTER: Eggs + lean meat (turkey breast, chicken breast) = can add 1 tsp oil

   üêü FATTY FISH STACKING PREVENTION:
   - Salmon, Mackerel, Sardines = ALREADY HIGH FAT ‚Üí skip butter/oil!
   - Salmon (150g) = 17g fat ‚Üí NO olive oil needed!
   - Mackerel (150g) = 21g fat ‚Üí NO butter needed!
   - Sardines (100g) = 11g fat ‚Üí minimal added fat
   - LEAN fish (cod, tilapia, halibut, shrimp) = CAN add 1 tsp oil/butter

   DO NOT STACK MULTIPLE FAT SOURCES:
   ‚ùå WRONG: Eggs (4) + Almonds (50g) + Avocado = 60g+ fat in one meal!
   ‚ùå WRONG: Eggs (3) + Ground Turkey (130g) + Butter (1 tbsp) = 35g+ fat!
   ‚ùå WRONG: Salmon (160g) + Olive Oil (1 tsp) = 23g+ fat in one meal!
   ‚úÖ RIGHT: Eggs (3) + vegetables + carbs = balanced meal
   ‚úÖ RIGHT: Eggs (2) + Ground Turkey (100g) + veggies = 20g fat (no oil needed)
   ‚úÖ RIGHT: Salmon (150g) + Rice + Vegetables = 17g fat (no oil needed)

   FAT BUDGET CHECK:
   - Eggs (3 whole) = 15g fat ‚Üí leaves room for 1 tsp oil only
   - Salmon (150g) = 17g fat ‚Üí NO added fat needed
   - Mackerel (150g) = 21g fat ‚Üí NO added fat needed
   - Nuts (35g) = 18g fat ‚Üí don't combine with fatty protein
   - Eggs + Ground Meat = 20-25g fat ‚Üí NO added fat!
   - If protein is lean (chicken breast, cod, tilapia) ‚Üí can add ONE fat source`;

        // Goal-based meal examples
        const mealExamples = goal === 'lose weight'
            ? `EXAMPLES OF WINNING MEALS (WEIGHT LOSS - FAT CONTROLLED):
Breakfast Option A: ["Eggs (3 whole)", "Oats (50g dry)", "Blueberries (100g)"] - 15g fat from eggs ONLY
Breakfast Option B: ["Eggs (2 whole)", "Ground Turkey (100g)", "Spinach (100g)", "Bell Peppers (80g)"] - 20g fat total, NO butter needed!
Lunch with LEAN fish: ["Cod (200g)", "Brown Rice (200g cooked)", "Broccoli (150g)", "Olive Oil (1 tsp)"] - lean fish + oil OK
Lunch with FATTY fish: ["Salmon (150g)", "Quinoa (200g cooked)", "Asparagus (150g)"] - 17g fat from salmon, NO oil!
Dinner: ["Chicken Breast (150g)", "Sweet Potato (200g)", "Green Beans (150g)", "Butter (1 tsp)"] - lean protein + small fat
Snack: ["Greek Yogurt Nonfat (200g)", "Strawberries (100g)", "Almonds (28g)"] - 14g fat from nuts only
Protein Shake Snack: ["Whey Protein (1 scoop)", "Almond Milk Unsweetened (125ml)", "Blueberries (60g)", "Strawberries (50g)"] - blended smoothie
Protein Smoothie Breakfast: ["Whey Protein (1 scoop)", "Almond Milk Unsweetened (250ml)", "Banana (1 medium)", "Oats (40g dry)"] - blended proats shake
Protein Shake + Sides: ["Whey Protein (2 scoops)", "Water (250ml)", "Apple (2 medium)", "Whole Wheat Bread (2 slices)", "Almond Butter (1 tbsp)"] - shaker cup shake with solid food

üö® FAT STACKING ERRORS TO AVOID:
‚ùå ["Eggs (3)", "Ground Turkey (130g)", "Butter (1 tbsp)"] = 35g fat - WRONG! No butter with eggs + meat!
‚ùå ["Salmon (160g)", "Brown Rice (200g)", "Olive Oil (1 tsp)"] = 23g fat - WRONG! No oil with salmon!
‚ùå ["Eggs (4)", "Avocado (100g)", "Almonds (50g)"] = 55g fat - TOO MUCH!`
            : `EXAMPLES OF WINNING MEALS (FAT CONTROLLED - MAX ${fatPerMeal}g per meal):
Breakfast Option A: ["Eggs (3 whole)", "Oats (60g dry)", "Banana (1 medium)"] - 15g fat from eggs, no extra needed
Breakfast Option B: ["Eggs (2 whole)", "Ground Turkey (100g)", "Bell Peppers (100g)", "Onion (50g)"] - 20g fat, cook with spray NOT butter!
Lunch with LEAN fish: ["Tilapia (180g)", "Brown Rice (200g cooked)", "Green Beans (150g)", "Olive Oil (1 tsp)"] - lean fish + oil OK
Lunch with FATTY fish: ["Salmon (170g)", "Quinoa (200g cooked)", "Asparagus (150g)"] - 19g fat from salmon, NO oil needed!
Dinner: ["Chicken Breast (180g)", "Sweet Potato (250g)", "Broccoli (150g)", "Butter (1 tsp)"] - lean + small fat
Snack: ["Cottage Cheese Nonfat (200g)", "Walnuts (28g)", "Apple (1 medium)"] - 18g fat from nuts only
Protein Shake Snack: ["Whey Protein (1 scoop)", "Almond Milk Unsweetened (125ml)", "Mixed Berries (75g)"] - blended smoothie
Protein Smoothie Breakfast: ["Whey Protein (1 scoop)", "Almond Milk Unsweetened (200ml)", "Banana (1 medium)", "Peanut Butter (1 tbsp)"] - blended smoothie
Protein Shake + Sides: ["Whey Protein (1 scoop)", "Water (250ml)", "Banana (1 medium)", "Whole Wheat Toast (2 slices)", "Peanut Butter (1 tbsp)"] - shaker cup shake with solid food

üö® FAT STACKING ERRORS TO AVOID:
‚ùå Eggs (3) + Ground Turkey (130g) + Butter (1 tbsp) = 35g fat - WRONG!
‚ùå Salmon (160g) + Olive Oil (1 tsp) = 23g fat - WRONG! Fatty fish needs NO oil!
‚ùå Mackerel (150g) + Butter (1 tsp) = 26g fat - WRONG! Fatty fish needs NO butter!
‚úÖ Salmon (150g) + Rice + Vegetables = 17g fat (perfect, no oil)
‚úÖ Cod (200g) + Rice + Olive Oil (1 tsp) = 7g fat (lean fish, oil OK)
‚úÖ Eggs + Ground Meat = 20g fat ‚Üí NO added butter/oil`;


        const dayPrompt = `Create 1-day meal plan for Day ${day} of ${numDays}.
[Variation: ${variationSeed}] - Generate UNIQUE meals different from any previous generation.
Stats: ${age}yo ${gender}, ${weightKg.toFixed(0)}kg, ${heightCm.toFixed(0)}cm
Goal: ${goal}, Diet: ${preference}
Macro Preference: ${macroPreference}
Avoid: ${allergies}
Disliked Foods: ${dislikedFoods}
Preferred Foods/Cuisines: ${preferredFoods}
Budget: ${budget}
Available Equipment: ${equipmentStr}${previousMealsText}${favoriteMealsText}

Daily targets: ${calories} cal, ${protein}g protein, ${carbs}g carbs, ${fat}g fat
${brandedFoodsNote}
CRITICAL MEAL DISTRIBUTION - HARD LIMITS:
- BREAKFAST: ${Math.round(calories * 0.25)}-${Math.round(calories * 0.30)} calories (25-30% of daily)
- LUNCH: ${Math.round(calories * 0.30)}-${Math.round(calories * 0.35)} calories (30-35% of daily)
- DINNER: ${Math.round(calories * 0.25)}-${Math.round(calories * 0.30)} calories (25-30% of daily)
- SNACKS: ${Math.round(calories * 0.10)}-${Math.round(calories * 0.15)} calories each (10-15% of daily)
- ABSOLUTE MAXIMUM: No single meal can exceed ${Math.round(calories * 0.40)} calories (40% of daily)
- Violating these limits is UNACCEPTABLE and will cause errors

CRITICAL TARGET REQUIREMENT:
Your meals MUST add up to approximately these daily targets. This is NOT optional.
- Acceptable variance: ¬±10% for calories, ¬±15% for macros
- Being 20%+ UNDER targets is UNACCEPTABLE - you must size portions appropriately
- Each meal should average ~${Math.round(calories / expectedMealTypes.length)} calories
- Calculate portions so your meals collectively hit targets within acceptable variance
- Example: If target is 2604 cal, acceptable range is 2344-2864 cal
- If your meals only add up to 2079 cal (20% under), portions are TOO SMALL

PORTION SIZING GUIDANCE:
- Small snack: 200-350 cal | Regular meal: 500-700 cal | Large meal: 700-900 cal
- Adjust protein portions: 100-200g chicken/fish, 150-300g tofu/beans
- Adjust carb portions: 150-300g cooked rice/pasta, 200-400g potatoes
- Don't be timid with portions - hitting targets is more important than "small portions"

üö® CRITICAL VARIETY RULES - HARD LIMITS (VIOLATION = PLAN REJECTION):

CARB VARIETY (STRICT ENFORCEMENT):
- Sweet potato: MAX 2-3 times per WEEK (NOT every day!)
- Each carb source MAX 3x per week: rice, quinoa, pasta, oats, potatoes, bread
- ROTATE carbs: Day 1 rice ‚Üí Day 2 quinoa ‚Üí Day 3 pasta ‚Üí Day 4 oats ‚Üí etc.
- NEVER use same carb source in breakfast AND dinner on same day

BREAKFAST VARIETY (STRICT ENFORCEMENT):
- DIFFERENT main protein each day: Day 1 eggs ‚Üí Day 2 turkey ‚Üí Day 3 oats+whey ‚Üí Day 4 yogurt
- NEVER use "ground turkey + eggs + sweet potato" more than 1x per week
- Breakfast options to rotate: eggs, Greek yogurt, cottage cheese, oats+whey, turkey, smoked salmon

PROTEIN VARIETY (STRICT ENFORCEMENT):
- Use DIFFERENT protein source for lunch vs dinner each day
- Rotate weekly: chicken, beef, fish, pork, turkey, shrimp, eggs
- Fish should appear 2-3x per week minimum (salmon, tilapia, cod, tuna)

SNACK VARIETY:
- NOT just "Greek yogurt + fruit" every day
- Rotate: yogurt, cottage cheese, protein shake, nuts+fruit, hard boiled eggs, tuna

SNACK PROPORTION RULES (critical for realistic snacks):
- Bread + nut butter: Use 1-2 slices bread with 1-2 tbsp nut butter (NOT 3 slices with 1 tbsp!)
- Toast snacks: 1-2 slices max with a spread/topping
- Fruit + protein: Balance fruit (1-2 servings) with protein source
- Every snack MUST have a protein source (yogurt, eggs, nuts, cheese, protein powder, etc.)
- Avoid carb-only snacks without protein

===== PROTEIN SHAKE & SMOOTHIE MEALS =====
Protein shakes/smoothies are VALID complete meals for snacks and quick breakfasts.

CRITICAL RULE: Whey Protein MUST ALWAYS include liquid (Water or Milk)!
- Whey protein powder is NEVER eaten dry - it's mixed in a shaker cup
- ALWAYS pair "Whey Protein (X scoop)" with "Water (200-300ml)" or "Almond Milk Unsweetened (200-300ml)"
- This applies to ALL protein shake meals - smoothies AND shake + solid food combos

TYPE 1 - BLENDED SMOOTHIE (all ingredients blended together):
- ["Whey Protein (1 scoop)", "Almond Milk Unsweetened (125ml)", "Blueberries (60g)", "Strawberries (50g)"]
- ["Whey Protein (1 scoop)", "Almond Milk Unsweetened (125ml)", "Mixed Berries (75g)"]
- ["Whey Protein (1 scoop)", "Almond Milk Unsweetened (200ml)", "Banana (1 medium)", "Peanut Butter (1 tbsp)"]
- ["Whey Protein (1 scoop)", "Almond Milk Unsweetened (250ml)", "Oats (40g dry)", "Banana (1/2 medium)"]

TYPE 2 - PROTEIN SHAKE + SOLID FOODS (shaker cup shake served alongside food):
- ["Whey Protein (2 scoops)", "Water (250ml)", "Apple (2 medium)", "Whole Wheat Bread (2 slices)", "Almond Butter (1 tbsp)"]
- ["Whey Protein (1 scoop)", "Water (250ml)", "Banana (1 medium)", "Whole Wheat Toast (2 slices)", "Peanut Butter (1 tbsp)"]
- ["Whey Protein (1 scoop)", "Water (200ml)", "Apple (1 medium)", "Oats (50g dry)", "Walnuts (28g)"]
- ["Whey Protein (2 scoops)", "Water (300ml)", "Banana (1 medium)", "Rice Cakes (2 cakes)", "Almond Butter (1 tbsp)"]

SHAKE CONSTRUCTION RULES:
- BASE: Whey Protein (1 scoop) = 120cal, 25P, 3C, 1F | (2 scoops) = 240cal, 50P, 6C, 2F
- LIQUID (REQUIRED): Water (0 cal) or Almond Milk Unsweetened (200ml = 6cal) or Milk (200ml = 100cal)
- FRUITS: Berries (50-100g), Banana (1/2 to 1 medium), Apple (1-2 medium)
- CARB SIDES: Whole Wheat Bread/Toast, Oats, Rice Cakes
- FAT SIDES: Peanut Butter, Almond Butter, Walnuts (1 tbsp or 28g)

WHEN TO USE PROTEIN SHAKES:
- As a SNACK: Shake (whey + water) with fruit = 200-300 cal
- As BREAKFAST: Shake (whey + water) + bread/toast + nut butter = 400-600 cal complete meal
- Post-workout: Shake (whey + water) + fast carbs (banana, bread) for recovery

MACRO BALANCE PRIORITY (when short on macros):
1. SHORT on CARBS? ‚Üí Add MORE carbs (rice, bread, banana, oats) - NOT fat!
2. SHORT on PROTEIN? ‚Üí Add more protein (chicken, eggs, yogurt) - NOT fat!
3. SHORT on FAT? ‚Üí Only THEN add fat sources
4. NEVER fill calorie gaps with oil/butter - use whole foods!

CRITICAL MEAL STRUCTURE:
Generate ${mealStructure}. DO NOT generate more or fewer items.
${expectedMealTypes.length === 4 ? 'The array should have EXACTLY 4 objects.' : ''}
${expectedMealTypes.length === 5 ? 'The array should have EXACTLY 5 objects.' : ''}
${expectedMealTypes.length === 6 ? 'The array should have EXACTLY 6 objects.' : ''}

===== USDA VERIFIED FOOD DATABASE =====
Reference database for accurate macro calculations.
IMPORTANT: In meal names and ingredients, use NORMAL READABLE FORMAT with spaces and Title Case (e.g., "Greek Yogurt Nonfat (200g)", "Whey Protein (1 scoop)", "Brown Rice (150g cooked)"). Do NOT use snake_case in output.

PROTEINS - Poultry (per 100g raw):
chicken_breast: 165cal, 31P, 0C, 4F | turkey_breast: 135cal, 30P, 0C, 1F
ground_turkey: 176cal, 25P, 0C, 10F | ground_chicken: 143cal, 17P, 0C, 8F

PROTEINS - Beef (per 100g raw):
ground_beef_93: 164cal, 22P, 0C, 7F | sirloin_steak: 160cal, 28P, 0C, 5F
flank_steak: 192cal, 27P, 0C, 9F | bison: 143cal, 28P, 0C, 2F

PROTEINS - Pork (per 100g raw):
pork_tenderloin: 143cal, 26P, 0C, 4F | pork_chop: 206cal, 26P, 0C, 11F

PROTEINS - Seafood (per 100g raw):
salmon: 177cal, 20P, 0C, 11F | cod: 82cal, 18P, 0C, 1F | tilapia: 128cal, 26P, 0C, 3F
shrimp: 106cal, 23P, 1C, 1F | tuna_canned_water: 116cal, 26P, 0C, 1F

PROTEINS - Dairy & Eggs:
egg_large (1 egg): 70cal, 6P, 0C, 5F | egg_white (1 white): 17cal, 4P, 0C, 0F
greek_yogurt_nonfat (100g): 59cal, 10P, 4C, 0F
cottage_cheese_nonfat (100g): 72cal, 12P, 6C, 0F

PROTEINS - Plant (per 100g cooked):
tofu_firm: 76cal, 8P, 2C, 5F | lentils_cooked: 116cal, 9P, 20C, 0F
black_beans: 132cal, 9P, 24C, 1F | chickpeas: 164cal, 9P, 27C, 3F

PROTEINS - Powder (per scoop):
whey_protein (30g): 120cal, 25P, 3C, 1F

CARBS - Rice & Grains (per 100g cooked):
brown_rice_cooked: 112cal, 2P, 24C, 1F | white_rice_cooked: 130cal, 3P, 28C, 0F
quinoa_cooked: 120cal, 4P, 21C, 2F | oats_cooked: 71cal, 2P, 12C, 1F
pasta_cooked: 131cal, 5P, 25C, 1F

CARBS - Potatoes (per 100g):
sweet_potato: 86cal, 2P, 20C, 0F | russet_potato: 79cal, 2P, 18C, 0F

CARBS - Bread (per slice/piece):
whole_wheat_bread (1 slice 28g): 80cal, 4P, 14C, 1F
ezekiel_bread (1 slice 34g): 80cal, 4P, 15C, 1F
tortilla_flour (1 tortilla 32g): 94cal, 3P, 16C, 2F

FATS - Oils & Butters (per tbsp):
olive_oil: 120cal, 0P, 0C, 14F | butter: 102cal, 0P, 0C, 12F
avocado_oil: 120cal, 0P, 0C, 14F

FATS - Nut Butters (per tbsp 16g):
peanut_butter: 94cal, 4P, 3C, 8F | almond_butter: 95cal, 3P, 3C, 9F

FATS - Nuts (per 28g):
almonds: 160cal, 6P, 6C, 14F | walnuts: 185cal, 4P, 4C, 18F

FATS - Whole Foods (per 100g):
avocado: 160cal, 2P, 9C, 15F

VEGETABLES (per 100g):
broccoli: 34cal, 3P, 7C, 0F | spinach: 23cal, 3P, 4C, 0F
bell_pepper: 26cal, 1P, 6C, 0F | zucchini: 17cal, 1P, 3C, 0F
asparagus: 20cal, 2P, 4C, 0F | green_beans: 31cal, 2P, 7C, 0F

FRUITS:
banana (1 medium 118g): 105cal, 1P, 27C, 0F
blueberries (100g): 57cal, 1P, 14C, 0F
strawberries (100g): 32cal, 1P, 8C, 0F
apple (1 medium 182g): 95cal, 0P, 25C, 0F

CONDIMENTS (per tbsp):
ketchup: 17cal, 0P, 4C, 0F | mustard: 10cal, 1P, 1C, 1F
hot_sauce: 1cal, 0P, 0C, 0F | soy_sauce: 9cal, 1P, 1C, 0F

===== REALISTIC PORTION GUIDELINES (CRITICAL!) =====
PHILOSOPHY: Start with realistic portions. Add MORE foods instead of scaling portions beyond natural limits.

üö® ABSOLUTE PORTION LIMITS - HARD CAPS (NEVER EXCEED!) üö®
These are MAXIMUM values per meal - treat as HARD LIMITS, not suggestions!

PROTEINS (per meal - MAXIMUM):
  - Chicken/Turkey/Fish: MAX 250g (NEVER more!)
  - Ground meats: MAX 200g (NEVER more!)
  - Eggs: MAX 4 whole eggs, or MAX 300g egg whites
  - Greek Yogurt: MAX 250g (NEVER more!)
  - Cottage Cheese: MAX 250g (NEVER more!)

CARBS - GRAINS DRY WEIGHT (HARD CAPS):
  - Oats (dry): MAX 80g - NO EXCEPTIONS! (84g is TOO MUCH!)
  - Rice (dry): MAX 80g - NO EXCEPTIONS!
  - Quinoa (dry): MAX 80g - NO EXCEPTIONS!
  - Pasta (dry): MAX 80g - NO EXCEPTIONS!

CARBS - GRAINS COOKED WEIGHT (HARD CAPS):
  - Oats (cooked): MAX 250g - NO EXCEPTIONS!
  - Rice (cooked): MAX 300g - NO EXCEPTIONS!
  - Quinoa (cooked): MAX 250g - NO EXCEPTIONS!
  - Pasta (cooked): MAX 300g - NO EXCEPTIONS!

CARBS - OTHER (HARD CAPS):
  - Sweet/Regular Potatoes: MAX 300g
  - Bread: MAX 3 slices per meal
  - Tortillas: MAX 2 per meal

FATS (HARD CAPS - CRITICAL FOR MACRO BALANCE):
  - Oils/Butter: MAX 1 tsp per meal (5g fat) - NOT 1 tbsp!
  - Nut Butters: MAX 1 tbsp per meal (8g fat)
  - Nuts: MAX 35g per meal (18g fat) - NEVER 50g+!
  - Avocado: MAX 75g per meal (12g fat)
  - TOTAL FAT per meal should be 15-25g, NEVER 35g+!

VEGETABLES: MAX 200g per meal (NEVER exceed 200g!)
FRUITS: MAX 150g or MAX 2 medium pieces (NEVER more!)

üõë ENFORCEMENT RULES - READ CAREFULLY:
1. These maximums are ABSOLUTE HARD CAPS
2. If a portion would exceed the max, STOP and ADD a different food instead
3. Examples of VIOLATIONS to AVOID:
   ‚ùå Oats (84g dry) - WRONG! Max is 80g
   ‚ùå Cod (260g) - WRONG! Max is 250g
   ‚ùå Cottage Cheese (307g) - WRONG! Max is 250g
   ‚ùå Asparagus (213g) - WRONG! Max is 200g
   ‚ùå Walnuts (43g) - WRONG! Max is 42g (56g for all nuts)

4. Correct approach when short on macros:
   ‚úÖ Have 70g oats + need more carbs? ‚Üí ADD banana (don't increase oats to 84g)
   ‚úÖ Have 200g cottage cheese + need more protein? ‚Üí ADD egg whites (don't increase to 307g)
   ‚úÖ Have 180g vegetables + need more volume? ‚Üí ADD a second vegetable type (don't exceed 200g)

===== STRATEGIC PROTEIN DISTRIBUTION (ADVANCED!) =====
DO NOT rely on giant dairy snacks to hit protein! Use these proven strategies:

STRATEGY 1: PROTEIN STACKING (Multiple sources in one meal)
Instead of: Greek Yogurt (400g) = 40g protein ‚ùå
Do this: Greek Yogurt (200g) + Egg Whites (100g) + Almonds (28g) = 40g protein ‚úÖ

STRATEGY 2: "PROATS" TECHNIQUE (Mix whey into oats)
Oats (75g dry) + Whey Protein (1 scoop) = 35g protein base ‚úÖ
Then ADD: Whole Eggs (2) + Egg Whites (100g) + Almonds (30g) = 66g total!

STRATEGY 3: LEAVE HEADROOM (Don't max every portion)
Chicken: Use 170-200g (not 250g max) - Saves room for variety
Rice: Use 220-280g (not 300g max) - Leaves stomach space
This allows adding complementary foods without feeling stuffed!

STRATEGY 4: SMART COMBINATIONS
‚úÖ Eggs (2 whole) + Egg Whites (150g) = 28g protein, not too heavy
‚úÖ Chicken (170g) + Rice (280g) = 70g protein + carbs
‚úÖ Beef (200g) + Sweet Potato (280g) = Dinner that satisfies

STRATEGY 5: 3-MEAL APPROACH FOR HIGH TARGETS
If user needs 2500+ calories OR 180+ protein:
- Each meal: 800-900 calories, 60-65g protein
- Use 5-6 ingredients per meal (stack proteins!)
- Example: Oats + Whey + Eggs + Whites + Banana + Almonds = 880 cal, 66g protein

CRITICAL MEAL BUILDING PROCESS:
0. MANDATORY PROTEIN RULE: Every meal MUST have a PRIMARY protein source!
   - Breakfast: eggs, Greek yogurt, cottage cheese, turkey, or whey protein
   - Lunch/Dinner: chicken, fish, beef, pork, turkey, tofu, or eggs
   - Snacks: yogurt, eggs, nuts, cheese, protein powder, or cottage cheese
   - DO NOT create vegetable-only meals without protein (e.g., "spinach with olive oil" is NOT valid)
   - MINIMUM protein: Breakfast 10g+, Lunch/Dinner 15g+, Snacks 3g+

1. Start with BASE portions WELL BELOW the maximums:
   - 1 protein source: 150-220g (leave room to add more if needed)
   - 1 carb source: 50-70g dry grains (leave room to add fruit/bread)
   - 1 fat source: 1-1.5 tbsp (leave room to add nuts)
   - 1 vegetable: 100-180g (leave room to add more veggies)

2. Calculate macros from these base ingredients

3. IF still short of target macros (>15% under):
   ‚úÖ ADD complementary foods from different categories
   ‚ùå NEVER increase existing portions beyond the HARD CAPS above

4. IF cannot hit targets with 5-6 ingredients:
   ‚Üí Keep meal reasonable, accept being slightly under target
   ‚Üí System will balance across other meals or suggest snacks

5. PRIORITY ORDER: Protein requirement > Portion limits > Hitting exact macros
   - It is BETTER to be 10-15% under macros than to violate portion limits
   - NEVER sacrifice realistic portions to hit targets
   - BUT every meal MUST have adequate protein!

CRITICAL RULES:
- Use ONLY foods from the database above for accurate macros
- OUTPUT FORMAT: Use readable names with spaces (e.g., "Chicken Breast", "Greek Yogurt Nonfat", "Whey Protein") - NEVER use underscores in output
- Portions: "100g", "150g", "1 tbsp", "2 slices", "1 egg", "200g"
- MEAL NAME FORMAT: Include ALL key ingredient portions inline in parentheses
  Examples:
  "High-Protein Oatmeal (80g dry) with Scrambled Eggs (2 whole, 200g whites) and Peanut Butter (1 tbsp)"
  "Grilled Chicken Breast (200g) with Quinoa (150g cooked) and Broccoli (100g)"
  "Greek Yogurt Bowl (170g) with Blueberries (75g) and Almonds (28g)"
- CRITICAL: Meal name descriptor MUST match database entry used
  If using "oats_rolled_dry" ‚Üí say "80g dry oats" in name
  If using "oats_cooked" ‚Üí say "80g cooked oats" in name
  If using "quinoa_cooked" ‚Üí say "150g cooked quinoa" in name
  If using "brown_rice_cooked" ‚Üí say "200g cooked rice" in name
- NO adjectives like "delicious" or "hearty" in meal names

IMPORTANT: Only use recipes that can be made with the available equipment.
Consider the budget constraint and preferred foods when planning meals.
${day > 1 ? 'ENSURE VARIETY: This is Day ' + day + ', so make sure meals are different from previous days.' : ''}

CRITICAL: Return ONLY valid JSON with NO special characters, NO quotes in text, NO newlines in strings.
Use only alphanumeric characters and basic punctuation (periods, commas) in text fields.
Replace all quotes with apostrophes.

üö® CRITICAL INSTRUCTION RULES (MUST FOLLOW):
1. ONLY mention ingredients that are in your ingredients array - NO extras!
2. If ingredients say "Eggs (2 whole)", instructions must say "2 eggs" - NOT "3 eggs"!
3. DO NOT add garnishes, toppings, or extras not in the ingredients list
4. NO "top with almonds" unless almonds are in ingredients
5. NO "garnish with parsley" unless parsley is in ingredients
6. Match EXACT quantities: if ingredients say "1 tsp olive oil", don't say "2 tbsp oil" in instructions
7. Keep instructions simple: just cooking steps, no imaginary ingredients

CRITICAL INGREDIENTS FORMAT:
You MUST return ingredients as an ARRAY OF STRINGS in natural language format.
Include the food name AND amount/portion in parentheses.

EXAMPLES:
"Chicken Breast (200g)" ‚úÖ
"Eggs (3 whole)" ‚úÖ
"Rolled Oats (80g dry)" ‚úÖ
"Egg Whites (200g)" ‚úÖ
"Brown Rice (150g cooked)" ‚úÖ
"Whole Wheat Bread (2 slices)" ‚úÖ
"Olive Oil (1 tsp)" ‚úÖ
"Greek Yogurt (200g)" ‚úÖ

FULL EXAMPLE (use this EXACT format - 3-4 ingredients with larger portions):
{"day":${day},"targets":{"calories":${calories},"protein":${protein},"carbs":${carbs},"fat":${fat}},"plan":[{"type":"breakfast","name":"Scrambled Eggs (3 whole) with Oatmeal (1 cup cooked) and Berries (100g)","ingredients":["Eggs (3 whole)","Oats (50g dry)","Blueberries (100g)","Butter (1 tsp)"],"instructions":"Scramble 3 eggs in 1 tsp butter. Cook oatmeal. Serve with fresh berries."},{"type":"lunch","name":"Grilled Chicken (200g) with Brown Rice (200g cooked)","ingredients":["Chicken Breast (200g)","Brown Rice (200g cooked)","Broccoli (150g)"],"instructions":"Grill chicken. Serve with rice and steamed broccoli."},{"type":"dinner","name":"Salmon (180g) with Quinoa (200g cooked)","ingredients":["Salmon (180g)","Quinoa (200g cooked)","Asparagus (150g)"],"instructions":"Bake salmon. Serve with quinoa and roasted asparagus."},{"type":"snack","name":"Greek Yogurt (200g) with Almonds (28g)","ingredients":["Greek Yogurt Nonfat (200g)","Almonds (28g)","Blueberries (75g)"],"instructions":"Mix yogurt with almonds and berries."}]}

MEAL TYPE VALUES - Use these EXACT type values in lowercase:
- "breakfast" for the breakfast meal
- "lunch" for the lunch meal
- "dinner" for the dinner meal
- "snack" for ALL snack meals (use "snack" not "snacks" even if there are multiple snacks)

CRITICAL REQUIREMENTS:
1. Ingredients MUST be array of strings: ["Food Name (amount)", "Food Name (amount)"]
2. Use natural language names: "Chicken Breast" not "chicken_breast"
3. ALWAYS include amount in parentheses: "Chicken Breast (200g)" not just "Chicken Breast"
4. DO NOT include calories/protein/carbs/fat - backend calculates from database
5. Portions: "100g", "150g", "200g", "1 tbsp", "2 slices", "3 whole", etc.
6. Each meal MUST have "type", "name", "ingredients", "instructions"
7. For descriptors like dry/cooked, include in parentheses: "Oats (80g dry)" or "Rice (200g cooked)"

STEP-BY-STEP FOR EACH MEAL:
1. DETERMINE meal protein target:
   - Standard meals (3-5 per day): 40-50g protein each
   - High-protein plan (3 meals/day): 60-70g protein each

2. START with protein foundation (use STACKING strategy):
   - Breakfast: Eggs (2 whole) + Egg Whites (100-150g) + Whey (1 scoop) = 40g base
   - Lunch: Chicken/Fish (170-200g) = 50g base
   - Dinner: Beef/Pork (170-200g) = 40-50g base

3. ADD carbs (leave headroom!):
   - Use 220-280g cooked rice (NOT 300g max)
   - Use 70-80g dry oats (NOT always maxed)
   - Use 250-280g potatoes (NOT 300g max)

${fatGuidance}

5. ADD vegetables/fruits:
   - Vegetables: 150-200g portions
   - Fruits: 1 medium or 100g berries

6. CALCULATE total macros from 3-4 main ingredients

7. IF still short (>10% under):
   ‚úÖ INCREASE existing protein/carb portions first
   ‚úÖ Or ADD one complementary food (banana, almonds, bread slice)
   ‚ùå DO NOT add more cooking oil

8. Format as string array with amounts in parentheses

${mealExamples}`;

        // Build targets object for hybrid Gemini + JS optimizer
        const dayTargets = {
            calories: calories,
            protein: protein,
            carbs: carbs,
            fat: fat
        };

        // ‚úÖ Use callGemini (hybrid approach with JS optimizer) instead of callClaude
        const dayData = await callGemini(dayPrompt, true, dayTargets, null, expectedMealTypes.length);
        if (dayData.error) {
            resultDiv.innerHTML = `<div class="card text-red-600">Error generating Day ${day}: ${dayData.error}</div>`;
            button.disabled = false;
            return;
        }

        // Validate meal count
        if (dayData.plan && Array.isArray(dayData.plan)) {
            if (dayData.plan.length !== expectedMealTypes.length) {
                console.warn(`‚ö†Ô∏è Wrong meal count: Got ${dayData.plan.length} meals but expected ${expectedMealTypes.length}`);
                // Trim or pad the plan to match expected count
                if (dayData.plan.length > expectedMealTypes.length) {
                    console.log('Trimming excess meals...');
                    dayData.plan = dayData.plan.slice(0, expectedMealTypes.length);
                } else if (dayData.plan.length < expectedMealTypes.length) {
                    // Pad with placeholder meals that will be regenerated
                    console.log(`üìù Padding ${expectedMealTypes.length - dayData.plan.length} missing meals...`);
                    while (dayData.plan.length < expectedMealTypes.length) {
                        const missingIndex = dayData.plan.length;
                        const missingType = expectedMealTypes[missingIndex];
                        dayData.plan.push({
                            type: missingType,
                            name: 'Meal', // Will trigger regeneration
                            calories: 0,
                            protein: 0,
                            carbs: 0,
                            fat: 0,
                            ingredients: [],
                            instructions: ''
                        });
                    }
                }
            }

            // Enforce correct meal types based on expected structure
            console.log('üîß Enforcing correct meal types...');
            for (let i = 0; i < dayData.plan.length; i++) {
                const expectedType = expectedMealTypes[i] || 'meal';
                const meal = dayData.plan[i];

                // Fix missing or incorrect type
                if (!meal.type || meal.type === 'meal' || meal.type === 'snacks') {
                    console.log(`   Fixed meal ${i + 1} type: "${meal.type || 'undefined'}" ‚Üí "${expectedType}"`);
                    meal.type = expectedType;
                }

                // Ensure meal has required fields to prevent empty meals
                if (!meal.name || meal.name === 'Meal' || meal.name === 'Unnamed Meal') {
                    console.warn(`‚ö†Ô∏è Meal ${i + 1} (${expectedType}) has invalid name: "${meal.name}"`);
                }
                if (!meal.ingredients || !Array.isArray(meal.ingredients) || meal.ingredients.length === 0) {
                    console.warn(`‚ö†Ô∏è Meal ${i + 1} (${expectedType}) has no ingredients`);
                }
            }
        }

        // Validate each meal and regenerate if needed
        if (dayData.plan && Array.isArray(dayData.plan)) {
            for (let mealIndex = 0; mealIndex < dayData.plan.length; mealIndex++) {
                const meal = dayData.plan[mealIndex];
                const validation = validateMeal(meal, meal.type);

                if (!validation.valid) {
                    console.warn(`‚ö†Ô∏è Validation failed for ${meal.type} on Day ${day}:`, validation.issues);
                    console.log('üîÑ Regenerating meal...');

                    // Regenerate this specific meal using hybrid Gemini + JS optimizer (max 2 attempts)
                    let retryCount = 0;
                    let validMeal = null;
                    let previousAttempt = null;

                    while (retryCount < 3 && !validMeal) {
                        // Calculate targets for the prompt
                        const mealTypeName = meal.type?.toLowerCase() || 'meal';
                        let targetCalPercent = 0.25;
                        let minProteinRequired = 10;
                        if (mealTypeName === 'breakfast') { targetCalPercent = 0.27; minProteinRequired = 10; }
                        else if (mealTypeName === 'lunch') { targetCalPercent = 0.32; minProteinRequired = 15; }
                        else if (mealTypeName === 'dinner') { targetCalPercent = 0.28; minProteinRequired = 15; }
                        else if (mealTypeName === 'snack') { targetCalPercent = 0.13; minProteinRequired = 3; }

                        const targetCal = Math.round(calories * targetCalPercent);
                        const targetProt = Math.round(protein * targetCalPercent);

                        const regeneratePrompt = `Generate a COMPLETE ${meal.type} meal with MULTIPLE ingredients.

CRITICAL REQUIREMENTS:
- This MUST be a real meal with 3-5 ingredients, NOT a single ingredient!
- MUST include a PRIMARY PROTEIN SOURCE: chicken, fish, beef, eggs, Greek yogurt, tofu, etc.
- MINIMUM PROTEIN: ${minProteinRequired}g (current issue: meal has insufficient protein)
- Target: ~${targetCal} calories, ~${targetProt}g protein

Diet preference: ${preference}
Avoid: ${allergies}

VALID PROTEIN SOURCES (pick at least one):
- Chicken Breast (150-200g) = 45-60g protein
- Salmon/Fish (150g) = 30-35g protein
- Ground Turkey (150g) = 35-40g protein
- Eggs (2-3) = 12-18g protein
- Greek Yogurt Nonfat (200g) = 20g protein
- Tofu Firm (150g) = 12g protein

EXAMPLE ${meal.type.toUpperCase()} MEALS:
${mealTypeName === 'breakfast' ? '- Scrambled Eggs (3) with Whole Wheat Toast (2 slices) and Avocado (50g)\n- Greek Yogurt (200g) with Oats (50g dry) and Blueberries (75g)\n- Turkey Sausage (100g) with Eggs (2) and Sweet Potato (100g)' : ''}
${mealTypeName === 'lunch' || mealTypeName === 'dinner' ? '- Grilled Chicken Breast (180g) with Brown Rice (150g cooked) and Broccoli (100g)\n- Baked Salmon (150g) with Quinoa (150g cooked) and Asparagus (100g)\n- Ground Turkey (150g) with Sweet Potato (200g) and Green Beans (100g)' : ''}
${mealTypeName === 'snack' ? '- Greek Yogurt (150g) with Almonds (28g) and Berries (75g)\n- Cottage Cheese (150g) with Apple (1 medium)\n- Hard Boiled Eggs (2) with Whole Wheat Crackers' : ''}

Return JSON: {"type":"${meal.type}","name":"Meal Name with portions","ingredients":["Ingredient (amount)","..."],"instructions":"Brief cooking steps"}`;

                        // Build targets object for JS optimizer
                        // If meal has 0 calories (placeholder), calculate proper targets based on meal type
                        let mealTargets;
                        if (meal.calories === 0) {
                            // Calculate targets based on meal type distribution
                            const mealType = meal.type?.toLowerCase() || 'meal';
                            let calPercent = 0.25; // Default
                            if (mealType === 'breakfast') calPercent = 0.27;
                            else if (mealType === 'lunch') calPercent = 0.32;
                            else if (mealType === 'dinner') calPercent = 0.28;
                            else if (mealType === 'snack') calPercent = 0.13;

                            mealTargets = {
                                calories: Math.round(calories * calPercent),
                                protein: Math.round(protein * calPercent),
                                carbs: Math.round(carbs * calPercent),
                                fat: Math.round(fat * calPercent)
                            };
                            console.log(`üìä Calculated targets for ${mealType}: ${mealTargets.calories}cal, ${mealTargets.protein}P, ${mealTargets.carbs}C, ${mealTargets.fat}F`);
                        } else {
                            mealTargets = {
                                calories: meal.calories,
                                protein: meal.protein,
                                carbs: meal.carbs,
                                fat: meal.fat
                            };
                        }

                        // Include validation errors as feedback if this is a retry
                        if (retryCount > 0 && previousAttempt) {
                            previousAttempt.errors = validation.issues;
                        }

                        // ‚úÖ Use callGemini (hybrid approach with JS optimizer) instead of callClaude
                        const newMeal = await callGemini(regeneratePrompt, true, mealTargets, previousAttempt, 1);
                        if (!newMeal.error) {
                            const newValidation = validateMeal(newMeal, meal.type);
                            if (newValidation.valid) {
                                validMeal = newMeal;
                                console.log('‚úÖ Regenerated meal passed validation');
                            } else {
                                console.warn(`Retry ${retryCount + 1} still has issues:`, newValidation.issues);
                                previousAttempt = { errors: newValidation.issues };
                            }
                        }
                        retryCount++;
                    }

                    // Use regenerated meal if valid, otherwise keep original
                    if (validMeal) {
                        dayData.plan[mealIndex] = validMeal;
                    } else {
                        console.error(`‚ùå CRITICAL: Could not generate valid ${meal.type} after ${retryCount} retries`);
                        console.error('Invalid meal issues:', validation.issues);

                        // BLOCK: Do not proceed with invalid meal
                        resultDiv.innerHTML = `<div class="card text-red-600">
                            <h3 class="font-bold mb-2">‚ùå Meal Generation Failed</h3>
                            <p>Could not generate a valid ${meal.type} for Day ${day} after multiple attempts.</p>
                            <p class="mt-2">Issues detected: ${validation.issues.join(', ')}</p>
                            <p class="mt-4 text-sm">This is a quality control measure to ensure accurate nutrition data. Please try generating again.</p>
                        </div>`;
                        button.disabled = false;
                        return; // STOP - don't save or display plan
                    }
                }
            }
        }

        // Validate day's total macros against targets - ENFORCE THIS
        const dayValidation = validateDayTotals(dayData);
        if (!dayValidation.valid) {
            console.error(`‚ùå CRITICAL: Day ${day} totals don't match targets:`, dayValidation.issues);
            console.error(`Actual totals: ${dayValidation.totals.calories} cal, ${dayValidation.totals.protein}g protein, ${dayValidation.totals.carbs}g carbs, ${dayValidation.totals.fat}g fat`);

            // BLOCK: Do not proceed with inaccurate day
            resultDiv.innerHTML = `<div class="card text-red-600">
                <h3 class="font-bold mb-2">‚ùå Daily Total Validation Failed</h3>
                <p>Day ${day} meals don't add up to targets accurately enough.</p>
                <p class="mt-2"><strong>Target:</strong> ${dayData.targets.calories} cal, ${dayData.targets.protein}g protein, ${dayData.targets.carbs}g carbs, ${dayData.targets.fat}g fat</p>
                <p><strong>Actual:</strong> ${dayValidation.totals.calories} cal, ${dayValidation.totals.protein}g protein, ${dayValidation.totals.carbs}g carbs, ${dayValidation.totals.fat}g fat</p>
                <p class="mt-4 text-sm">Issues: ${dayValidation.issues.join(', ')}</p>
                <p class="mt-4 text-sm">This is a quality control measure. Please try generating again.</p>
            </div>`;
            button.disabled = false;
            return; // STOP - don't save or display plan
        } else {
            console.log(`‚úÖ Day ${day} totals validated successfully`);
        }

        // Update targets to show original values
        dayData.targets = originalTargets;

        allDays.push(dayData);
    }

    // FINAL VALIDATION: Check all days before saving/displaying
    console.log('üîç Performing final validation on entire plan...');
    let planValid = true;
    let planIssues = [];

    for (let i = 0; i < allDays.length; i++) {
        const day = allDays[i];

        // Check each meal
        for (let j = 0; j < day.plan.length; j++) {
            const meal = day.plan[j];
            const validation = validateMeal(meal, meal.type);
            if (!validation.valid) {
                planValid = false;
                planIssues.push(`Day ${day.day} ${meal.type}: ${validation.issues.join(', ')}`);
            }
        }

        // Check day totals
        const dayValidation = validateDayTotals(day);
        if (!dayValidation.valid) {
            planValid = false;
            planIssues.push(`Day ${day.day} totals: ${dayValidation.issues.join(', ')}`);
        }
    }

    if (!planValid) {
        console.error('‚ùå FINAL VALIDATION FAILED');
        console.error('Issues found:', planIssues);

        // Clear progress animation
        if (window.currentProgressInterval) clearInterval(window.currentProgressInterval);

        resultDiv.innerHTML = `<div class="card text-red-600">
            <h3 class="font-bold mb-2">‚ùå Plan Validation Failed</h3>
            <p>The generated plan did not pass final quality checks.</p>
            <p class="mt-2"><strong>Issues found:</strong></p>
            <ul class="list-disc ml-6 mt-2">
                ${planIssues.map(issue => `<li>${issue}</li>`).join('')}
            </ul>
            <p class="mt-4 text-sm">This is a quality control measure. Please try generating again.</p>
        </div>`;
        button.disabled = false;
        return; // BLOCK - do not save or display invalid plan
    }

    console.log('‚úÖ All validation passed - plan is accurate');

    lastPlanQuery.currentPlan = allDays;
    markUnsavedChanges(); // Track that there are unsaved changes

    // Generate a summary of what's in the plan for client display
    lastPlanQuery.summary = generatePlanSummary(lastPlanQuery);
    console.log('üìã Plan summary:', lastPlanQuery.summary);

    // Clear progress animation
    if (window.currentProgressInterval) clearInterval(window.currentProgressInterval);

    displayDietPlan(allDays);

    // Save plan to coach's history (only if valid)
    // Must await to ensure planId is set before user can interact with Submit button
    const saveSuccess = await saveCoachPlan(lastPlanQuery, lastPlanQuery.clientName);

    // Show save status to user
    if (!saveSuccess) {
        showSaveRetryButton();
    }

    button.disabled = false;
}

function displayDietPlan(multiDayData) {
    const resultDiv = document.getElementById('diet-plan-result');
    const targets = multiDayData[0].targets;

    // Helper function to get color class based on variance
    const getVarianceColor = (variancePercent) => {
        const abs = Math.abs(variancePercent);
        if (abs <= 10) return 'text-green-600'; // Within ¬±10% - good
        if (abs <= 20) return 'text-yellow-600'; // Within ¬±20% - acceptable
        return 'text-red-600'; // Over ¬±20% - needs adjustment
    };

    // Helper function to format variance display
    const formatVariance = (actual, target, variancePercent) => {
        const diff = actual - target;
        const sign = diff >= 0 ? '+' : '';
        return `${sign}${diff} (${sign}${variancePercent.toFixed(1)}%)`;
    };

    let planHTML = `
        <div class="card">
            <h3 class="text-xl font-bold mb-4">Your ${multiDayData.length}-Day Plan</h3>

            <div class="mb-4">
                <p class="text-sm font-semibold text-gray-700 mb-2">Daily Nutrition Targets:</p>
                <div class="grid grid-cols-4 gap-2 p-4 bg-blue-50 rounded-lg">
                    <div class="text-center"><p class="text-sm text-gray-600">Calories</p><span class="font-bold text-blue-600">${targets.calories}</span></div>
                    <div class="text-center"><p class="text-sm text-gray-600">Protein</p><span class="font-bold text-blue-600">${targets.protein}g</span></div>
                    <div class="text-center"><p class="text-sm text-gray-600">Carbs</p><span class="font-bold text-blue-600">${targets.carbs}g</span></div>
                    <div class="text-center"><p class="text-sm text-gray-600">Fat</p><span class="font-bold text-blue-600">${targets.fat}g</span></div>
                </div>
            </div>

    `;

    multiDayData.forEach((dayData, dayIndex) => {
        // Calculate per-day actual totals
        let dayTotals = { calories: 0, protein: 0, carbs: 0, fat: 0 };
        dayData.plan.forEach(meal => {
            dayTotals.calories += meal.calories || 0;
            dayTotals.protein += meal.protein || 0;
            dayTotals.carbs += meal.carbs || 0;
            dayTotals.fat += meal.fat || 0;
        });

        // Calculate per-day variance
        const dayVariance = {
            calories: ((dayTotals.calories - targets.calories) / targets.calories * 100),
            protein: ((dayTotals.protein - targets.protein) / targets.protein * 100),
            carbs: ((dayTotals.carbs - targets.carbs) / targets.carbs * 100),
            fat: ((dayTotals.fat - targets.fat) / targets.fat * 100)
        };

        // Calculate macro distribution percentages (% of total calories from each macro)
        const macroPercent = {
            protein: dayTotals.calories > 0 ? Math.round((dayTotals.protein * 4) / dayTotals.calories * 100) : 0,
            carbs: dayTotals.calories > 0 ? Math.round((dayTotals.carbs * 4) / dayTotals.calories * 100) : 0,
            fat: dayTotals.calories > 0 ? Math.round((dayTotals.fat * 9) / dayTotals.calories * 100) : 0
        };

        planHTML += `
            <div class="day-divider" style="display: flex; justify-content: space-between; align-items: center; padding: 0.75rem 1rem;">
                <span>Day ${dayData.day}</span>
                <button data-action="regenerate-day" data-day-index="${dayIndex}" class="btn btn-secondary text-xs" style="background: rgba(255,255,255,0.2); color: white; border: 1px solid rgba(255,255,255,0.3); padding: 0.5rem 1rem;">üîÑ Regenerate Day</button>
            </div>
            <div class="mb-3 p-3 bg-gray-50 rounded-lg">
                <p class="text-xs font-semibold text-gray-600 mb-2">Day ${dayData.day} Totals:</p>
                <div class="grid grid-cols-4 gap-2 text-center">
                    <div>
                        <p class="text-xs text-gray-500">Calories</p>
                        <span class="text-sm font-bold ${getVarianceColor(dayVariance.calories)}">${dayTotals.calories}</span>
                        <p class="text-xs ${getVarianceColor(dayVariance.calories)}">${formatVariance(dayTotals.calories, targets.calories, dayVariance.calories)}</p>
                    </div>
                    <div>
                        <p class="text-xs text-gray-500">Protein</p>
                        <span class="text-sm font-bold ${getVarianceColor(dayVariance.protein)}">${dayTotals.protein}g</span>
                        <span class="text-xs font-medium" style="color: #10b981; display: block;">${macroPercent.protein}%</span>
                        <p class="text-xs ${getVarianceColor(dayVariance.protein)}">${formatVariance(dayTotals.protein, targets.protein, dayVariance.protein)}</p>
                    </div>
                    <div>
                        <p class="text-xs text-gray-500">Carbs</p>
                        <span class="text-sm font-bold ${getVarianceColor(dayVariance.carbs)}">${dayTotals.carbs}g</span>
                        <span class="text-xs font-medium" style="color: #f59e0b; display: block;">${macroPercent.carbs}%</span>
                        <p class="text-xs ${getVarianceColor(dayVariance.carbs)}">${formatVariance(dayTotals.carbs, targets.carbs, dayVariance.carbs)}</p>
                    </div>
                    <div>
                        <p class="text-xs text-gray-500">Fat</p>
                        <span class="text-sm font-bold ${getVarianceColor(dayVariance.fat)}">${dayTotals.fat}g</span>
                        <span class="text-xs font-medium" style="color: #3b82f6; display: block;">${macroPercent.fat}%</span>
                        <p class="text-xs ${getVarianceColor(dayVariance.fat)}">${formatVariance(dayTotals.fat, targets.fat, dayVariance.fat)}</p>
                    </div>
                </div>
            </div>`;
        dayData.plan.forEach((meal, mealIndex) => {
            const mealNoteId = `meal-note-${dayIndex}-${mealIndex}`;
            const existingNote = meal.coach_note || '';
            const isSupplement = meal.type === 'supplement';

            if (isSupplement) {
                // Special styling for supplement items
                planHTML += `
                <div class="meal-card" style="background: linear-gradient(135deg, #e0f2fe 0%, #dbeafe 100%); border: 2px solid #0ea5e9;">
                    <h4 class="font-bold text-lg capitalize" style="color: #0369a1;">üíä Supplement</h4>
                    <p class="text-blue-700">${meal.name}</p>
                    <div class="grid grid-cols-4 gap-1 text-xs text-gray-600 my-2">
                        <span>${meal.calories} cal</span>
                        <span>${meal.protein}g P</span>
                        <span>${meal.carbs}g C</span>
                        <span>${meal.fat}g F</span>
                    </div>
                    <p class="text-xs text-gray-500 italic">${meal.instructions || 'Mix with water or milk as directed.'}</p>
                </div>`;
            } else {
                // Check if there's a previous state for undo
                const undoStateKey = `${dayIndex}-${mealIndex}`;
                const hasUndoState = previousMealStates[undoStateKey] !== undefined;
                const undoButton = hasUndoState
                    ? `<button data-action="undo-meal" data-day-index="${dayIndex}" data-meal-index="${mealIndex}" class="btn text-xs" style="background: #dc2626; color: white;" title="Undo last change">‚Ü©Ô∏è Undo</button>`
                    : '';

                // Different buttons for custom vs AI-generated meals
                const isCustomMeal = meal.isCustom === true;

                // Edit button for custom meals, Revise button for AI meals
                const editOrReviseButton = isCustomMeal
                    ? `<button data-action="edit-custom-meal" data-day-index="${dayIndex}" data-meal-index="${mealIndex}" class="btn btn-edit text-xs flex-1" title="Edit this custom meal">‚úé Edit</button>`
                    : `<button data-action="revise-meal" data-day-index="${dayIndex}" data-meal-index="${mealIndex}" class="btn btn-secondary text-xs flex-1">‚úèÔ∏è Revise</button>`;

                // Generate unique ID for this meal's image
                const mealImageId = `meal-img-${dayIndex}-${mealIndex}`;
                const escapedMealName = meal.name.replace(/'/g, "\\'").replace(/"/g, '&quot;');

                planHTML += `
                <div class="meal-card">
                    <div class="meal-card-image-placeholder" id="${mealImageId}" data-meal-name="${escapedMealName}" onclick="showMealImageLarge(this)">
                        üçΩÔ∏è
                    </div>
                    <div class="meal-card-content">
                        <h4 class="font-bold text-lg capitalize">${meal.type}</h4>
                        <p class="text-blue-700">${meal.name}</p>
                        <div class="grid grid-cols-4 gap-1 text-xs text-gray-600 my-2">
                            <span>${meal.calories} cal</span>
                            <span>${meal.protein}g P</span>
                            <span>${meal.carbs}g C</span>
                            <span>${meal.fat}g F</span>
                        </div>
                        <div class="flex gap-2 mt-2 flex-wrap">
                            <button data-action="change-meal" data-day-index="${dayIndex}" data-meal-index="${mealIndex}" class="btn btn-secondary text-xs flex-1">üîÑ Change</button>
                            ${editOrReviseButton}
                            <button data-action="custom-meal" data-day-index="${dayIndex}" data-meal-index="${mealIndex}" class="btn btn-custom text-xs flex-1" title="Create exact meal from scratch">üéØ Custom</button>
                            <button data-action="get-recipe" data-meal-name="${meal.name}" class="btn btn-secondary text-xs flex-1">üìñ Recipe</button>
                            ${undoButton}
                        </div>
                        <div class="flex gap-2 mt-2">
                            <button data-action="generate-meal-image" data-image-id="${mealImageId}" data-meal-name="${escapedMealName}" class="btn text-xs" style="background: #8b5cf6; color: white;">üì∑ Generate Image</button>
                        </div>
                        <div class="meal-note-section" style="margin-top: 12px; background: #fef3c7; padding: 10px; border-radius: 6px; border: 1px solid #fcd34d;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                <span style="font-weight: 600; color: #92400e; font-size: 11px;">üìù Note for Client:</span>
                                <button data-action="save-meal-note" data-day-index="${dayIndex}" data-meal-index="${mealIndex}" class="btn" style="background: #f59e0b; color: white; padding: 3px 10px; font-size: 10px; border-radius: 4px;">Save</button>
                            </div>
                            <textarea id="${mealNoteId}" style="width: 100%; min-height: 50px; padding: 6px; border: 1px solid #fcd34d; border-radius: 4px; font-size: 12px; resize: vertical;" placeholder="Add a note about this meal...">${existingNote}</textarea>
                        </div>
                    </div>
                </div>`;
            }
        });
    });

    // Coach Notes Section
    planHTML += `
        <div class="coach-notes-section" style="margin-top: 20px; padding: 16px; background: #f0f9ff; border-radius: 8px; border: 1px solid #bae6fd;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h4 style="margin: 0; color: #0369a1; font-size: 14px; font-weight: 600;">üìù Coach Notes for Client</h4>
                <button id="saveNotesBtn" data-action="save-coach-notes" class="btn btn-secondary" style="font-size: 12px; padding: 6px 12px;">Save Notes</button>
            </div>
            <textarea id="coachNotesInput" placeholder="Add personalized notes, tips, or instructions for your client..." style="width: 100%; min-height: 80px; padding: 10px; border: 1px solid #cbd5e0; border-radius: 6px; font-size: 14px; resize: vertical;"></textarea>
            <p style="margin-top: 6px; font-size: 11px; color: #64748b;">These notes will be visible to the client when they view this plan.</p>
        </div>
    `;

    // Plan Status Banner and Submit Button
    planHTML += `
        <div id="plan-status-banner" class="plan-status-section" style="margin-top: 20px; padding: 16px; background: #fef3c7; border-radius: 8px; border: 2px solid #f59e0b;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <span style="font-size: 14px; font-weight: 600; color: #92400e;">üìù Status: <span id="plan-status-text" style="background: #f59e0b; color: white; padding: 2px 8px; border-radius: 4px;">Draft</span></span>
                    <p style="margin: 4px 0 0 0; font-size: 12px; color: #92400e;">This plan is saved but not yet visible to your client.</p>
                </div>
                <button id="submitToClientBtn" data-action="submit-to-client" class="btn btn-primary" style="background: #10b981; color: white; font-size: 14px; padding: 10px 20px; white-space: nowrap;">
                    ‚úÖ Submit to Client
                </button>
            </div>
        </div>
    `;

    planHTML += `
        <div class="flex gap-2 mt-4 flex-wrap">
            <button data-action="generate-all-images" class="btn w-full" style="background:#8b5cf6; color:white;">üì∑ Generate All Images</button>
            <button data-action="show-meal-prep-guide" class="btn btn-primary w-full" style="background:#ff6b6b; color:white;">üìã Meal Prep Guide</button>
            <button data-action="show-grocery-list" class="btn btn-secondary w-full" style="color:white;">üìù Grocery List</button>
            <button data-action="download-pdf" class="btn btn-primary w-full" style="color:white;">üì• Download PDF</button>
            <button data-action="share-plan" class="btn btn-primary w-full" style="background:#28a745; color:white;">üîó Share Plan Link</button>
            <button data-action="save-as-template" class="btn btn-secondary w-full" style="background:#8b5cf6; color:white;">üìã Save as Template</button>
        </div>
    </div>`;
    resultDiv.innerHTML = planHTML;
}

// UPDATE PLAN STATUS UI
function updatePlanStatusUI() {
    const banner = document.getElementById('plan-status-banner');
    const statusText = document.getElementById('plan-status-text');
    const submitBtn = document.getElementById('submitToClientBtn');

    if (!banner || !statusText) return;

    if (lastPlanQuery.status === 'published') {
        banner.style.background = '#d1fae5';
        banner.style.borderColor = '#10b981';
        statusText.textContent = 'Published';
        statusText.style.background = '#10b981';
        banner.querySelector('p').textContent = 'This plan is visible to your client.';
        banner.querySelector('p').style.color = '#065f46';
        banner.querySelector('div > span').style.color = '#065f46';
        if (submitBtn) {
            submitBtn.style.display = 'none';
        }
    } else {
        banner.style.background = '#fef3c7';
        banner.style.borderColor = '#f59e0b';
        statusText.textContent = 'Draft';
        statusText.style.background = '#f59e0b';
        banner.querySelector('p').textContent = 'This plan is saved but not yet visible to your client.';
        banner.querySelector('p').style.color = '#92400e';
        banner.querySelector('div > span').style.color = '#92400e';
        if (submitBtn) {
            submitBtn.style.display = 'block';
        }
    }
}

// SHOW SAVE RETRY BUTTON (when auto-save fails)
function showSaveRetryButton() {
    const banner = document.getElementById('plan-status-banner');
    if (!banner) return;

    // Update banner to show error state
    banner.style.background = '#fee2e2';
    banner.style.borderColor = '#ef4444';

    const statusText = document.getElementById('plan-status-text');
    if (statusText) {
        statusText.textContent = 'Not Saved';
        statusText.style.background = '#ef4444';
    }

    const descP = banner.querySelector('p');
    if (descP) {
        descP.textContent = 'Plan could not be saved. Click "Save Plan" to try again.';
        descP.style.color = '#991b1b';
    }

    const colorSpan = banner.querySelector('div > span');
    if (colorSpan) {
        colorSpan.style.color = '#991b1b';
    }

    // Hide submit button, show save button
    const submitBtn = document.getElementById('submitToClientBtn');
    if (submitBtn) {
        submitBtn.style.display = 'none';
    }

    // Add or show save retry button
    let saveBtn = document.getElementById('savePlanBtn');
    if (!saveBtn) {
        saveBtn = document.createElement('button');
        saveBtn.id = 'savePlanBtn';
        saveBtn.className = 'btn btn-primary';
        saveBtn.style.cssText = 'background: #3b82f6; font-size: 14px; padding: 10px 20px; white-space: nowrap;';
        saveBtn.innerHTML = 'üíæ Save Plan';
        saveBtn.onclick = retrySavePlan;
        submitBtn.parentNode.appendChild(saveBtn);
    }
    saveBtn.style.display = 'block';
}

// HIDE SAVE RETRY BUTTON (when save succeeds)
function hideSaveRetryButton() {
    const saveBtn = document.getElementById('savePlanBtn');
    if (saveBtn) {
        saveBtn.style.display = 'none';
    }
}

// RETRY SAVING PLAN
async function retrySavePlan() {
    const saveBtn = document.getElementById('savePlanBtn');
    if (saveBtn) {
        saveBtn.innerHTML = 'üíæ Saving...';
        saveBtn.disabled = true;
    }

    const success = await saveCoachPlan(lastPlanQuery, lastPlanQuery.clientName);

    if (success) {
        // Hide the save button and show normal status
        hideSaveRetryButton();
        updatePlanStatusUI();
    } else {
        // Still failed, reset button
        if (saveBtn) {
            saveBtn.innerHTML = 'üíæ Save Plan';
            saveBtn.disabled = false;
        }
        alert('Failed to save plan. Please check your connection and try again.');
    }
}

// PUBLISH PLAN TO CLIENT
async function publishPlanToClient() {
    if (!currentCoach || !lastPlanQuery.planId) {
        // Check if save failed - show more helpful message
        if (lastPlanQuery.currentPlan && !lastPlanQuery.planId) {
            alert('Plan needs to be saved first. Please click the "Save Plan" button to save your plan before submitting to client.');
        } else {
            alert('Please generate a plan first.');
        }
        return;
    }

    const submitBtn = document.getElementById('submitToClientBtn');
    const originalText = submitBtn.innerHTML;
    submitBtn.innerHTML = 'Submitting...';
    submitBtn.disabled = true;

    try {
        const response = await fetch(PUBLISH_PLAN_ENDPOINT, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                planId: lastPlanQuery.planId,
                coachId: currentCoach.id
            })
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || 'Failed to submit plan');
        }

        const data = await response.json();
        console.log('‚úÖ Plan submitted to client:', data);

        // Update local status
        lastPlanQuery.status = 'published';

        // Update UI
        updatePlanStatusUI();

        // Show success message
        alert('Plan submitted to client successfully! They can now see this plan.');

    } catch (error) {
        console.error('Error submitting plan:', error);
        alert('Failed to submit plan: ' + error.message);
        submitBtn.innerHTML = originalText;
        submitBtn.disabled = false;
    }
}

// MANUAL SAVE BUTTON HANDLER
async function savePlanChanges() {
    if (!lastPlanQuery.currentPlan || lastPlanQuery.currentPlan.length === 0) {
        alert('No plan to save. Please generate or build a plan first.');
        return;
    }

    const saveBtn = document.getElementById('savePlanBtn');
    if (!saveBtn) return;

    const originalText = saveBtn.innerHTML;
    saveBtn.innerHTML = 'üíæ Saving...';
    saveBtn.disabled = true;

    try {
        const success = await saveCoachPlan(lastPlanQuery, lastPlanQuery.clientName);

        if (success) {
            saveBtn.innerHTML = '‚úÖ Saved!';
            saveBtn.style.background = '#10b981';

            // Reset button after 2 seconds
            setTimeout(() => {
                saveBtn.innerHTML = 'üíæ Save Changes';
                saveBtn.style.background = '#3b82f6';
                saveBtn.disabled = false;
            }, 2000);
        } else {
            throw new Error('Save failed');
        }
    } catch (error) {
        console.error('Error saving plan:', error);
        saveBtn.innerHTML = '‚ùå Save Failed';
        saveBtn.style.background = '#ef4444';

        setTimeout(() => {
            saveBtn.innerHTML = originalText;
            saveBtn.style.background = '#3b82f6';
            saveBtn.disabled = false;
        }, 2000);
    }
}

// SAVE COACH PLAN TO DATABASE
async function saveCoachPlan(planData, clientName) {
    if (!currentCoach) {
        console.warn('No coach session - plan not saved to history');
        return false;
    }

    // Use lastPlanQuery if no planData provided (for auto-saves after revisions)
    if (!planData && lastPlanQuery) {
        planData = lastPlanQuery;
        clientName = lastPlanQuery.clientName || clientName;
        console.log('üìù Auto-save: Using lastPlanQuery for plan data');
    }

    // Check if planData exists
    if (!planData) {
        console.warn('No plan data provided - cannot save');
        return false;
    }

    // Validate that clientId exists and is valid
    if (!planData.clientId || isNaN(planData.clientId) || planData.clientId <= 0) {
        console.error('‚ùå Cannot save plan: Invalid or missing clientId', planData.clientId);
        // Don't show alert for auto-saves, just log the warning
        console.warn('‚ö†Ô∏è Plan not saved: No valid client ID. Select a client to enable saving.');
        return false;
    }

    try {
        console.log('Saving plan to coach history...', planData.planId ? `(updating plan ${planData.planId})` : '(creating new plan)');

        const payload = {
            coachId: currentCoach.id,
            clientName: clientName,
            planData: planData,
            clientId: planData.clientId,  // Always include clientId (validated above)
            planId: planData.planId || null  // Include planId for updates (null for new plans)
        };

        const response = await fetch(SAVE_COACH_PLAN_ENDPOINT, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}));
            throw new Error(errorData.error || 'Failed to save plan');
        }

        const data = await response.json();
        console.log('Plan saved to history with ID:', data.planId);

        // Store the planId and status in lastPlanQuery so it can be used when sharing
        if (lastPlanQuery) {
            lastPlanQuery.planId = data.planId;
            lastPlanQuery.status = data.status || 'draft';
            console.log('‚úÖ Plan ID stored for sharing:', data.planId, 'Status:', lastPlanQuery.status);

            // Update the UI to show draft status
            updatePlanStatusUI();

            // Hide retry button if it was showing
            hideSaveRetryButton();

            // Clear unsaved changes flag
            clearUnsavedChanges();
        }

        return true; // Return success

    } catch (error) {
        console.error('Error saving plan:', error);
        // Show error to user so they know save failed
        console.error('‚ö†Ô∏è Plan save failed - user will need to retry');
        return false;
    }
}

// SAVE COACH NOTES TO PLAN
async function saveCoachNotes() {
    if (!currentCoach || !lastPlanQuery.planId) {
        alert('Please generate a plan first before saving notes.');
        return;
    }

    const notesInput = document.getElementById('coachNotesInput');
    const saveBtn = document.getElementById('saveNotesBtn');
    const notes = notesInput.value.trim();

    const originalText = saveBtn.textContent;
    saveBtn.textContent = 'Saving...';
    saveBtn.disabled = true;

    try {
        const response = await fetch(UPDATE_PLAN_NOTES_ENDPOINT, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                planId: lastPlanQuery.planId,
                coachId: currentCoach.id,
                notes: notes || null
            })
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || 'Failed to save notes');
        }

        console.log('‚úÖ Coach notes saved successfully');
        saveBtn.textContent = 'Saved!';
        saveBtn.style.background = '#28a745';
        saveBtn.style.color = 'white';

        setTimeout(() => {
            saveBtn.textContent = originalText;
            saveBtn.style.background = '';
            saveBtn.style.color = '';
            saveBtn.disabled = false;
        }, 2000);

    } catch (error) {
        console.error('Error saving notes:', error);
        alert('Failed to save notes: ' + error.message);
        saveBtn.textContent = originalText;
        saveBtn.disabled = false;
    }
}

// SAVE MEAL NOTE (per-meal coaching note)
async function saveMealNote(dayIndex, mealIndex) {
    const noteTextarea = document.getElementById(`meal-note-${dayIndex}-${mealIndex}`);
    const note = noteTextarea.value.trim();
    const saveBtn = event.target;

    // Update the meal's coach_note in the local data
    if (lastPlanQuery.currentPlan && lastPlanQuery.currentPlan[dayIndex] && lastPlanQuery.currentPlan[dayIndex].plan[mealIndex]) {
        lastPlanQuery.currentPlan[dayIndex].plan[mealIndex].coach_note = note;
    }

    // If plan is saved to database, update it
    if (!lastPlanQuery.planId) {
        // Plan not saved yet - just save locally and show feedback
        saveBtn.textContent = 'Saved!';
        saveBtn.style.background = '#28a745';
        setTimeout(() => {
            saveBtn.textContent = 'Save';
            saveBtn.style.background = '#f59e0b';
        }, 1500);
        return;
    }

    const originalText = saveBtn.textContent;
    saveBtn.textContent = '...';
    saveBtn.disabled = true;

    try {
        // Update the plan data in database with the new note
        const response = await fetch(UPDATE_PLAN_NOTES_ENDPOINT, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                planId: lastPlanQuery.planId,
                coachId: currentCoach.id,
                planData: lastPlanQuery  // Send full plan data including nutrition info
            })
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || 'Failed to save note');
        }

        console.log(`‚úÖ Meal note saved for Day ${dayIndex + 1}, Meal ${mealIndex + 1}`);
        saveBtn.textContent = 'Saved!';
        saveBtn.style.background = '#28a745';

        setTimeout(() => {
            saveBtn.textContent = originalText;
            saveBtn.style.background = '#f59e0b';
            saveBtn.disabled = false;
        }, 1500);

    } catch (error) {
        console.error('Error saving meal note:', error);
        alert('Failed to save note: ' + error.message);
        saveBtn.textContent = originalText;
        saveBtn.disabled = false;
    }
}

// RECIPE GENERATOR
async function getAIRecipe(mealName) {
    console.log('üìñ Getting recipe for:', mealName);
    const modal = document.getElementById('recipe-modal');
    const content = document.getElementById('recipe-content');

    if (!modal || !content) {
        console.error('‚ùå Recipe modal elements not found in DOM');
        alert('Error: Recipe modal not found. Please refresh the page.');
        return;
    }

    document.getElementById('recipe-title').innerText = mealName;
    modal.classList.remove('hidden');
    content.innerHTML = '<div class="loader"><div class="loader-spinner"></div></div>';

    try {
        const prompt = `Recipe for "${mealName}". Use markdown with ### Ingredients and ### Instructions headings.`;
        const recipe = await callGemini(prompt, false);

        if (recipe.error) {
            content.innerHTML = `<p class="text-red-500">${recipe.error}</p>`;
        } else if (typeof recipe !== 'string') {
            console.error('‚ùå Recipe response is not a string:', typeof recipe, recipe);
            content.innerHTML = '<p class="text-red-500">Error: Invalid recipe format received. Please try again.</p>';
        } else {
            console.log('‚úÖ Recipe generated successfully');
            let html = recipe
                .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
                .replace(/^### (.*$)/gim, '<h3>$1</h3>')
                .replace(/^\* (.*$)/gim, '<li>$1</li>')
                .replace(/^(\d+)\. (.*$)/gim, '<li>$2</li>')
                .replace(/<\/li>\n<li>/g, '</li><li>');

            html = html.replace(/(<li>.*<\/li>)/gs, (match) => {
                if(match.toLowerCase().includes('ingredient')) return `<ul>${match}</ul>`;
                return `<ol>${match}</ol>`;
            });

            content.innerHTML = html;
        }
    } catch (error) {
        console.error('‚ùå Error generating recipe:', error);
        content.innerHTML = `<p class="text-red-500">Error generating recipe: ${error.message}. Please try again.</p>`;
    }
}

// CHANGE MEAL - Generate a completely different meal
async function changeMeal(dayIndex, mealIndex) {
    const meal = lastPlanQuery.currentPlan[dayIndex].plan[mealIndex];

    // Save current meal state for undo functionality
    const stateKey = `${dayIndex}-${mealIndex}`;
    previousMealStates[stateKey] = JSON.parse(JSON.stringify(meal)); // Deep copy
    saveUndoStates(); // Persist to localStorage
    console.log(`üíæ Saved previous state for undo (change):`, previousMealStates[stateKey]);

    // Calculate per-meal targets based on MEAL TYPE (not equal distribution)
    // This ensures proper calorie distribution across the day
    const dailyCal = lastPlanQuery.calories || 2000;
    const dailyProtein = lastPlanQuery.protein || 150;
    const dailyCarbs = lastPlanQuery.carbs || 200;
    const dailyFat = lastPlanQuery.fat || 70;
    const mealType = meal.type?.toLowerCase() || 'meal';

    // Meal-type specific distribution percentages
    let calPercent = 0.25; // Default
    if (mealType === 'breakfast') calPercent = 0.27;
    else if (mealType === 'lunch') calPercent = 0.32;
    else if (mealType === 'dinner') calPercent = 0.28;
    else if (mealType === 'snack' || mealType === 'snack 1' || mealType === 'snack 2') calPercent = 0.13;

    const targetCalories = Math.round(dailyCal * calPercent);
    const targetProtein = Math.round(dailyProtein * calPercent);
    const targetCarbs = Math.round(dailyCarbs * calPercent);
    const targetFat = Math.round(dailyFat * calPercent);

    console.log(`üéØ Exchange targets for ${mealType} (${Math.round(calPercent * 100)}% of daily): ${targetCalories}cal, ${targetProtein}P, ${targetCarbs}C, ${targetFat}F`);

    // Show loading
    displayDietPlan(lastPlanQuery.currentPlan);
    const mealCards = document.querySelectorAll('.meal-card');
    let cardIndex = 0;
    for (let d = 0; d < dayIndex; d++) {
        cardIndex += lastPlanQuery.currentPlan[d].plan.length;
    }
    cardIndex += mealIndex;
    const targetCard = mealCards[cardIndex];
    if (targetCard) {
        targetCard.innerHTML = '<div class="loader"><div class="loader-spinner"></div></div><p class="text-center">Generating different meal...</p>';
    }

    const variationSeed = Math.floor(Math.random() * 1000000);
    const aiPrompt = `Generate a COMPLETELY DIFFERENT ${meal.type} meal (NOT "${meal.name}").
[Variation: ${variationSeed}] - Generate something UNIQUE and CREATIVE.
Diet: ${lastPlanQuery.preference}
Macro Preference: ${lastPlanQuery.macroPreference}
Avoid: ${lastPlanQuery.allergies}
Disliked Foods: ${lastPlanQuery.dislikedFoods}
Preferred Foods: ${lastPlanQuery.preferredFoods}
Budget: ${lastPlanQuery.budget}
Available Equipment: ${lastPlanQuery.equipmentStr}

STRICT TARGET MACROS - the new meal MUST closely match:
- Calories: ${targetCalories} (stay within ¬±50 calories)
- Protein: ${targetProtein}g (stay within ¬±5g)
- Carbs: ${targetCarbs}g (stay within ¬±10g)
- Fat: ${targetFat}g (stay within ¬±5g)

Use ONLY foods from USDA database - you can choose from 200+ foods including:
Proteins: Chicken Breast, Salmon, Ground Turkey, Eggs, Shrimp, Tofu, Greek Yogurt
Carbs: Brown Rice, Quinoa, Sweet Potato, Oats, Whole Wheat Bread, Pasta
Fats: Olive Oil, Avocado, Almonds, Peanut Butter
Vegetables: Broccoli, Spinach, Bell Pepper, Asparagus, etc.

CRITICAL:
1. Return ingredients as ARRAY OF STRINGS with amounts in parentheses
2. DO NOT include calories/protein/carbs/fat - backend will calculate from database
3. Choose portions that CLOSELY MATCH the target macros - this is ESSENTIAL
4. If original meal was small (under 400 cal), keep new meal small. If large (over 600 cal), keep it large.
MEAL NAME FORMAT: Include ALL key ingredient portions inline in parentheses

EXAMPLE FORMAT (3-4 ingredients with larger portions):
{"type":"${meal.type}","name":"Grilled Chicken Breast (150g) with Quinoa (1 cup cooked) and Broccoli (150g)","ingredients":["Chicken Breast (150g)","Quinoa (1 cup cooked)","Broccoli (150g)","Olive Oil (1 tsp)"],"instructions":"Grill chicken breast. Cook quinoa. Steam broccoli. Drizzle with olive oil."}

Return ONLY valid JSON. NO quotes in text - use apostrophes. Keep it brief.`;

    // Call backend with CONSISTENT targets (not current meal's drifted values)
    const mealTargets = {
        calories: targetCalories,
        protein: targetProtein,
        carbs: targetCarbs,
        fat: targetFat
    };

    // Try up to 2 times to get a valid meal
    let validMeal = null;
    let retryCount = 0;
    const maxRetries = 2;

    while (retryCount < maxRetries && !validMeal) {
        // Add retry variation to prompt if this is a retry
        const retryPrompt = retryCount > 0
            ? aiPrompt + `\n\n‚ö†Ô∏è RETRY ${retryCount}: Previous attempt had issues. Ensure meal has adequate protein (minimum ${Math.round(targetProtein * 0.5)}g) and includes a protein source like chicken, fish, eggs, yogurt, tofu, etc.`
            : aiPrompt;

        const newMeal = await callGemini(retryPrompt, true, mealTargets, null, 1);

        if (!newMeal.error) {
            // Validate that backend returned complete meal with macros
            if (!newMeal.calories || !newMeal.protein || !newMeal.carbs || newMeal.fat === undefined) {
                console.error('‚ùå Backend returned incomplete meal:', newMeal);
                retryCount++;
                continue;
            }

            // Validate meal quality (protein, etc.)
            const validation = validateMeal(newMeal, meal.type);
            if (!validation.valid) {
                console.warn(`‚ö†Ô∏è Change meal validation failed (attempt ${retryCount + 1}):`, validation.issues);
                retryCount++;
                continue;
            }

            validMeal = newMeal;
        } else {
            console.error('‚ùå Meal generation error:', newMeal.error);
            retryCount++;
        }
    }

    if (validMeal) {
        // Backend calculated accurate macros - use them directly
        lastPlanQuery.currentPlan[dayIndex].plan[mealIndex] = validMeal;

        // Auto-save if plan already exists in database
        if (lastPlanQuery.planId) {
            saveCoachPlan();
        }

        displayDietPlan(lastPlanQuery.currentPlan);
    } else {
        console.error(`‚ùå Failed to generate valid meal after ${maxRetries} attempts`);
        alert('Could not generate a valid meal. Please try again or use "Custom" to enter your own meal.');
        displayDietPlan(lastPlanQuery.currentPlan);
    }
}

// REVISE MEAL - Custom user modifications
async function reviseMeal(dayIndex, mealIndex) {
    const meal = lastPlanQuery.currentPlan[dayIndex].plan[mealIndex];
    const userRequest = window.prompt(
`Revise "${meal.name}"?

Examples of what you can request:

üìä ADJUST PORTIONS:
‚Ä¢ "increase chicken to 250g"
‚Ä¢ "double the portion size"
‚Ä¢ "make this 800 calories"
‚Ä¢ "reduce carbs by 20g"

üîÑ SWAP INGREDIENTS:
‚Ä¢ "swap rice for sweet potato"
‚Ä¢ "replace chicken with salmon"
‚Ä¢ "use egg whites instead of whole eggs"

ü•ó DIETARY CHANGES:
‚Ä¢ "make it vegetarian"
‚Ä¢ "make it dairy-free"
‚Ä¢ "add more protein"

‚ú® OTHER:
‚Ä¢ "simplify - fewer ingredients"
‚Ä¢ "make it a smoothie instead"
‚Ä¢ "add avocado"

Enter your request:`, '');

    if (!userRequest || !userRequest.trim()) return;

    // Save current meal state for undo functionality
    const stateKey = `${dayIndex}-${mealIndex}`;
    previousMealStates[stateKey] = JSON.parse(JSON.stringify(meal)); // Deep copy
    saveUndoStates(); // Persist to localStorage
    console.log(`üíæ Saved previous state for undo (revise):`, previousMealStates[stateKey]);

    // Show loading
    displayDietPlan(lastPlanQuery.currentPlan);
    const mealCards = document.querySelectorAll('.meal-card');
    let cardIndex = 0;
    for (let d = 0; d < dayIndex; d++) {
        cardIndex += lastPlanQuery.currentPlan[d].plan.length;
    }
    cardIndex += mealIndex;
    const targetCard = mealCards[cardIndex];
    if (targetCard) {
        targetCard.innerHTML = '<div class="loader"><div class="loader-spinner"></div></div><p class="text-center">Revising meal...</p>';
    }

    const aiPrompt = `Revise this meal based on user request: "${meal.name}" (${meal.type})

USER REQUEST: ${userRequest}

CURRENT MEAL:
- Calories: ${meal.calories}
- Protein: ${meal.protein}g
- Carbs: ${meal.carbs}g
- Fat: ${meal.fat}g
- Ingredients: ${meal.ingredients ? meal.ingredients.map(ing => typeof ing === 'string' ? ing : `${ing.amount} ${ing.food}`).join(', ') : 'N/A'}

REVISION RULES - Follow these carefully:

1. EXPLICIT AMOUNTS: If user specifies exact amount (e.g., "make salmon 200g", "use 2 eggs"),
   use EXACTLY that amount even if it changes the meal's total calories.

2. VAGUE INCREASE: If user says "increase salmon" or "more protein" (no specific amount),
   increase by a reasonable amount (~30-50%) AND reduce other ingredients to keep total calories similar.

3. SWAP INGREDIENT: If user says "swap salmon for chicken" or "replace rice with quinoa",
   calculate the NEW ingredient amount to match the CALORIES of the original ingredient.
   Example: 130g salmon (230 cal) ‚Üí ~140g chicken breast to match ~230 cal

4. ADD NEW INGREDIENT: If user says "add chicken" to a meal that has none,
   ADD it on top - the meal will be bigger. Don't reduce other ingredients.

5. COMPLETE REPLACEMENT: If user specifies an entirely new meal or uses words like
   "just", "only", "make it", "change to", or "replace with", use ONLY the ingredients
   they specify. Do NOT add extra ingredients to match the original meal's calories.
   The new calorie total will be whatever the specified ingredients naturally add up to.
   Example: "just a protein shake with creatine" = ONLY protein powder + creatine, nothing else.

Diet: ${lastPlanQuery.preference}
Macro Preference: ${lastPlanQuery.macroPreference}
Avoid: ${lastPlanQuery.allergies}
Disliked Foods: ${lastPlanQuery.dislikedFoods}
Preferred Foods: ${lastPlanQuery.preferredFoods}
Budget: ${lastPlanQuery.budget}
Available Equipment: ${lastPlanQuery.equipmentStr}

Use ONLY foods from USDA database - you can choose from 200+ foods including:
Proteins: Chicken Breast, Salmon, Ground Turkey, Eggs, Shrimp, Tofu, Greek Yogurt
Carbs: Brown Rice, Quinoa, Sweet Potato, Oats, Whole Wheat Bread, Pasta
Fats: Olive Oil, Avocado, Almonds, Peanut Butter
Vegetables: Broccoli, Spinach, Bell Pepper, Asparagus, etc.

CRITICAL:
1. Return ingredients as ARRAY OF STRINGS with amounts in parentheses
2. DO NOT include calories/protein/carbs/fat - backend will calculate from database
MEAL NAME FORMAT: Include ALL key ingredient portions inline in parentheses

EXAMPLE FORMAT:
{"type":"${meal.type}","name":"Baked Turkey Breast (200g) with Sweet Potato (150g) and Green Beans (100g)","ingredients":["Turkey Breast (200g)","Sweet Potato (150g)","Green Beans (100g)","Olive Oil (1 tsp)"],"instructions":"Bake turkey at 375F for 25 mins. Roast sweet potato. Steam green beans."}

Return ONLY valid JSON. NO quotes in text - use apostrophes. Keep it brief.`;

    // Pass current meal macros as targets, with skipAutoScale for revisions
    const mealTargets = {
        calories: meal.calories,
        protein: meal.protein,
        carbs: meal.carbs,
        fat: meal.fat
    };

    const revisedMeal = await callGemini(aiPrompt, true, mealTargets, null, 1, true); // true = skipAutoScale

    if (!revisedMeal.error) {
        // Validate that backend returned complete meal with macros
        if (!revisedMeal.calories || !revisedMeal.protein || !revisedMeal.carbs || revisedMeal.fat === undefined) {
            console.error('‚ùå Backend returned incomplete meal:', revisedMeal);
            alert('Error: Backend did not calculate macros. Check console for details.');
            displayDietPlan(lastPlanQuery.currentPlan);
            return;
        }

        // Check for empty/placeholder meal (blocking validation)
        const isEmptyMeal = (
            revisedMeal.calories === 0 ||
            !revisedMeal.ingredients ||
            !Array.isArray(revisedMeal.ingredients) ||
            revisedMeal.ingredients.length === 0 ||
            !revisedMeal.name ||
            revisedMeal.name === 'Meal' ||
            revisedMeal.name === 'Unnamed Meal'
        );

        if (isEmptyMeal) {
            console.error('‚ùå Backend returned empty/placeholder meal:', revisedMeal);
            alert('Error: Could not revise meal - got empty result. Please try again.');
            displayDietPlan(lastPlanQuery.currentPlan);
            return;
        }

        // Warn (but don't block) for low protein in revisions - user may have requested it
        const validation = validateMeal(revisedMeal, meal.type);
        if (!validation.valid) {
            console.warn('‚ö†Ô∏è Revised meal has validation warnings:', validation.issues);
        }

        // Backend calculated accurate macros - use them directly
        lastPlanQuery.currentPlan[dayIndex].plan[mealIndex] = revisedMeal;

        // Auto-save if plan already exists in database
        if (lastPlanQuery.planId) {
            saveCoachPlan();
        }

        displayDietPlan(lastPlanQuery.currentPlan);
    } else {
        alert('Error revising meal: ' + revisedMeal.error);
        displayDietPlan(lastPlanQuery.currentPlan);
    }
}

// UNDO MEAL - Restore previous meal state
function undoMeal(dayIndex, mealIndex) {
    const stateKey = `${dayIndex}-${mealIndex}`;
    const previousState = previousMealStates[stateKey];

    if (!previousState) {
        alert('No previous state to undo');
        return;
    }

    console.log(`‚Ü©Ô∏è Undoing meal change for ${stateKey}:`, previousState);

    // Restore the previous meal state
    lastPlanQuery.currentPlan[dayIndex].plan[mealIndex] = JSON.parse(JSON.stringify(previousState));

    // Remove the undo state (can only undo once)
    delete previousMealStates[stateKey];
    saveUndoStates(); // Persist to localStorage

    // Auto-save if plan already exists in database
    if (lastPlanQuery.planId) {
        saveCoachPlan();
    }

    // Re-render the plan
    displayDietPlan(lastPlanQuery.currentPlan);

    // Show success message
    alert('Undo successful! Meal restored to previous state.');
}

// ADJUST PORTIONS - Quick serving size adjustment with stepper
let currentPortionMultiplier = 1.0;
const PORTION_STEP = 0.25;
const PORTION_MIN = 0.25;
const PORTION_MAX = 3.0;

function showPortionsDropdown(buttonElement, dayIndex, mealIndex) {
    // Remove any existing stepper/dropdown
    const existingStepper = document.querySelector('.portions-stepper');
    if (existingStepper) {
        existingStepper.remove();
    }
    const existingDropdown = document.querySelector('.portions-dropdown');
    if (existingDropdown) {
        existingDropdown.remove();
    }

    // Reset to 1.0x when opening
    currentPortionMultiplier = 1.0;

    const stepper = document.createElement('div');
    stepper.className = 'portions-stepper';

    stepper.innerHTML = `
        <span class="portions-stepper-label">Adjust Portions</span>
        <div class="portions-stepper-controls">
            <button class="portions-step-btn" id="portions-decrease" title="Decrease">‚àí</button>
            <span class="portions-value" id="portions-value">1.0x</span>
            <button class="portions-step-btn" id="portions-increase" title="Increase">+</button>
        </div>
        <div class="portions-presets">
            <button class="portions-preset-btn" data-multiplier="0.5">¬Ω</button>
            <button class="portions-preset-btn" data-multiplier="0.75">¬æ</button>
            <button class="portions-preset-btn" data-multiplier="1.5">1.5x</button>
            <button class="portions-preset-btn" data-multiplier="2">2x</button>
        </div>
        <button class="portions-stepper-apply" id="portions-apply">Apply</button>
    `;

    // Position the stepper below the button
    const rect = buttonElement.getBoundingClientRect();
    stepper.style.top = `${rect.bottom + 5}px`;
    stepper.style.left = `${rect.left}px`;

    document.body.appendChild(stepper);

    // Update display function
    const updateDisplay = () => {
        const valueEl = document.getElementById('portions-value');
        const decreaseBtn = document.getElementById('portions-decrease');
        const increaseBtn = document.getElementById('portions-increase');

        valueEl.textContent = `${currentPortionMultiplier.toFixed(2).replace(/\.?0+$/, '')}x`;
        decreaseBtn.disabled = currentPortionMultiplier <= PORTION_MIN;
        increaseBtn.disabled = currentPortionMultiplier >= PORTION_MAX;
    };

    // Decrease button
    document.getElementById('portions-decrease').onclick = (e) => {
        e.stopPropagation();
        if (currentPortionMultiplier > PORTION_MIN) {
            currentPortionMultiplier = Math.max(PORTION_MIN, currentPortionMultiplier - PORTION_STEP);
            updateDisplay();
        }
    };

    // Increase button
    document.getElementById('portions-increase').onclick = (e) => {
        e.stopPropagation();
        if (currentPortionMultiplier < PORTION_MAX) {
            currentPortionMultiplier = Math.min(PORTION_MAX, currentPortionMultiplier + PORTION_STEP);
            updateDisplay();
        }
    };

    // Preset buttons
    stepper.querySelectorAll('.portions-preset-btn').forEach(btn => {
        btn.onclick = (e) => {
            e.stopPropagation();
            currentPortionMultiplier = parseFloat(btn.dataset.multiplier);
            updateDisplay();
        };
    });

    // Apply button
    document.getElementById('portions-apply').onclick = (e) => {
        e.stopPropagation();
        if (currentPortionMultiplier !== 1.0) {
            adjustPortions(dayIndex, mealIndex, currentPortionMultiplier);
        }
        stepper.remove();
    };

    // Close stepper when clicking outside
    const closeStepper = (e) => {
        if (!stepper.contains(e.target) && e.target !== buttonElement) {
            stepper.remove();
            document.removeEventListener('click', closeStepper);
        }
    };
    setTimeout(() => document.addEventListener('click', closeStepper), 0);
}

function adjustPortions(dayIndex, mealIndex, multiplier) {
    const meal = lastPlanQuery.currentPlan[dayIndex].plan[mealIndex];

    // Save current meal state for undo functionality
    const stateKey = `${dayIndex}-${mealIndex}`;
    previousMealStates[stateKey] = JSON.parse(JSON.stringify(meal));
    saveUndoStates();
    console.log(`üíæ Saved previous state for undo (portions):`, previousMealStates[stateKey]);

    // Scale macros proportionally
    meal.calories = Math.round(meal.calories * multiplier);
    meal.protein = Math.round(meal.protein * multiplier);
    meal.carbs = Math.round(meal.carbs * multiplier);
    meal.fat = Math.round(meal.fat * multiplier);

    // Update meal name to reflect portion change
    const portionLabel = multiplier < 1 ? `${multiplier}x portion` : `${multiplier}x portion`;
    if (!meal.name.includes('portion')) {
        meal.name = `${meal.name} (${portionLabel})`;
    } else {
        // Replace existing portion label
        meal.name = meal.name.replace(/\s*\([0-9.]+x portion\)/, ` (${portionLabel})`);
    }

    // Auto-save if plan already exists in database
    if (lastPlanQuery.planId) {
        saveCoachPlan();
    }

    displayDietPlan(lastPlanQuery.currentPlan);
    console.log(`‚öñÔ∏è Adjusted portions for ${meal.type}: ${multiplier}x`);
}

// ========================================
// CUSTOM MEAL MODAL FUNCTIONALITY
// ========================================

// State for custom meal modal
let customMealDayIndex = null;
let customMealMealIndex = null;
let customMealSelectedIngredients = [];
let foodSearchTimeout = null;
let foodSearchResults = [];
const FOOD_SEARCH_ENDPOINT = '/.netlify/functions/usda-search';

// CUSTOM MEAL - Opens the modal instead of prompt
function customMeal(dayIndex, mealIndex) {
    customMealDayIndex = dayIndex;
    customMealMealIndex = mealIndex;
    customMealSelectedIngredients = [];

    // Reset modal state
    document.getElementById('foodSearchInput').value = '';
    document.getElementById('foodSearchResults').classList.remove('active');
    document.getElementById('foodSearchResults').innerHTML = '';
    document.getElementById('calculatedMealName').value = '';
    document.getElementById('calculatedMealInstructions').value = '';
    document.getElementById('manualMealName').value = '';
    document.getElementById('manualCalories').value = '';
    document.getElementById('manualProtein').value = '';
    document.getElementById('manualCarbs').value = '';
    document.getElementById('manualFat').value = '';
    document.getElementById('manualInstructions').value = '';

    // Reset to calculate tab
    switchCustomMealTab('calculate');

    // Update UI
    renderCustomMealIngredients();
    updateCustomMealTotals();

    // Show modal
    document.getElementById('customMealModal').classList.add('show');
}

// EDIT CUSTOM MEAL - Opens modal pre-populated with existing meal data
async function editCustomMeal(dayIndex, mealIndex) {
    // Get the existing meal data
    const meal = lastPlanQuery.currentPlan[dayIndex]?.plan[mealIndex];

    if (!meal) {
        console.error('Could not find meal to edit');
        return;
    }

    // Set up the indices
    customMealDayIndex = dayIndex;
    customMealMealIndex = mealIndex;

    // Reset modal state first
    document.getElementById('foodSearchInput').value = '';
    document.getElementById('foodSearchResults').classList.remove('active');
    document.getElementById('foodSearchResults').innerHTML = '';
    document.getElementById('calculatedMealName').value = '';
    document.getElementById('calculatedMealInstructions').value = '';
    document.getElementById('manualMealName').value = '';
    document.getElementById('manualCalories').value = '';
    document.getElementById('manualProtein').value = '';
    document.getElementById('manualCarbs').value = '';
    document.getElementById('manualFat').value = '';
    document.getElementById('manualInstructions').value = '';

    // Show modal first (so user sees something happening)
    document.getElementById('customMealModal').classList.add('show');

    // Check if meal has full ingredient data (from Food Database)
    let ingredientData = meal.ingredientData;

    // If no ingredientData, try to parse and look up ingredients
    if ((!ingredientData || !Array.isArray(ingredientData) || ingredientData.length === 0) && meal.ingredients) {
        console.log('üîç No ingredientData found, attempting to parse ingredients...');
        ingredientData = await parseAndLookupIngredients(meal.ingredients);
    }

    if (ingredientData && Array.isArray(ingredientData) && ingredientData.length > 0) {
        // Load ingredients into Calculate tab
        customMealSelectedIngredients = JSON.parse(JSON.stringify(ingredientData));

        // Switch to calculate tab
        switchCustomMealTab('calculate');

        // Clear meal name so it auto-generates based on current ingredients
        // (user can still type a custom name if they want)
        document.getElementById('calculatedMealName').value = '';
        document.getElementById('calculatedMealInstructions').value = meal.instructions || '';

        // Render the ingredients and update totals
        renderCustomMealIngredients();
        updateCustomMealTotals();

        console.log('üìù Editing meal with ingredients:', customMealSelectedIngredients);
    } else {
        // Fall back to manual tab for meals without ingredient data
        customMealSelectedIngredients = [];
        switchCustomMealTab('manual');

        // Pre-populate the manual panel fields with existing meal data
        document.getElementById('manualMealName').value = meal.name || '';
        document.getElementById('manualCalories').value = meal.calories || '';
        document.getElementById('manualProtein').value = meal.protein || '';
        document.getElementById('manualCarbs').value = meal.carbs || '';
        document.getElementById('manualFat').value = meal.fat || '';
        document.getElementById('manualInstructions').value = meal.instructions || '';

        // Update UI
        renderCustomMealIngredients();
        updateCustomMealTotals();
    }
}

function closeCustomMealModal() {
    document.getElementById('customMealModal').classList.remove('show');
    customMealDayIndex = null;
    customMealMealIndex = null;
    customMealSelectedIngredients = [];

    // Reset form fields
    document.getElementById('foodSearchInput').value = '';
    document.getElementById('foodSearchResults').classList.remove('active');
    document.getElementById('calculatedMealName').value = '';
    document.getElementById('calculatedMealInstructions').value = '';
    document.getElementById('manualMealName').value = '';
    document.getElementById('manualCalories').value = '';
    document.getElementById('manualProtein').value = '';
    document.getElementById('manualCarbs').value = '';
    document.getElementById('manualFat').value = '';
    document.getElementById('manualInstructions').value = '';

    // Reset save for later checkboxes
    document.getElementById('saveCalculatedForLater').checked = false;
    document.getElementById('saveManualForLater').checked = false;

    // Reset to first tab
    switchCustomMealTab('calculate');
}

function switchCustomMealTab(tab) {
    // Update tab active states
    document.querySelectorAll('.custom-meal-tab').forEach((t, i) => {
        t.classList.toggle('active',
            (tab === 'calculate' && i === 0) ||
            (tab === 'manual' && i === 1) ||
            (tab === 'saved' && i === 2)
        );
    });

    // Update panel visibility
    document.getElementById('calculatePanel').classList.toggle('active', tab === 'calculate');
    document.getElementById('manualPanel').classList.toggle('active', tab === 'manual');
    document.getElementById('savedPanel').classList.toggle('active', tab === 'saved');

    // Render saved meals when switching to saved tab
    if (tab === 'saved') {
        renderSavedMeals();
    }
}

// Saved Meals Management - Database backed (per coach)
const SAVED_MEALS_ENDPOINT = '/.netlify/functions/saved-meals';
let savedMealsCache = []; // In-memory cache of coach's saved meals

async function loadSavedMeals() {
    if (!currentCoach) {
        console.log('‚ö†Ô∏è Cannot load saved meals - no coach logged in');
        savedMealsCache = [];
        return [];
    }

    try {
        const response = await fetch(`${SAVED_MEALS_ENDPOINT}?coachId=${currentCoach.id}`);
        const data = await response.json();

        if (data.meals) {
            // Transform database format to match expected format
            savedMealsCache = data.meals.map(m => ({
                id: m.id.toString(),
                savedAt: m.created_at,
                ...m.meal_data
            }));
            console.log(`üìö Loaded ${savedMealsCache.length} saved meals from database`);
        } else {
            savedMealsCache = [];
        }
        return savedMealsCache;
    } catch (error) {
        console.error('Error loading saved meals:', error);
        savedMealsCache = [];
        return [];
    }
}

function getSavedMeals() {
    return savedMealsCache;
}

async function saveMealToLibrary(meal) {
    if (!currentCoach) {
        alert('Please log in to save meals to your library');
        return null;
    }

    try {
        const response = await fetch(SAVED_MEALS_ENDPOINT, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                coachId: currentCoach.id,
                mealData: meal
            })
        });

        const data = await response.json();

        if (data.success && data.meal) {
            // Add to cache
            const newMeal = {
                id: data.meal.id.toString(),
                savedAt: data.meal.created_at,
                ...data.meal.meal_data
            };
            savedMealsCache.unshift(newMeal);
            console.log('üíæ Meal saved to library:', newMeal.name);
            return newMeal;
        } else {
            throw new Error(data.error || 'Failed to save meal');
        }
    } catch (error) {
        console.error('Error saving meal to library:', error);
        alert('Failed to save meal to library. Please try again.');
        return null;
    }
}

async function deleteSavedMeal(mealId) {
    if (!currentCoach) {
        alert('Please log in to manage your meal library');
        return;
    }

    try {
        const response = await fetch(`${SAVED_MEALS_ENDPOINT}?mealId=${mealId}&coachId=${currentCoach.id}`, {
            method: 'DELETE'
        });

        const data = await response.json();

        if (data.success) {
            // Remove from cache
            savedMealsCache = savedMealsCache.filter(m => m.id !== mealId);
            renderSavedMeals();
            console.log('üóëÔ∏è Meal deleted from library:', mealId);
        } else {
            throw new Error(data.error || 'Failed to delete meal');
        }
    } catch (error) {
        console.error('Error deleting saved meal:', error);
        alert('Failed to delete meal. Please try again.');
    }
}

function useSavedMeal(mealId) {
    const savedMeals = getSavedMeals();
    const meal = savedMeals.find(m => m.id === mealId);
    if (!meal) {
        alert('Meal not found');
        return;
    }

    // Get meal type from original meal
    const originalMeal = lastPlanQuery.currentPlan[customMealDayIndex].plan[customMealMealIndex];
    const mealType = originalMeal.type || 'meal';

    // Save for undo
    const stateKey = `${customMealDayIndex}-${customMealMealIndex}`;
    previousMealStates[stateKey] = JSON.parse(JSON.stringify(originalMeal));
    saveUndoStates(); // Persist to localStorage

    // Create the meal (without id and savedAt)
    const newMeal = {
        type: mealType,
        name: meal.name,
        ingredients: meal.ingredients,
        ingredientData: meal.ingredientData,  // Include full ingredient data for editing
        calories: meal.calories,
        protein: meal.protein,
        carbs: meal.carbs,
        fat: meal.fat,
        instructions: meal.instructions || 'Prepare as desired.',
        source: meal.source || 'Saved Meal',
        isCustom: true
    };

    // Update the meal in the plan
    lastPlanQuery.currentPlan[customMealDayIndex].plan[customMealMealIndex] = newMeal;

    // Auto-save if plan already exists
    if (lastPlanQuery.planId) {
        saveCoachPlan();
    }

    // Close modal and refresh display
    closeCustomMealModal();
    displayDietPlan(lastPlanQuery.currentPlan);
    console.log('‚úÖ Used saved meal:', newMeal.name);
}

// Parse ingredient string and look up in food database
async function parseAndLookupIngredients(ingredients) {
    if (!ingredients || !Array.isArray(ingredients) || ingredients.length === 0) {
        return null;
    }

    const ingredientData = [];

    for (const ingStr of ingredients) {
        // Try to parse formats like "Food Name (150g)" or "Food Name (1 Serving)"
        // Also handle "150g Food Name" format
        let match = ingStr.match(/^(.+?)\s*\((\d+\.?\d*)\s*(g|serving|cup|tbsp|tsp|oz|scoop|whole|medium|large|slice)s?\)$/i);

        if (!match) {
            // Try alternate format: "150g Food Name"
            match = ingStr.match(/^(\d+\.?\d*)\s*(g|serving|cup|tbsp|tsp|oz)\s+(.+)$/i);
            if (match) {
                // Rearrange to [full, name, quantity, unit]
                match = [match[0], match[3], match[1], match[2]];
            }
        }

        if (!match) {
            console.log('Could not parse ingredient:', ingStr);
            continue;
        }

        const [, name, quantity, unit] = match;
        const cleanName = name.trim();
        const qty = parseFloat(quantity);
        const cleanUnit = unit.toLowerCase();

        try {
            // Look up in food database
            const response = await fetch(`${FOOD_SEARCH_ENDPOINT}?query=${encodeURIComponent(cleanName)}`);
            const data = await response.json();

            if (data.foods && data.foods.length > 0) {
                // Use the first match
                const food = data.foods[0];

                // Calculate quantity in grams
                let quantityGrams = qty;
                if (cleanUnit !== 'g') {
                    // Use serving size conversion if available
                    if (food.gramsPerServing) {
                        quantityGrams = qty * food.gramsPerServing;
                    } else {
                        // Default conversions
                        const conversions = { cup: 240, tbsp: 15, tsp: 5, oz: 28, serving: 100, scoop: 30, whole: 50, medium: 150, large: 200, slice: 30 };
                        quantityGrams = qty * (conversions[cleanUnit] || 100);
                    }
                }

                ingredientData.push({
                    name: cleanName, // Keep original name from meal
                    originalName: cleanName,
                    dbName: food.name, // Store database name for reference
                    caloriesPer100g: food.caloriesPer100g,
                    proteinPer100g: food.proteinPer100g,
                    carbsPer100g: food.carbsPer100g,
                    fatPer100g: food.fatPer100g,
                    quantity: qty,
                    selectedUnit: cleanUnit,
                    quantityGrams: quantityGrams,
                    gramsPerServing: food.gramsPerServing
                });
                console.log('‚úÖ Found ingredient:', cleanName, '(matched to:', food.name + ')');
            } else {
                console.log('‚ùå No match found for:', cleanName);
            }
        } catch (error) {
            console.error('Error looking up ingredient:', cleanName, error);
        }
    }

    return ingredientData.length > 0 ? ingredientData : null;
}

// Edit a saved meal before using it
async function editSavedMeal(mealId) {
    const savedMeals = getSavedMeals();
    const meal = savedMeals.find(m => m.id === mealId);
    if (!meal) {
        alert('Meal not found');
        return;
    }

    // Check if meal has full ingredient data (from Food Database)
    let ingredientData = meal.ingredientData;

    // If no ingredientData, try to parse and look up ingredients
    if ((!ingredientData || !Array.isArray(ingredientData) || ingredientData.length === 0) && meal.ingredients) {
        console.log('üîç No ingredientData found, attempting to parse ingredients...');
        ingredientData = await parseAndLookupIngredients(meal.ingredients);
    }

    if (ingredientData && Array.isArray(ingredientData) && ingredientData.length > 0) {
        // Load ingredients into Calculate tab
        customMealSelectedIngredients = JSON.parse(JSON.stringify(ingredientData));

        // Switch to calculate tab
        switchCustomMealTab('calculate');

        // Pre-populate meal name and instructions
        document.getElementById('calculatedMealName').value = meal.name || '';
        document.getElementById('calculatedMealInstructions').value = meal.instructions || '';

        // Render the ingredients and update totals
        renderCustomMealIngredients();
        updateCustomMealTotals();

        console.log('üìù Editing saved meal with ingredients:', customMealSelectedIngredients);
    } else {
        // Fall back to manual tab for meals without ingredient data
        switchCustomMealTab('manual');

        // Pre-populate the manual panel fields with existing meal data
        document.getElementById('manualMealName').value = meal.name || '';
        document.getElementById('manualCalories').value = meal.calories || '';
        document.getElementById('manualProtein').value = meal.protein || '';
        document.getElementById('manualCarbs').value = meal.carbs || '';
        document.getElementById('manualFat').value = meal.fat || '';
        document.getElementById('manualInstructions').value = meal.instructions || '';
    }
}

function renderSavedMeals() {
    const container = document.getElementById('savedMealsList');
    const savedMeals = getSavedMeals();

    if (savedMeals.length === 0) {
        container.innerHTML = '<div class="no-saved-meals">No saved meals yet. Create a meal and check "Save for future use" to add it here.</div>';
        return;
    }

    container.innerHTML = savedMeals.map(meal => `
        <div class="saved-meal-item">
            <div class="saved-meal-info">
                <div class="saved-meal-name">${escapeHtmlCustomMeal(meal.name)}</div>
                <div class="saved-meal-macros">${meal.calories} cal | ${meal.protein}g P | ${meal.carbs}g C | ${meal.fat}g F</div>
            </div>
            <div class="saved-meal-actions">
                <button class="btn-edit-saved" onclick="editSavedMeal('${meal.id}')" title="Edit before using">‚úé</button>
                <button class="btn-use-saved" onclick="useSavedMeal('${meal.id}')">Use</button>
                <button class="btn-delete-saved" onclick="deleteSavedMeal('${meal.id}')">üóëÔ∏è</button>
            </div>
        </div>
    `).join('');
}

// Food search functionality
function handleFoodSearch(query) {
    const resultsDiv = document.getElementById('foodSearchResults');

    if (foodSearchTimeout) {
        clearTimeout(foodSearchTimeout);
    }

    if (!query || query.trim().length < 2) {
        resultsDiv.classList.remove('active');
        resultsDiv.innerHTML = '';
        foodSearchResults = [];
        return;
    }

    // Show loading state
    resultsDiv.classList.add('active');
    resultsDiv.innerHTML = '<div class="food-search-loading">Searching foods...</div>';

    // Debounce the search
    foodSearchTimeout = setTimeout(async () => {
        try {
            // Add 8-second timeout to prevent long-hanging requests
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 8000);

            const response = await fetch(`${FOOD_SEARCH_ENDPOINT}?query=${encodeURIComponent(query)}`, {
                signal: controller.signal
            });
            clearTimeout(timeoutId);

            const data = await response.json();

            if (!response.ok) {
                throw new Error(data.error || 'Search failed');
            }

            if (data.foods && data.foods.length > 0) {
                foodSearchResults = data.foods;

                resultsDiv.innerHTML = data.foods.map((food, index) => {
                    let macroDisplay;
                    if (food.servingSize && food.caloriesPerServing !== undefined) {
                        macroDisplay = `${escapeHtmlCustomMeal(food.servingSize)}: ${food.caloriesPerServing} cal | ${food.proteinPerServing}g P | ${food.carbsPerServing}g C | ${food.fatPerServing}g F`;
                    } else {
                        macroDisplay = `Per 100g: ${food.caloriesPer100g} cal | ${food.proteinPer100g}g P | ${food.carbsPer100g}g C | ${food.fatPer100g}g F`;
                    }

                    return `
                    <div class="food-search-item" onclick="selectFoodItem(${index})">
                        <div class="food-name">${escapeHtmlCustomMeal(food.name)}${food.brand ? ` <span style="color: #888; font-size: 12px;">(${escapeHtmlCustomMeal(food.brand)})</span>` : ''}</div>
                        <div class="food-macros">${macroDisplay}</div>
                    </div>
                `}).join('');
            } else {
                foodSearchResults = [];
                resultsDiv.innerHTML = '<div class="food-search-empty">No foods found. Try a different search term.</div>';
            }
        } catch (error) {
            console.error('Food search error:', error);
            foodSearchResults = [];
            resultsDiv.innerHTML = '<div class="food-search-empty">Search failed. Please try again.</div>';
        }
    }, 300);
}

function escapeHtmlCustomMeal(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

function selectFoodItem(index) {
    const food = foodSearchResults[index];
    if (!food) return;

    // Build measures array - always include grams as default
    let measures = [{ label: 'g', weight: 1, isGrams: true }];

    // Add measures from API if available
    if (food.measures && food.measures.length > 0) {
        food.measures.forEach(m => {
            if (m.label && m.weight && m.label.toLowerCase() !== 'gram') {
                measures.push({
                    label: m.label,
                    weight: m.weight,
                    isGrams: false
                });
            }
        });
    }

    // Use first non-gram serving as default if available, otherwise 100g
    const defaultMeasure = measures.length > 1 ? measures[1] : measures[0];
    const defaultQty = defaultMeasure.isGrams ? 100 : 1;
    const defaultGrams = defaultMeasure.isGrams ? 100 : defaultMeasure.weight;

    customMealSelectedIngredients.push({
        fdcId: food.fdcId,
        name: food.name,
        quantity: defaultQty,
        quantityGrams: defaultGrams,
        selectedUnit: defaultMeasure.label,
        measures: measures,
        caloriesPer100g: food.caloriesPer100g,
        proteinPer100g: food.proteinPer100g,
        carbsPer100g: food.carbsPer100g,
        fatPer100g: food.fatPer100g
    });

    // Clear search
    document.getElementById('foodSearchInput').value = '';
    document.getElementById('foodSearchResults').classList.remove('active');
    document.getElementById('foodSearchResults').innerHTML = '';

    // Update UI
    renderCustomMealIngredients();
    updateCustomMealTotals();
}

function removeCustomMealIngredient(index) {
    customMealSelectedIngredients.splice(index, 1);
    renderCustomMealIngredients();
    updateCustomMealTotals();
}

function updateCustomMealIngredientQty(index, quantity) {
    const qty = parseFloat(quantity) || 0;
    const ing = customMealSelectedIngredients[index];
    ing.quantity = qty;

    // Recalculate grams based on current unit
    const measure = ing.measures.find(m => m.label === ing.selectedUnit);
    if (measure) {
        ing.quantityGrams = measure.isGrams ? qty : qty * measure.weight;
    }

    updateCustomMealTotals();
}

// Step ingredient quantity up or down with +/- buttons
function stepIngredientQty(index, direction) {
    const ing = customMealSelectedIngredients[index];
    if (!ing) return;

    const isGrams = ing.selectedUnit === 'g';
    const stepAmount = isGrams ? 10 : 0.5; // 10g for grams, 0.5 for servings

    let newQty = ing.quantity + (stepAmount * direction);

    // Minimum value
    if (newQty < 0.1) newQty = 0.1;

    // Round appropriately
    if (isGrams) {
        newQty = Math.round(newQty);
    } else {
        newQty = Math.round(newQty * 10) / 10;
    }

    ing.quantity = newQty;

    // Recalculate grams
    const measure = ing.measures.find(m => m.label === ing.selectedUnit);
    if (measure) {
        ing.quantityGrams = measure.isGrams ? newQty : newQty * measure.weight;
    }

    // Re-render to update the input field and update totals
    renderCustomMealIngredients();
    updateCustomMealTotals();
}

function updateCustomMealIngredientUnit(index, unitLabel) {
    const ing = customMealSelectedIngredients[index];
    const newMeasure = ing.measures.find(m => m.label === unitLabel);

    if (!newMeasure) return;

    // Convert current grams to new unit quantity
    if (newMeasure.isGrams) {
        // Switching to grams - quantity becomes the gram value
        ing.quantity = Math.round(ing.quantityGrams);
    } else {
        // Switching to a serving unit - calculate how many servings
        ing.quantity = Math.round((ing.quantityGrams / newMeasure.weight) * 10) / 10;
        if (ing.quantity < 0.1) ing.quantity = 0.1;
    }

    ing.selectedUnit = unitLabel;

    // Recalculate grams to ensure consistency
    ing.quantityGrams = newMeasure.isGrams ? ing.quantity : ing.quantity * newMeasure.weight;

    renderCustomMealIngredients();
    updateCustomMealTotals();
}

function renderCustomMealIngredients() {
    const listDiv = document.getElementById('ingredientsList');
    const countSpan = document.getElementById('ingredientCount');

    countSpan.textContent = `(${customMealSelectedIngredients.length})`;

    if (customMealSelectedIngredients.length === 0) {
        listDiv.innerHTML = '<div class="no-ingredients">No ingredients added yet</div>';
        return;
    }

    listDiv.innerHTML = customMealSelectedIngredients.map((ing, index) => {
        const displayName = ing.name;
        const gramsInfo = ing.selectedUnit !== 'g' ? ` (${Math.round(ing.quantityGrams)}g)` : '';
        const titleText = `${escapeHtmlCustomMeal(ing.name)}${gramsInfo}`;

        // Build unit dropdown options
        const unitOptions = ing.measures.map(m => {
            const selected = m.label === ing.selectedUnit ? 'selected' : '';
            const weightInfo = m.isGrams ? '' : ` (${m.weight}g)`;
            return `<option value="${escapeHtmlCustomMeal(m.label)}" ${selected}>${escapeHtmlCustomMeal(m.label)}${weightInfo}</option>`;
        }).join('');

        const isGrams = ing.selectedUnit === 'g';
        const stepAmount = isGrams ? 10 : 0.5;

        return `
        <div class="ingredient-item">
            <span class="ingredient-name" title="${titleText}">${escapeHtmlCustomMeal(displayName)}</span>
            <div class="qty-stepper">
                <button class="qty-step-btn" onclick="stepIngredientQty(${index}, -1)" title="Decrease">‚àí</button>
                <input type="number" class="ingredient-qty" value="${ing.quantity}" min="0.1" step="${stepAmount}"
                       onchange="updateCustomMealIngredientQty(${index}, this.value)"
                       oninput="updateCustomMealIngredientQty(${index}, this.value)"
                       onclick="event.stopPropagation()">
                <button class="qty-step-btn" onclick="stepIngredientQty(${index}, 1)" title="Increase">+</button>
            </div>
            <select class="ingredient-unit-select" onchange="updateCustomMealIngredientUnit(${index}, this.value)">
                ${unitOptions}
            </select>
            <button class="ingredient-remove" onclick="removeCustomMealIngredient(${index})" title="Remove">√ó</button>
        </div>
    `}).join('');
}

function updateCustomMealTotals() {
    let totalCal = 0, totalProtein = 0, totalCarbs = 0, totalFat = 0;

    customMealSelectedIngredients.forEach(ing => {
        // Use quantityGrams for accurate calculation
        const grams = ing.quantityGrams || ing.quantity;
        const factor = grams / 100;
        totalCal += ing.caloriesPer100g * factor;
        totalProtein += ing.proteinPer100g * factor;
        totalCarbs += ing.carbsPer100g * factor;
        totalFat += ing.fatPer100g * factor;
    });

    document.getElementById('totalCalories').textContent = Math.round(totalCal);
    document.getElementById('totalProtein').textContent = Math.round(totalProtein) + 'g';
    document.getElementById('totalCarbs').textContent = Math.round(totalCarbs) + 'g';
    document.getElementById('totalFat').textContent = Math.round(totalFat) + 'g';

    // Update meal name placeholder with auto-generated name
    const mealNameInput = document.getElementById('calculatedMealName');
    if (customMealSelectedIngredients.length > 0) {
        const autoName = customMealSelectedIngredients.map(ing => {
            const grams = ing.quantityGrams || ing.quantity;
            const shortName = ing.name.split(',')[0].trim();
            if (ing.selectedUnit === 'g') {
                return `${Math.round(grams)}g ${shortName}`;
            } else {
                return `${ing.quantity} ${ing.selectedUnit} ${shortName}`;
            }
        }).join(', ');
        mealNameInput.placeholder = autoName;
    } else {
        mealNameInput.placeholder = 'Meal name (optional - auto-generated if blank)';
    }

    // Enable/disable create button
    const createBtn = document.getElementById('createCalculatedMealBtn');
    createBtn.disabled = customMealSelectedIngredients.length === 0;
}

async function submitCalculatedMeal() {
    if (customMealSelectedIngredients.length === 0) {
        alert('Please add at least one ingredient');
        return;
    }

    // Calculate totals
    let totalCal = 0, totalProtein = 0, totalCarbs = 0, totalFat = 0;
    const ingredients = [];

    customMealSelectedIngredients.forEach(ing => {
        // Use quantityGrams for accurate calculation
        const grams = ing.quantityGrams || ing.quantity;
        const factor = grams / 100;
        totalCal += ing.caloriesPer100g * factor;
        totalProtein += ing.proteinPer100g * factor;
        totalCarbs += ing.carbsPer100g * factor;
        totalFat += ing.fatPer100g * factor;

        // Format ingredient with unit (e.g., "Chicken (1 Cup)" or "Rice (150g)")
        const unitDisplay = ing.selectedUnit === 'g' ? `${Math.round(grams)}g` : `${ing.quantity} ${ing.selectedUnit}`;
        ingredients.push(`${ing.name} (${unitDisplay})`);
    });

    // Get meal name
    let mealName = document.getElementById('calculatedMealName').value.trim();
    if (!mealName) {
        // Build full meal name with all ingredients and servings
        // e.g., "200g Sirloin Steak, 1 Cup Brown Rice, 2 Tbsp Olive Oil"
        const ingredientParts = customMealSelectedIngredients.map(ing => {
            const grams = ing.quantityGrams || ing.quantity;
            const shortName = ing.name.split(',')[0].trim();
            const displayName = shortName;

            if (ing.selectedUnit === 'g') {
                return `${Math.round(grams)}g ${displayName}`;
            } else {
                return `${ing.quantity} ${ing.selectedUnit} ${displayName}`;
            }
        });

        mealName = ingredientParts.join(', ');
    }

    // Get meal type from original meal
    const originalMeal = lastPlanQuery.currentPlan[customMealDayIndex].plan[customMealMealIndex];
    const mealType = originalMeal.type || 'meal';

    // Save for undo
    const stateKey = `${customMealDayIndex}-${customMealMealIndex}`;
    previousMealStates[stateKey] = JSON.parse(JSON.stringify(originalMeal));
    saveUndoStates(); // Persist to localStorage

    // Get custom instructions from the textarea
    const customInstructions = document.getElementById('calculatedMealInstructions').value.trim() || 'Prepare as desired.';

    // Store full ingredient data for editing later (deep copy to avoid reference issues)
    const ingredientData = JSON.parse(JSON.stringify(customMealSelectedIngredients));

    // Create the custom meal
    const customMealData = {
        type: mealType,
        name: mealName,
        ingredients: ingredients,
        ingredientData: ingredientData,  // Full ingredient objects for editing
        calories: Math.round(totalCal),
        protein: Math.round(totalProtein),
        carbs: Math.round(totalCarbs),
        fat: Math.round(totalFat),
        instructions: customInstructions,
        source: 'Food Database',
        isCustom: true
    };

    // Save to library if checkbox is checked
    const saveForLater = document.getElementById('saveCalculatedForLater').checked;
    if (saveForLater) {
        saveMealToLibrary(customMealData);
    }

    // Update the meal in the plan
    lastPlanQuery.currentPlan[customMealDayIndex].plan[customMealMealIndex] = customMealData;

    // Auto-save if plan already exists in database
    if (lastPlanQuery.planId) {
        saveCoachPlan();
    }

    // Close modal and refresh display
    closeCustomMealModal();
    displayDietPlan(lastPlanQuery.currentPlan);
    console.log('‚úÖ Custom meal created:', customMealData);
}

function submitManualMeal() {
    const mealName = document.getElementById('manualMealName').value.trim();
    const calories = parseInt(document.getElementById('manualCalories').value) || 0;
    const protein = parseInt(document.getElementById('manualProtein').value) || 0;
    const carbs = parseInt(document.getElementById('manualCarbs').value) || 0;
    const fat = parseInt(document.getElementById('manualFat').value) || 0;
    const instructions = document.getElementById('manualInstructions').value.trim() || 'Prepare as desired.';

    if (!mealName) {
        alert('Please enter a meal name');
        return;
    }

    if (calories === 0 && protein === 0 && carbs === 0 && fat === 0) {
        alert('Please enter at least some nutritional information');
        return;
    }

    // Validate macro math (calories should roughly equal P*4 + C*4 + F*9)
    if (calories > 0 && (protein > 0 || carbs > 0 || fat > 0)) {
        const calculatedCal = (protein * 4) + (carbs * 4) + (fat * 9);
        const variance = Math.abs(calories - calculatedCal);
        const variancePercent = (variance / calories) * 100;

        if (variancePercent > 25) {
            const proceed = confirm(
                `‚ö†Ô∏è Macro Math Check\n\n` +
                `Entered: ${calories} calories\n` +
                `Calculated from macros: ${calculatedCal} cal\n` +
                `(Protein√ó4 + Carbs√ó4 + Fat√ó9)\n\n` +
                `Difference: ${variance} cal (${Math.round(variancePercent)}%)\n\n` +
                `This seems off. Continue anyway?`
            );
            if (!proceed) return;
        }
    }

    // Get meal type from original meal
    const originalMeal = lastPlanQuery.currentPlan[customMealDayIndex].plan[customMealMealIndex];
    const mealType = originalMeal.type || 'meal';

    // Save for undo
    const stateKey = `${customMealDayIndex}-${customMealMealIndex}`;
    previousMealStates[stateKey] = JSON.parse(JSON.stringify(originalMeal));
    saveUndoStates(); // Persist to localStorage

    // Create the custom meal
    const customMealData = {
        type: mealType,
        name: mealName,
        ingredients: [mealName],
        calories: calories,
        protein: protein,
        carbs: carbs,
        fat: fat,
        instructions: instructions,
        source: 'Manual Entry',
        isCustom: true
    };

    // Save to library if checkbox is checked
    const saveForLater = document.getElementById('saveManualForLater').checked;
    if (saveForLater) {
        saveMealToLibrary(customMealData);
    }

    // Update the meal in the plan
    lastPlanQuery.currentPlan[customMealDayIndex].plan[customMealMealIndex] = customMealData;

    // Auto-save if plan already exists in database
    if (lastPlanQuery.planId) {
        saveCoachPlan();
    }

    // Close modal and refresh display
    closeCustomMealModal();
    displayDietPlan(lastPlanQuery.currentPlan);
    console.log('‚úÖ Manual meal created:', customMealData);
}

// REGENERATE ENTIRE DAY - Generate all new meals for a specific day
async function regenerateDay(dayIndex) {
    const dayData = lastPlanQuery.currentPlan[dayIndex];
    const dayNumber = dayData.day;

    // Filter out supplements and custom meals - they are preserved
    const mealsToRegenerate = dayData.plan.filter(m => m.type !== 'supplement' && !m.isCustom);
    const supplementItem = dayData.plan.find(m => m.type === 'supplement');
    const customMeals = dayData.plan.filter(m => m.isCustom);

    // If all meals are custom, nothing to regenerate
    if (mealsToRegenerate.length === 0) {
        alert('All meals in this day are custom meals. Nothing to regenerate!');
        return;
    }

    // Calculate targets for meals to regenerate (subtract custom meal macros)
    let customCalories = 0, customProtein = 0, customCarbs = 0, customFat = 0;
    customMeals.forEach(m => {
        customCalories += m.calories || 0;
        customProtein += m.protein || 0;
        customCarbs += m.carbs || 0;
        customFat += m.fat || 0;
    });

    const numMeals = mealsToRegenerate.length;
    const targets = {
        calories: Math.max(0, dayData.targets.calories - customCalories),
        protein: Math.max(0, dayData.targets.protein - customProtein),
        carbs: Math.max(0, dayData.targets.carbs - customCarbs),
        fat: Math.max(0, dayData.targets.fat - customFat)
    };

    if (customMeals.length > 0) {
        console.log(`üìå Preserving ${customMeals.length} custom meal(s), regenerating ${numMeals} meal(s)`);
    }

    // Get meal structure from meals to regenerate (excluding supplements and custom)
    const mealTypes = mealsToRegenerate.map(m => m.type);
    let mealStructure = '';
    let expectedMealTypes = mealTypes;

    if (mealTypes.filter(t => t === 'snack').length === 1) {
        mealStructure = `EXACTLY ${numMeals} items: ${mealTypes.join(', ')}`;
    } else if (mealTypes.filter(t => t === 'snack').length === 2) {
        mealStructure = `EXACTLY ${numMeals} items: ${mealTypes.join(', ')}`;
    } else if (mealTypes.filter(t => t === 'snack').length === 3) {
        mealStructure = `EXACTLY ${numMeals} items: ${mealTypes.join(', ')}`;
    } else {
        mealStructure = `EXACTLY ${numMeals} items: ${mealTypes.join(', ')}`;
    }

    // Show loading state
    displayDietPlan(lastPlanQuery.currentPlan);

    // Find the day section and show loading
    const dayDividers = document.querySelectorAll('.day-divider');
    if (dayDividers[dayIndex]) {
        const daySection = dayDividers[dayIndex].parentElement;
        // Get all meal cards after this day divider until the next day divider
        let currentElement = dayDividers[dayIndex].nextElementSibling; // Skip the totals div
        if (currentElement) currentElement = currentElement.nextElementSibling; // Move to first meal

        while (currentElement && !currentElement.classList.contains('day-divider')) {
            if (currentElement.classList.contains('meal-card')) {
                currentElement.innerHTML = '<div class="loader"><div class="loader-spinner"></div></div><p class="text-center text-sm">Regenerating day...</p>';
            }
            currentElement = currentElement.nextElementSibling;
        }
    }

    // Build list of meals from other days to avoid repetition
    let otherDaysMeals = [];
    lastPlanQuery.currentPlan.forEach((d, idx) => {
        if (idx !== dayIndex) {
            d.plan.forEach(meal => {
                otherDaysMeals.push(meal.name);
            });
        }
    });
    const previousMealsText = otherDaysMeals.length > 0
        ? `\n\nDO NOT repeat these meals from other days: ${otherDaysMeals.join(', ')}`
        : '';

    const dayPrompt = `Create 1-day meal plan for Day ${dayNumber} (REGENERATING - must be COMPLETELY DIFFERENT).
Stats: ${lastPlanQuery.age}yo ${lastPlanQuery.gender}, ${lastPlanQuery.weight}kg, ${lastPlanQuery.height}cm
Goal: ${lastPlanQuery.goal}, Diet: ${lastPlanQuery.preference}
Macro Preference: ${lastPlanQuery.macroPreference}
Avoid: ${lastPlanQuery.allergies}
Disliked Foods: ${lastPlanQuery.dislikedFoods}
Preferred Foods/Cuisines: ${lastPlanQuery.preferredFoods}
Budget: ${lastPlanQuery.budget}
Available Equipment: ${lastPlanQuery.equipmentStr}${previousMealsText}

Daily targets: ${targets.calories} cal, ${targets.protein}g protein, ${targets.carbs}g carbs, ${targets.fat}g fat

CRITICAL TARGET REQUIREMENT:
Your meals MUST add up to approximately these daily targets. This is NOT optional.
- Acceptable variance: ¬±10% for calories, ¬±15% for macros
- Each meal should average ~${Math.round(targets.calories / numMeals)} calories

CRITICAL MEAL STRUCTURE:
Generate ${mealStructure}. DO NOT generate more or fewer items.
The array should have EXACTLY ${numMeals} objects.

Use ONLY foods from USDA database including:
Proteins: Chicken Breast, Salmon, Ground Turkey, Eggs, Shrimp, Tofu, Greek Yogurt
Carbs: Brown Rice, Quinoa, Sweet Potato, Oats, Whole Wheat Bread, Pasta
Fats: Olive Oil, Avocado, Almonds, Peanut Butter
Vegetables: Broccoli, Spinach, Bell Pepper, Asparagus, etc.

CRITICAL: Return ingredients as ARRAY OF STRINGS in natural language format.
Include food name AND amount in parentheses.
DO NOT include calories/protein/carbs/fat - backend will calculate from database.
MEAL NAME FORMAT: Include ALL key ingredient portions inline in parentheses

MEAL TYPE VALUES - Use these EXACT type values in lowercase:
- "breakfast" for the breakfast meal
- "lunch" for the lunch meal
- "dinner" for the dinner meal
- "snack" for ALL snack meals (use "snack" not "snacks" even if there are multiple)

Return ONLY valid JSON array of ${numMeals} meal objects. Each object must have:
{"type":"meal_type","name":"Meal Name (portions)","ingredients":["Item (amount)",...],"instructions":"Brief cooking steps"}

NO markdown, NO backticks, NO extra text. ONLY the JSON array.`;

    try {
        const result = await callGemini(dayPrompt, true, targets, expectedMealTypes, numMeals);

        if (result.error) {
            alert('Error regenerating day: ' + result.error);
            displayDietPlan(lastPlanQuery.currentPlan);
            return;
        }

        // Result should be an array of meals
        let newMeals = Array.isArray(result) ? result : [result];

        // Validate we got the right number of meals
        if (newMeals.length !== numMeals) {
            console.warn(`Expected ${numMeals} meals, got ${newMeals.length}. Using what we got.`);
        }

        // Enforce correct meal types based on expected structure
        console.log('üîß Enforcing correct meal types for regenerated day...');
        for (let i = 0; i < newMeals.length && i < expectedMealTypes.length; i++) {
            const expectedType = expectedMealTypes[i] || 'meal';
            const meal = newMeals[i];

            // Fix missing or incorrect type
            if (!meal.type || meal.type === 'meal' || meal.type === 'snacks') {
                console.log(`   Fixed meal ${i + 1} type: "${meal.type || 'undefined'}" ‚Üí "${expectedType}"`);
                meal.type = expectedType;
            }
        }

        // Add back custom meals (preserved)
        if (customMeals.length > 0) {
            newMeals = [...newMeals, ...customMeals];
            console.log(`üìå Restored ${customMeals.length} custom meal(s) to Day ${dayNumber}`);
        }

        // Add back the supplement if there was one
        if (supplementItem) {
            newMeals.push(supplementItem);
            console.log(`‚úÖ Re-added supplement to Day ${dayNumber}`);
        }

        // Update the day's meals
        lastPlanQuery.currentPlan[dayIndex].plan = newMeals;

        // Auto-save if plan already exists in database
        if (lastPlanQuery.planId) {
            saveCoachPlan();
        }

        // Refresh the display
        displayDietPlan(lastPlanQuery.currentPlan);

        console.log(`‚úÖ Day ${dayNumber} regenerated successfully`);

    } catch (error) {
        console.error('Error regenerating day:', error);
        alert('Error regenerating day. Please try again.');
        displayDietPlan(lastPlanQuery.currentPlan);
    }
}

// GROCERY LIST AGGREGATION

// Helper function to parse fractions and mixed numbers
function parseFraction(str) {
    // Handle mixed numbers like "1 1/2" or "2 3/4"
    const mixedMatch = str.match(/(\d+)\s+(\d+)\/(\d+)/);
    if (mixedMatch) {
        const whole = parseInt(mixedMatch[1]);
        const numerator = parseInt(mixedMatch[2]);
        const denominator = parseInt(mixedMatch[3]);
        return whole + (numerator / denominator);
    }

    // Handle simple fractions like "1/2" or "3/4"
    const fractionMatch = str.match(/(\d+)\/(\d+)/);
    if (fractionMatch) {
        const numerator = parseInt(fractionMatch[1]);
        const denominator = parseInt(fractionMatch[2]);
        return numerator / denominator;
    }

    // Handle decimals like "1.5" or whole numbers like "2"
    return parseFloat(str) || 0;
}

function parseIngredient(ingredientStr) {
    // NEW FORMAT: "Food Name (amount)" - e.g., "Chicken Breast (200g)" or "Eggs (2 whole)"
    // Pattern 1: "Food Name (quantity unit descriptor)" - handles formats like:
    //   - "Chicken Breast (200g)"
    //   - "Olive Oil (1 tbsp)"
    //   - "Quinoa (200g cooked)"
    //   - "Oats (80g dry)"
    const parenthesesPattern = /^(.+?)\s*\(([\d\s\/\.]+)\s*(oz|ounces?|pounds?|lbs?|g|grams?|kg|cups?|tbsp|tsp|teaspoons?|tablespoons?|pieces?|medium|large|small|whole|slices?|scoops?|servings?|ml|l|liters?|bars?|bottles?|sticks?|cans?|packets?|pouches?|containers?|tortillas?)?(?:\s+(dry|cooked|raw|uncooked))?\)$/i;
    const parenthesesMatch = ingredientStr.match(parenthesesPattern);

    if (parenthesesMatch) {
        const name = parenthesesMatch[1].trim();
        const quantityStr = parenthesesMatch[2].trim();
        const quantity = parseFraction(quantityStr);
        let unit = (parenthesesMatch[3] || 'unit').toLowerCase();
        const descriptor = parenthesesMatch[4] ? parenthesesMatch[4].toLowerCase() : null;

        // If descriptor was captured as the unit (old format fallback), treat as 'unit'
        const filteredUnit = ['dry', 'cooked', 'whole', 'raw', 'uncooked'].includes(unit) ? 'unit' : unit;

        return {
            quantity: quantity,
            unit: filteredUnit,
            name: name.toLowerCase().trim()
        };
    }

    // Pattern 2: Handle "dry" or "cooked" appearing as standalone unit (fallback for edge cases)
    // e.g., "Quinoa (200 cooked)" where no unit like 'g' is present
    const descriptorOnlyPattern = /^(.+?)\s*\(([\d\s\/\.]+)\s*(dry|cooked|raw|uncooked)\)$/i;
    const descriptorMatch = ingredientStr.match(descriptorOnlyPattern);

    if (descriptorMatch) {
        const name = descriptorMatch[1].trim();
        const quantityStr = descriptorMatch[2].trim();
        const quantity = parseFraction(quantityStr);
        // Assume grams when descriptor is used without unit
        return {
            quantity: quantity,
            unit: 'g',
            name: name.toLowerCase().trim()
        };
    }

    // OLD FORMAT FALLBACK: "quantity unit food" - e.g., "200g chicken breast" or "2 eggs"
    const patterns = [
        // Pattern 1: Fractions or decimals with units - e.g., "1/4 cup" or "1 1/2 cups" or "2.5 tbsp"
        /([\d\s\/\.]+)\s*(oz|ounces?|pounds?|lbs?|g|grams?|kg|cups?|tbsp|tsp|teaspoons?|tablespoons?|pieces?|medium|large|small|scoops?|servings?|bars?|bottles?|sticks?|cans?|packets?|pouches?|containers?|tortillas?)\s+(.+)/i,
        // Pattern 2: Just number with rest of string - e.g., "2 bananas"
        /([\d\s\/\.]+)\s+(.+)/i
    ];

    for (const pattern of patterns) {
        const match = ingredientStr.match(pattern);
        if (match) {
            // Parse the quantity (handles fractions, mixed numbers, decimals)
            const quantityStr = match[1].trim();
            const quantity = parseFraction(quantityStr);

            return {
                quantity: quantity,
                unit: (match[2] || 'unit').toLowerCase(),
                name: (match[3] || match[2] || ingredientStr).toLowerCase().trim()
            };
        }
    }
    return { quantity: 1, unit: 'unit', name: ingredientStr.toLowerCase().trim() };
}

function normalizeUnit(quantity, unit) {
    // Normalize unit names and keep quantities in their original units
    // Group similar units together for aggregation
    const unitNormalization = {
        // Weight units - keep in grams
        'g': 'g',
        'gram': 'g',
        'grams': 'g',
        'kg': 'g', // Convert kg to g for aggregation
        'oz': 'oz',
        'ounce': 'oz',
        'ounces': 'oz',
        'lb': 'oz', // Convert lbs to oz for aggregation
        'lbs': 'oz',
        'pound': 'oz',
        'pounds': 'oz',

        // Volume units - keep separate
        'cup': 'cup',
        'cups': 'cup',
        'tbsp': 'tbsp',
        'tablespoon': 'tbsp',
        'tablespoons': 'tbsp',
        'tsp': 'tsp',
        'teaspoon': 'tsp',
        'teaspoons': 'tsp',
        'ml': 'ml',
        'milliliter': 'ml',
        'milliliters': 'ml',
        'l': 'l',
        'liter': 'l',
        'liters': 'l',

        // Count units
        'piece': 'unit',
        'pieces': 'unit',
        'medium': 'medium',
        'large': 'large',
        'small': 'small',
        'scoop': 'scoop',
        'scoops': 'scoop',
        'serving': 'serving',
        'servings': 'serving',
        'unit': 'unit'
    };

    const normalizedUnit = unitNormalization[unit] || unit;
    let normalizedQuantity = quantity;

    // Convert kg to g (1 kg = 1000 g)
    if (unit === 'kg') {
        normalizedQuantity = quantity * 1000;
    }
    // Convert lbs to oz (1 lb = 16 oz)
    else if (unit === 'lb' || unit === 'lbs' || unit === 'pound' || unit === 'pounds') {
        normalizedQuantity = quantity * 16;
    }
    // Convert tablespoons to teaspoons if needed for consistency (optional)
    // For now, keep them separate for easier reading

    return {
        quantity: normalizedQuantity,
        unit: normalizedUnit
    };
}

function aggregateGroceryList(multiDayPlan) {
    const aggregated = {};

    multiDayPlan.forEach(dayData => {
        dayData.plan.forEach(meal => {
            if (!meal.ingredients || !Array.isArray(meal.ingredients)) return;

            meal.ingredients.forEach(ingredient => {
                // Handle both old string format and new object format
                let ingredientStr;
                if (typeof ingredient === 'string') {
                    // Old format: "3 eggs"
                    ingredientStr = ingredient;
                } else if (ingredient.food && ingredient.amount) {
                    // New format: {food: "egg", amount: "3"}
                    ingredientStr = `${ingredient.amount} ${ingredient.food}`;
                } else {
                    console.warn('Unknown ingredient format:', ingredient);
                    return;
                }

                const parsed = parseIngredient(ingredientStr);
                const normalized = normalizeUnit(parsed.quantity, parsed.unit);

                const key = `${parsed.name}|${normalized.unit}`;
                if (aggregated[key]) {
                    aggregated[key].quantity += normalized.quantity;
                } else {
                    aggregated[key] = {
                        name: parsed.name,
                        quantity: normalized.quantity,
                        unit: normalized.unit
                    };
                }
            });
        });
    });

    return Object.values(aggregated).sort((a, b) => a.name.localeCompare(b.name));
}

// Format quantity with fractions for better readability
function formatQuantity(quantity) {
    // Round to nearest 0.125 for cleaner fractions
    const rounded = Math.round(quantity * 8) / 8;

    const whole = Math.floor(rounded);
    const decimal = rounded - whole;

    // Convert common decimals to fractions
    const fractions = {
        0: '',
        0.125: '1/8',
        0.25: '1/4',
        0.333: '1/3',
        0.375: '3/8',
        0.5: '1/2',
        0.625: '5/8',
        0.666: '2/3',
        0.75: '3/4',
        0.875: '7/8'
    };

    // Find closest fraction
    let closestDecimal = 0;
    let minDiff = 1;
    for (const dec in fractions) {
        const diff = Math.abs(decimal - parseFloat(dec));
        if (diff < minDiff) {
            minDiff = diff;
            closestDecimal = dec;
        }
    }

    const fraction = fractions[closestDecimal];

    if (whole === 0 && fraction) {
        return fraction;
    } else if (whole > 0 && fraction) {
        return `${whole} ${fraction}`;
    } else if (whole > 0) {
        return whole.toString();
    } else {
        // If no clean fraction match, show decimal
        return quantity.toFixed(1);
    }
}

// Generate a summary of the meal plan for client display
function generatePlanSummary(planData) {
    if (!planData || !planData.currentPlan || !Array.isArray(planData.currentPlan)) {
        return null;
    }

    // Collect all meal names
    const allMealNames = [];
    planData.currentPlan.forEach(dayData => {
        if (dayData.plan && Array.isArray(dayData.plan)) {
            dayData.plan.forEach(meal => {
                if (meal.name) {
                    allMealNames.push(meal.name.toLowerCase());
                }
            });
        }
    });

    if (allMealNames.length === 0) return null;

    const mealText = allMealNames.join(' ');

    // Detect protein sources
    const proteinSources = [];
    const proteinKeywords = {
        'chicken': 'chicken',
        'beef': 'beef',
        'steak': 'beef',
        'salmon': 'salmon',
        'fish': 'fish',
        'tuna': 'tuna',
        'shrimp': 'shrimp',
        'turkey': 'turkey',
        'pork': 'pork',
        'tofu': 'tofu',
        'tempeh': 'tempeh',
        'eggs': 'eggs',
        'egg': 'eggs',
        'greek yogurt': 'Greek yogurt',
        'cottage cheese': 'cottage cheese',
        'beans': 'beans',
        'lentils': 'lentils',
        'quinoa': 'quinoa'
    };

    for (const [keyword, label] of Object.entries(proteinKeywords)) {
        if (mealText.includes(keyword) && !proteinSources.includes(label)) {
            proteinSources.push(label);
        }
    }

    // Detect carb sources
    const carbSources = [];
    const carbKeywords = {
        'rice': 'rice',
        'oatmeal': 'oatmeal',
        'oats': 'oats',
        'sweet potato': 'sweet potatoes',
        'potato': 'potatoes',
        'pasta': 'pasta',
        'bread': 'bread',
        'quinoa': 'quinoa',
        'whole grain': 'whole grains'
    };

    for (const [keyword, label] of Object.entries(carbKeywords)) {
        if (mealText.includes(keyword) && !carbSources.includes(label)) {
            carbSources.push(label);
        }
    }

    // Detect vegetables
    const veggies = [];
    const veggieKeywords = {
        'broccoli': 'broccoli',
        'spinach': 'spinach',
        'salad': 'salads',
        'vegetables': 'vegetables',
        'asparagus': 'asparagus',
        'green beans': 'green beans',
        'kale': 'kale',
        'zucchini': 'zucchini',
        'peppers': 'peppers',
        'carrots': 'carrots',
        'avocado': 'avocado'
    };

    for (const [keyword, label] of Object.entries(veggieKeywords)) {
        if (mealText.includes(keyword) && !veggies.includes(label)) {
            veggies.push(label);
        }
    }

    // Build summary based on macro targets
    const targets = planData.currentPlan[0]?.targets || {};
    let planStyle = '';

    if (targets.protein && targets.calories) {
        const proteinRatio = (targets.protein * 4) / targets.calories;
        if (proteinRatio > 0.35) {
            planStyle = 'High-protein';
        } else if (proteinRatio > 0.25) {
            planStyle = 'Protein-focused';
        }
    }

    if (targets.carbs && targets.calories) {
        const carbRatio = (targets.carbs * 4) / targets.calories;
        if (carbRatio < 0.25) {
            planStyle = planStyle ? planStyle + ', low-carb' : 'Low-carb';
        }
    }

    // Build the summary string
    let summary = '';

    if (planStyle) {
        summary = planStyle + ' meals';
    } else {
        summary = 'Balanced meals';
    }

    if (proteinSources.length > 0) {
        const topProteins = proteinSources.slice(0, 3);
        summary += ' featuring ' + topProteins.join(', ');
    }

    if (veggies.length > 0 && veggies.length <= 2) {
        summary += ' with ' + veggies.join(' and ');
    } else if (veggies.length > 2) {
        summary += ' with fresh vegetables';
    }

    if (carbSources.length > 0 && carbSources.length <= 2) {
        summary += ' and ' + carbSources.join(', ');
    }

    // Truncate if too long
    if (summary.length > 120) {
        summary = summary.substring(0, 117) + '...';
    }

    return summary;
}

function showGroceryList() {
    if (!lastPlanQuery.currentPlan) {
        alert('No plan available');
        return;
    }

    const groceryList = aggregateGroceryList(lastPlanQuery.currentPlan);

    let listHTML = `
        <div class="card mt-4">
            <h3 class="text-2xl font-bold mb-4">üìù Grocery List</h3>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-2">`;

    groceryList.forEach(item => {
        const formattedQty = formatQuantity(item.quantity);
        listHTML += `<div class="p-2 bg-gray-50 rounded">
            <span class="font-semibold">${formattedQty} ${item.unit}</span> ${item.name}
        </div>`;
    });

    listHTML += `</div>
        <button data-action="close-grocery-list" class="btn btn-secondary w-full mt-4">Close</button>
    </div>`;

    const resultDiv = document.getElementById('diet-plan-result');
    resultDiv.innerHTML += listHTML;
    resultDiv.lastElementChild.scrollIntoView({ behavior: 'smooth' });
}

// PDF EXPORT
function downloadPlanAsPDF() {
    const { jsPDF } = window.jspdf;
    if (!lastPlanQuery.currentPlan) {
        alert('No plan to download');
        return;
    }

    const pdf = new jsPDF();
    const margin = 15;
    const pageWidth = pdf.internal.pageSize.getWidth();
    const maxWidth = pageWidth - (margin * 2);
    let y = 20;

    // Title
    pdf.setFontSize(24);
    pdf.setTextColor(102, 126, 234);
    pdf.text('Personalized Meal Plan', margin, y);
    y += 10;

    // Client Name
    if (lastPlanQuery.clientName) {
        pdf.setFontSize(16);
        pdf.setTextColor(0, 0, 0);
        pdf.text(`For: ${lastPlanQuery.clientName}`, margin, y);
        y += 12;
    }

    // Daily Nutrition Summary - use original targets
    const displayTargets = lastPlanQuery.originalTargets || {
        calories: lastPlanQuery.calories,
        protein: lastPlanQuery.protein,
        carbs: lastPlanQuery.carbs,
        fat: lastPlanQuery.fat
    };
    pdf.setFontSize(14);
    pdf.setTextColor(0, 0, 0);
    pdf.text('Daily Nutrition Targets:', margin, y);
    y += 8;
    pdf.setFontSize(11);
    pdf.text(`Calories: ${displayTargets.calories} | Protein: ${displayTargets.protein}g | Carbs: ${displayTargets.carbs}g | Fat: ${displayTargets.fat}g`, margin, y);
    y += 8;
    pdf.text(`Macro Split: ${lastPlanQuery.macroPreference}`, margin, y);
    y += 15;

    // Meal Plans by Day
    lastPlanQuery.currentPlan.forEach(dayData => {
        if (y > 250) {
            pdf.addPage();
            y = 20;
        }

        // Day Header
        pdf.setFontSize(18);
        pdf.setTextColor(118, 75, 162);
        pdf.text(`Day ${dayData.day}`, margin, y);
        y += 10;

        dayData.plan.forEach(meal => {
            if (y > 230) {
                pdf.addPage();
                y = 20;
            }

            // Meal Name
            pdf.setFontSize(14);
            pdf.setTextColor(102, 126, 234);
            const mealNameLines = pdf.splitTextToSize(`${meal.type.toUpperCase()}: ${meal.name}`, maxWidth);
            pdf.text(mealNameLines, margin, y);
            y += mealNameLines.length * 6;

            // Macros
            pdf.setFontSize(10);
            pdf.setTextColor(100, 100, 100);
            pdf.text(`${meal.calories} cal | ${meal.protein}g protein | ${meal.carbs}g carbs | ${meal.fat}g fat`, margin + 5, y);
            y += 7;

            // Ingredients
            if (meal.ingredients && Array.isArray(meal.ingredients) && meal.ingredients.length > 0) {
                pdf.setFontSize(11);
                pdf.setTextColor(0, 0, 0);
                pdf.setFont(undefined, 'bold');
                pdf.text('Ingredients:', margin + 5, y);
                y += 5;
                pdf.setFont(undefined, 'normal');
                pdf.setFontSize(9);
                meal.ingredients.forEach(ingredient => {
                    if (y > 270) {
                        pdf.addPage();
                        y = 20;
                    }
                    // Handle both string and object ingredient formats
                    const ingredientText = typeof ingredient === 'string'
                        ? ingredient
                        : `${ingredient.amount} ${ingredient.food}`;
                    const ingredientLines = pdf.splitTextToSize(`‚Ä¢ ${ingredientText}`, maxWidth - 10);
                    pdf.text(ingredientLines, margin + 10, y);
                    y += ingredientLines.length * 4;
                });
                y += 3;
            }

            // Full Cooking Instructions
            if (meal.instructions) {
                if (y > 260) {
                    pdf.addPage();
                    y = 20;
                }
                pdf.setFontSize(11);
                pdf.setFont(undefined, 'bold');
                pdf.text('Cooking Instructions:', margin + 5, y);
                y += 5;
                pdf.setFont(undefined, 'normal');
                pdf.setFontSize(9);
                const instructionLines = pdf.splitTextToSize(meal.instructions, maxWidth - 10);
                pdf.text(instructionLines, margin + 10, y);
                y += instructionLines.length * 4 + 8;
            }

            y += 5; // Space between meals
        });
        y += 10; // Space between days
    });

    // Grocery List
    pdf.addPage();
    y = 20;
    pdf.setFontSize(20);
    pdf.setTextColor(102, 126, 234);
    pdf.text('Shopping List', margin, y);
    y += 12;

    const groceryList = aggregateGroceryList(lastPlanQuery.currentPlan);
    pdf.setFontSize(10);
    pdf.setTextColor(0, 0, 0);
    groceryList.forEach(item => {
        if (y > 270) {
            pdf.addPage();
            y = 20;
        }
        const formattedQty = formatQuantity(item.quantity);
        const itemText = `- ${formattedQty} ${item.unit} ${item.name}`;
        pdf.text(itemText, margin, y);
        y += 6;
    });

    // Footer on last page
    y += 10;
    if (y > 260) {
        pdf.addPage();
        y = 20;
    }
    pdf.setFontSize(8);
    pdf.setTextColor(150, 150, 150);
    pdf.text(`Generated on ${new Date().toLocaleDateString()}`, margin, y);

    pdf.save('meal-plan.pdf');
}

// SHARE PLAN FUNCTIONALITY
async function sharePlan() {
    if (!lastPlanQuery.currentPlan) {
        alert('No plan to share. Please generate a plan first.');
        return;
    }

    // Prepare the plan data for sharing
    const shareData = {
        clientName: lastPlanQuery.clientName || 'Client',
        nutrition: {
            calories: lastPlanQuery.calories,
            protein: lastPlanQuery.protein,
            carbs: lastPlanQuery.carbs,
            fat: lastPlanQuery.fat
        },
        meals: [],
        preferences: {
            goal: document.getElementById('dp_goal')?.value || 'maintain',
            dietType: lastPlanQuery.preference || 'omnivore',
            allergies: lastPlanQuery.allergies || 'none',
            mealsPerDay: lastPlanQuery.currentPlan.length > 0 ? lastPlanQuery.currentPlan[0].plan.length : 3
        },
        generatedAt: new Date().toISOString()
    };

    // Flatten multi-day plan into single meals array
    lastPlanQuery.currentPlan.forEach(dayData => {
        dayData.plan.forEach(meal => {
            shareData.meals.push(meal);
        });
    });

    // Show modal with loading state
    const modal = document.getElementById('share-modal');
    const linkText = document.getElementById('share-link-text');
    linkText.textContent = 'Generating share link...';
    modal.classList.remove('hidden');

    try {
        console.log('Saving plan for sharing...');

        // Prepare request body
        const requestBody = { planData: shareData };

        // If this plan was saved to history (has planId), include it
        // This links the shared plan to the coach plan for cascade deletion
        if (lastPlanQuery.planId) {
            requestBody.coachPlanId = lastPlanQuery.planId;
            console.log('Linking shared plan to coach plan:', lastPlanQuery.planId);
        }

        const response = await fetch(SAVE_PLAN_ENDPOINT, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            throw new Error('Failed to generate share link');
        }

        const data = await response.json();
        currentShareUrl = data.shareUrl;

        console.log('Share link generated:', currentShareUrl);

        linkText.textContent = currentShareUrl;

    } catch (error) {
        console.error('Error generating share link:', error);
        linkText.textContent = 'Failed to generate link. Please try again.';
        alert('Failed to generate share link. Please try again.');
    }
}

async function copyShareLink() {
    if (!currentShareUrl) {
        alert('No share link available');
        return;
    }

    try {
        await navigator.clipboard.writeText(currentShareUrl);

        // Update button text temporarily
        const copyBtn = event.target;
        const originalText = copyBtn.textContent;
        copyBtn.textContent = '‚úÖ Copied!';
        copyBtn.style.background = '#28a745';

        setTimeout(() => {
            copyBtn.textContent = originalText;
            copyBtn.style.background = '';
        }, 2000);

    } catch (error) {
        console.error('Copy error:', error);
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = currentShareUrl;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        alert('Link copied to clipboard!');
    }
}

function closeShareModal() {
    const modal = document.getElementById('share-modal');
    modal.classList.add('hidden');
}

// MEAL PREP GUIDE GENERATOR
async function showMealPrepGuide() {
    const modal = document.getElementById('meal-prep-modal');
    const content = document.getElementById('meal-prep-content');

    // Show modal with loading state
    modal.classList.remove('hidden');
    content.innerHTML = `
        <div class="flex items-center justify-center py-12">
            <div class="loader"><div class="loader-spinner"></div></div>
            <p class="ml-4 text-gray-600">Generating your comprehensive meal prep guide...</p>
        </div>
    `;

    try {
        // Collect all meals from the plan
        const allMeals = [];
        if (lastPlanQuery.currentPlan && Array.isArray(lastPlanQuery.currentPlan)) {
            lastPlanQuery.currentPlan.forEach(dayData => {
                if (dayData.plan && Array.isArray(dayData.plan)) {
                    dayData.plan.forEach(meal => {
                        allMeals.push({
                            day: dayData.day,
                            type: meal.type,
                            name: meal.name,
                            calories: meal.calories,
                            protein: meal.protein,
                            carbs: meal.carbs,
                            fat: meal.fat
                        });
                    });
                }
            });
        }

        if (allMeals.length === 0) {
            content.innerHTML = '<p class="text-center text-gray-600">No meal plan found. Please generate a meal plan first.</p>';
            return;
        }

        const numDays = lastPlanQuery.currentPlan.length;
        const mealsList = allMeals.map(m => `Day ${m.day} ${m.type}: ${m.name}`).join('\n');

        const prompt = `You are a professional meal prep consultant. Create a comprehensive meal prep guide for the following ${numDays}-day meal plan:

${mealsList}

Create a detailed, actionable meal prep guide with the following sections:

## üìù Shopping List
Group all ingredients by category (Proteins, Vegetables, Fruits, Grains/Carbs, Dairy, Pantry Items, etc.)
Combine quantities where meals share ingredients
Be specific with quantities and measurements

## ‚è∞ Meal Prep Timeline
Provide a day-by-day prep schedule (e.g., "Sunday: Cook all proteins", "Monday: Prep vegetables")
Include which meals to batch cook together
Suggest which components can be prepared ahead
Include estimated time for each prep session

## ü•° Storage Instructions
For EACH meal, specify:
- How long it keeps in the refrigerator (be specific: 3-4 days, 5-6 days, etc.)
- Whether it can be frozen and for how long
- Best storage containers (airtight, glass, etc.)
- Any special storage notes

## üî• Reheating Instructions
For EACH meal type (not every individual meal, but each unique recipe), provide:
- Microwave instructions (time and power level)
- Oven/stovetop instructions if better quality
- Tips to maintain texture and flavor

## üí° Time-Saving Tips
- Batch cooking strategies (cook all chicken at once, prep all vegetables together, etc.)
- Make-ahead components (cook rice/grains in bulk, pre-chop vegetables, etc.)
- Kitchen shortcuts and efficiency tips
- Which meals taste better fresh vs reheated

Format the response in clean, readable markdown with clear headings and bullet points.
Be specific, practical, and actionable. Focus on making meal prep as easy and efficient as possible.`;

        const response = await callGemini(prompt, false);

        // Format the response nicely
        content.innerHTML = `
            <div class="prose prose-sm max-w-none">
                ${formatMarkdown(response)}
            </div>
        `;

    } catch (error) {
        console.error('Error generating meal prep guide:', error);
        content.innerHTML = `
            <div class="text-center text-red-600 py-8">
                <p class="font-semibold">Error generating meal prep guide</p>
                <p class="text-sm mt-2">${error.message}</p>
            </div>
        `;
    }
}

// Simple markdown formatter
function formatMarkdown(text) {
    // Handle non-string inputs
    if (typeof text !== 'string') {
        console.warn('formatMarkdown received non-string input:', typeof text);
        text = String(text);
    }

    return text
        .replace(/^## (.+)$/gm, '<h2 class="text-2xl font-bold mt-6 mb-4 text-gray-800">$1</h2>')
        .replace(/^### (.+)$/gm, '<h3 class="text-xl font-semibold mt-4 mb-3 text-gray-700">$1</h3>')
        .replace(/^\* (.+)$/gm, '<li class="ml-4">$1</li>')
        .replace(/^- (.+)$/gm, '<li class="ml-4">$1</li>')
        .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
        .replace(/\n\n/g, '</p><p class="mb-3">')
        .replace(/^(?!<[hl]|<li)/gm, '<p class="mb-3">')
        .replace(/<\/li>\n<li/g, '</li><li');
}

// UNIT SYSTEM STATE
let currentUnitSystem = 'imperial';

function toggleUnitSystem(system) {
    currentUnitSystem = system;
    document.getElementById('unit-imperial').className = system === 'imperial' ? 'btn btn-primary text-sm py-1 px-3' : 'btn btn-secondary text-sm py-1 px-3';
    document.getElementById('unit-metric').className = system === 'metric' ? 'btn btn-primary text-sm py-1 px-3' : 'btn btn-secondary text-sm py-1 px-3';

    // Update labels
    const weightLabel = system === 'imperial' ? 'Weight (lbs)' : 'Weight (kg)';
    const heightLabel1 = system === 'imperial' ? 'Height (ft)' : 'Height (cm)';
    const heightLabel2 = system === 'imperial' ? 'Height (in)' : '';

    document.querySelector('label[for="dp_weight"]').textContent = weightLabel;
    document.querySelector('label[for="dp_height_ft"]').textContent = heightLabel1;
    document.querySelector('label[for="dp_height_in"]').textContent = heightLabel2;
    document.getElementById('dp_height_in').style.display = system === 'imperial' ? 'block' : 'none';
}

// EVENT HANDLERS
document.addEventListener('click', function(event) {
    const actionTarget = event.target.closest('[data-action]');
    if (!actionTarget) return;

    const actions = {
        'generate-plan': generateDietPlan,
        'close-modal': () => document.getElementById('recipe-modal').classList.add('hidden'),
        'get-recipe': () => {
            const target = event.target.closest('[data-meal-name]');
            if (!target) {
                console.error('Recipe button clicked but no data-meal-name attribute found');
                return;
            }
            const mealName = target.dataset.mealName;
            if (mealName) {
                console.log('Opening recipe for:', mealName);
                getAIRecipe(mealName);
            } else {
                console.error('Recipe button has data-meal-name attribute but no value');
            }
        },
        'change-meal': () => {
            const target = event.target.closest('[data-day-index]');
            const dayIndex = parseInt(target.dataset.dayIndex);
            const mealIndex = parseInt(target.dataset.mealIndex);
            changeMeal(dayIndex, mealIndex);
        },
        'revise-meal': () => {
            const target = event.target.closest('[data-day-index]');
            const dayIndex = parseInt(target.dataset.dayIndex);
            const mealIndex = parseInt(target.dataset.mealIndex);
            reviseMeal(dayIndex, mealIndex);
        },
        'custom-meal': () => {
            const target = event.target.closest('[data-day-index]');
            const dayIndex = parseInt(target.dataset.dayIndex);
            const mealIndex = parseInt(target.dataset.mealIndex);
            customMeal(dayIndex, mealIndex);
        },
        'edit-custom-meal': () => {
            const target = event.target.closest('[data-day-index]');
            const dayIndex = parseInt(target.dataset.dayIndex);
            const mealIndex = parseInt(target.dataset.mealIndex);
            editCustomMeal(dayIndex, mealIndex);
        },
        'undo-meal': () => {
            const target = event.target.closest('[data-day-index]');
            const dayIndex = parseInt(target.dataset.dayIndex);
            const mealIndex = parseInt(target.dataset.mealIndex);
            undoMeal(dayIndex, mealIndex);
        },
        'regenerate-day': () => {
            const target = event.target.closest('[data-day-index]');
            const dayIndex = parseInt(target.dataset.dayIndex);
            regenerateDay(dayIndex);
        },
        'show-grocery-list': showGroceryList,
        'close-grocery-list': () => {
            event.target.closest('.card').remove();
        },
        'show-meal-prep-guide': showMealPrepGuide,
        'close-meal-prep-modal': () => document.getElementById('meal-prep-modal').classList.add('hidden'),
        'download-pdf': downloadPlanAsPDF,
        'share-plan': sharePlan,
        'copy-share-link': copyShareLink,
        'close-share-modal': closeShareModal,
        'save-coach-notes': saveCoachNotes,
        'save-meal-note': () => {
            const target = event.target.closest('[data-day-index]');
            const dayIndex = parseInt(target.dataset.dayIndex);
            const mealIndex = parseInt(target.dataset.mealIndex);
            saveMealNote(dayIndex, mealIndex);
        },
        'submit-to-client': publishPlanToClient,
        'save-as-template': saveAsTemplate,
        'save-plan': savePlanChanges
    };

    if (actions[actionTarget.dataset.action]) actions[actionTarget.dataset.action]();
});

// Unit system toggle
document.getElementById('unit-imperial').addEventListener('click', () => toggleUnitSystem('imperial'));
document.getElementById('unit-metric').addEventListener('click', () => toggleUnitSystem('metric'));

// Custom targets checkbox toggle
document.getElementById('dp_custom_targets').addEventListener('change', function() {
    const fields = document.getElementById('custom-targets-fields');
    if (this.checked) {
        fields.classList.remove('hidden');
        updateMacroFromPercentages(); // Calculate on open
    } else {
        fields.classList.add('hidden');
    }
});

// Percentage-based macro calculator
let lastEditedMacro = null; // Track which macro was edited last for auto-fill

function updateMacroFromPercentages() {
    const calories = parseInt(document.getElementById('dp_custom_calories').value) || 0;
    const proteinPct = parseFloat(document.getElementById('dp_protein_pct').value) || 0;
    const carbsPct = parseFloat(document.getElementById('dp_carbs_pct').value) || 0;
    const fatPct = parseFloat(document.getElementById('dp_fat_pct').value) || 0;

    // Calculate total percentage
    const totalPct = proteinPct + carbsPct + fatPct;
    document.getElementById('total-pct').textContent = totalPct;

    // Update progress bar
    const progressBar = document.getElementById('pct-progress-bar');
    progressBar.style.width = Math.min(totalPct, 100) + '%';

    // Update status
    const pctStatus = document.getElementById('pct-status');
    if (totalPct === 100) {
        pctStatus.textContent = '‚úÖ Perfect! 100%';
        pctStatus.className = 'text-sm font-bold text-green-600';
        progressBar.style.background = 'linear-gradient(to right, #3b82f6, #22c55e, #eab308)';
    } else if (totalPct > 100) {
        pctStatus.textContent = `‚ö†Ô∏è Over by ${totalPct - 100}%`;
        pctStatus.className = 'text-sm font-bold text-red-600';
        progressBar.style.background = '#ef4444';
    } else if (totalPct > 0) {
        pctStatus.textContent = `${100 - totalPct}% remaining`;
        pctStatus.className = 'text-sm font-bold text-amber-600';
        progressBar.style.background = 'linear-gradient(to right, #3b82f6, #22c55e, #eab308)';
    } else {
        pctStatus.textContent = 'Enter percentages';
        pctStatus.className = 'text-sm text-gray-500';
    }

    // Calculate grams from percentages
    if (calories > 0) {
        const proteinCals = (calories * proteinPct) / 100;
        const carbsCals = (calories * carbsPct) / 100;
        const fatCals = (calories * fatPct) / 100;

        const proteinGrams = Math.round(proteinCals / 4);
        const carbsGrams = Math.round(carbsCals / 4);
        const fatGrams = Math.round(fatCals / 9);

        // Update displays
        document.getElementById('protein-grams-display').textContent = proteinGrams + 'g';
        document.getElementById('protein-cals-display').textContent = Math.round(proteinCals);
        document.getElementById('carbs-grams-display').textContent = carbsGrams + 'g';
        document.getElementById('carbs-cals-display').textContent = Math.round(carbsCals);
        document.getElementById('fat-grams-display').textContent = fatGrams + 'g';
        document.getElementById('fat-cals-display').textContent = Math.round(fatCals);

        // Update hidden fields for generateDietPlan
        document.getElementById('dp_custom_protein').value = proteinGrams;
        document.getElementById('dp_custom_carbs').value = carbsGrams;
        document.getElementById('dp_custom_fat').value = fatGrams;
    } else {
        // Reset displays if no calories
        document.getElementById('protein-grams-display').textContent = '0g';
        document.getElementById('protein-cals-display').textContent = '0';
        document.getElementById('carbs-grams-display').textContent = '0g';
        document.getElementById('carbs-cals-display').textContent = '0';
        document.getElementById('fat-grams-display').textContent = '0g';
        document.getElementById('fat-cals-display').textContent = '0';
    }
}

// Auto-fill remaining percentage when 2 of 3 are entered
function autoFillRemainingPercentage(changedField) {
    const proteinInput = document.getElementById('dp_protein_pct');
    const carbsInput = document.getElementById('dp_carbs_pct');
    const fatInput = document.getElementById('dp_fat_pct');

    const proteinPct = parseFloat(proteinInput.value) || 0;
    const carbsPct = parseFloat(carbsInput.value) || 0;
    const fatPct = parseFloat(fatInput.value) || 0;

    // Count how many fields have values
    const hasProtein = proteinInput.value !== '';
    const hasCarbs = carbsInput.value !== '';
    const hasFat = fatInput.value !== '';
    const filledCount = (hasProtein ? 1 : 0) + (hasCarbs ? 1 : 0) + (hasFat ? 1 : 0);

    // If exactly 2 fields have values, auto-fill the 3rd
    if (filledCount === 2) {
        const remaining = 100 - proteinPct - carbsPct - fatPct;
        if (remaining >= 0) {
            if (!hasProtein && changedField !== 'protein') {
                proteinInput.value = remaining;
            } else if (!hasCarbs && changedField !== 'carbs') {
                carbsInput.value = remaining;
            } else if (!hasFat && changedField !== 'fat') {
                fatInput.value = remaining;
            }
        }
    }

    updateMacroFromPercentages();
}

// Add input listeners for percentage fields
document.getElementById('dp_custom_calories').addEventListener('input', updateMacroFromPercentages);

document.getElementById('dp_protein_pct').addEventListener('input', function() {
    lastEditedMacro = 'protein';
    autoFillRemainingPercentage('protein');
});

document.getElementById('dp_carbs_pct').addEventListener('input', function() {
    lastEditedMacro = 'carbs';
    autoFillRemainingPercentage('carbs');
});

document.getElementById('dp_fat_pct').addEventListener('input', function() {
    lastEditedMacro = 'fat';
    autoFillRemainingPercentage('fat');
});

// Template checkbox toggle
document.getElementById('dp_use_template').addEventListener('change', function() {
    const fields = document.getElementById('template-selector-fields');
    if (this.checked) {
        fields.classList.remove('hidden');
        loadTemplatesList();
        // Uncheck Start from Scratch if template is selected
        document.getElementById('dp_start_from_scratch').checked = false;
    } else {
        fields.classList.add('hidden');
    }
});

// Start from Scratch - uncheck template when selected
document.getElementById('dp_start_from_scratch').addEventListener('change', function() {
    if (this.checked) {
        document.getElementById('dp_use_template').checked = false;
        document.getElementById('template-selector-fields').classList.add('hidden');
    }
});

// Template selection change - show preview and enable/disable buttons
document.getElementById('dp_template_select').addEventListener('change', function() {
    const templateId = this.value;
    const previewDiv = document.getElementById('template-preview');
    const editBtn = document.getElementById('edit-template-btn');
    const deleteBtn = document.getElementById('delete-template-btn');

    if (!templateId) {
        previewDiv.classList.add('hidden');
        editBtn.disabled = true;
        deleteBtn.disabled = true;
        return;
    }

    // Enable buttons when a template is selected
    editBtn.disabled = false;
    deleteBtn.disabled = false;

    // Use cached templates from API
    const template = cachedTemplates.find(t => t.id == templateId);

    if (template) {
        const mealCount = template.plan_data?.[0]?.plan?.length || 0;
        const dayCount = template.plan_data?.length || 0;
        previewDiv.innerHTML = `<strong>${template.name}</strong>: ${dayCount} day(s), ${mealCount} meals/day<br><em>${template.description || 'No description'}</em>`;
        previewDiv.classList.remove('hidden');
    }
});

// TEMPLATE MANAGEMENT FUNCTIONS
const TEMPLATES_ENDPOINT = '/.netlify/functions/meal-plan-templates';
let cachedTemplates = []; // Store loaded templates for quick access

async function loadTemplatesList() {
    const select = document.getElementById('dp_template_select');

    if (!currentCoach || !currentCoach.id) {
        console.warn('No coach logged in, cannot load templates');
        select.innerHTML = '<option value="">Please log in first</option>';
        return;
    }

    // Show loading state
    select.innerHTML = '<option value="">Loading templates...</option>';

    try {
        const response = await fetch(`${TEMPLATES_ENDPOINT}?coachId=${currentCoach.id}`);
        const data = await response.json();

        if (!response.ok) {
            throw new Error(data.error || 'Failed to load templates');
        }

        cachedTemplates = data.templates || [];

        // Clear and rebuild options
        select.innerHTML = '<option value="">Select a template...</option>';

        cachedTemplates.forEach(template => {
            const option = document.createElement('option');
            option.value = template.id;
            const dayCount = template.plan_data?.length || 0;
            option.textContent = `${template.name} (${dayCount} days)`;
            select.appendChild(option);
        });

        if (cachedTemplates.length === 0) {
            const option = document.createElement('option');
            option.value = '';
            option.textContent = 'No templates saved yet';
            option.disabled = true;
            select.appendChild(option);
        }

        console.log(`Loaded ${cachedTemplates.length} templates`);

    } catch (error) {
        console.error('Error loading templates:', error);
        select.innerHTML = '<option value="">Error loading templates</option>';
    }
}

async function saveAsTemplate() {
    if (!lastPlanQuery.currentPlan || lastPlanQuery.currentPlan.length === 0) {
        alert('No meal plan to save as template. Please generate a plan first.');
        return;
    }

    if (!currentCoach || !currentCoach.id) {
        alert('Please log in to save templates.');
        return;
    }

    const templateName = prompt('Enter a name for this template:', `Template - ${new Date().toLocaleDateString()}`);
    if (!templateName) return;

    const templateDesc = prompt('Enter a brief description (optional):', '');

    const planData = lastPlanQuery.currentPlan.map(day => ({
        day: day.day,
        plan: day.plan.map(meal => ({
            type: meal.type,
            name: meal.name,
            calories: meal.calories,
            protein: meal.protein,
            carbs: meal.carbs,
            fat: meal.fat,
            ingredients: meal.ingredients,
            ingredientData: meal.ingredientData || null,
            instructions: meal.instructions,
            isCustom: meal.isCustom || false
        }))
    }));

    try {
        const response = await fetch(TEMPLATES_ENDPOINT, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                coachId: currentCoach.id,
                name: templateName,
                description: templateDesc || '',
                mealsStructure: lastPlanQuery.meals,
                macroPreference: lastPlanQuery.macroPreference,
                preference: lastPlanQuery.preference,
                planData: planData
            })
        });

        const data = await response.json();
        console.log('Template API response:', response.status, data);

        if (!response.ok) {
            const errorMsg = data.details || data.error || 'Failed to save template';
            console.error('Template save failed:', errorMsg);
            throw new Error(errorMsg);
        }

        alert(`Template "${templateName}" saved successfully!`);
        console.log('Template saved:', data.template);

        // Refresh templates list
        await loadTemplatesList();

    } catch (error) {
        console.error('Error saving template:', error);
        alert('Failed to save template. Please try again.');
    }
}

function applyTemplate(templateId) {
    const template = cachedTemplates.find(t => t.id == templateId);

    if (!template) {
        alert('Template not found. Please refresh the templates list.');
        return null;
    }

    // Return a deep copy of the template plan data
    return JSON.parse(JSON.stringify(template.plan_data));
}

async function deleteTemplate(templateId) {
    if (!currentCoach || !currentCoach.id) {
        alert('Please log in to delete templates.');
        return;
    }

    if (!confirm('Are you sure you want to delete this template?')) {
        return;
    }

    try {
        const response = await fetch(`${TEMPLATES_ENDPOINT}?templateId=${templateId}&coachId=${currentCoach.id}`, {
            method: 'DELETE'
        });

        const data = await response.json();

        if (!response.ok) {
            throw new Error(data.error || 'Failed to delete template');
        }

        alert('Template deleted successfully!');
        await loadTemplatesList();

    } catch (error) {
        console.error('Error deleting template:', error);
        alert('Failed to delete template. Please try again.');
    }
}

// Delete selected template from dropdown
function deleteSelectedTemplate() {
    const templateId = document.getElementById('dp_template_select').value;
    if (!templateId) {
        alert('Please select a template first.');
        return;
    }
    deleteTemplate(templateId);
}

// Edit selected template
async function editSelectedTemplate() {
    const templateId = document.getElementById('dp_template_select').value;
    if (!templateId) {
        alert('Please select a template first.');
        return;
    }

    const template = cachedTemplates.find(t => t.id == templateId);
    if (!template) {
        alert('Template not found. Please refresh the list.');
        return;
    }

    // Prompt for new name
    const newName = prompt('Edit template name:', template.name);
    if (newName === null) return; // User cancelled

    // Prompt for new description
    const newDescription = prompt('Edit template description:', template.description || '');
    if (newDescription === null) return; // User cancelled

    if (!newName.trim()) {
        alert('Template name cannot be empty.');
        return;
    }

    try {
        const response = await fetch(TEMPLATES_ENDPOINT, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                templateId: templateId,
                coachId: currentCoach.id,
                name: newName.trim(),
                description: newDescription.trim()
            })
        });

        const data = await response.json();

        if (!response.ok) {
            throw new Error(data.error || 'Failed to update template');
        }

        alert('Template updated successfully!');
        await loadTemplatesList();

        // Re-select the template
        document.getElementById('dp_template_select').value = templateId;
        // Trigger change event to update preview
        document.getElementById('dp_template_select').dispatchEvent(new Event('change'));

    } catch (error) {
        console.error('Error updating template:', error);
        alert('Failed to update template. Please try again.');
    }
}

// Load templates after coach is loaded (deferred)
setTimeout(() => {
    if (currentCoach && currentCoach.id) {
        loadTemplatesList();
    }
}, 1000);

// ============================================
// MEAL IMAGE GENERATION
// ============================================
const MEAL_IMAGE_ENDPOINT = '/.netlify/functions/meal-image';

// Cache for meal images to avoid repeated API calls
const mealImageCache = {};

// Fetch or generate meal image
async function fetchMealImage(mealName, imageElementId) {
    const imageContainer = document.getElementById(imageElementId);
    if (!imageContainer) return;

    // Check cache first
    if (mealImageCache[mealName]) {
        updateImageElement(imageContainer, mealImageCache[mealName], mealName);
        return;
    }

    // Show loading state
    imageContainer.innerHTML = '‚è≥';
    imageContainer.classList.add('loading');

    try {
        // First check if image exists
        const checkResponse = await fetch(`${MEAL_IMAGE_ENDPOINT}?mealName=${encodeURIComponent(mealName)}`);
        const checkData = await checkResponse.json();

        if (checkData.exists && checkData.imageUrl) {
            mealImageCache[mealName] = checkData.imageUrl;
            updateImageElement(imageContainer, checkData.imageUrl, mealName);
            return;
        }

        // Image doesn't exist, generate it
        const generateResponse = await fetch(MEAL_IMAGE_ENDPOINT, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ mealName })
        });

        const generateData = await generateResponse.json();

        if (generateData.success && generateData.imageUrl) {
            mealImageCache[mealName] = generateData.imageUrl;
            updateImageElement(imageContainer, generateData.imageUrl, mealName);
        } else {
            throw new Error(generateData.error || 'Failed to generate image');
        }
    } catch (error) {
        console.error('Error fetching meal image:', error);
        imageContainer.classList.remove('loading');
        imageContainer.innerHTML = 'üçΩÔ∏è';
    }
}

// Update image element with the loaded image
function updateImageElement(container, imageUrl, mealName) {
    container.classList.remove('loading');
    container.classList.remove('meal-card-image-placeholder');

    // Create wrapper container
    const wrapper = document.createElement('div');
    wrapper.className = 'meal-image-container';
    wrapper.id = container.id;
    wrapper.dataset.mealName = mealName;

    // Create image
    const img = document.createElement('img');
    img.src = imageUrl;
    img.alt = mealName;
    img.className = 'meal-card-image';
    img.onclick = () => showMealImageLarge({ src: imageUrl, alt: mealName });

    // Handle image load errors - show placeholder instead of broken icon
    img.onerror = () => {
        console.warn(`Image failed to load for: ${mealName}`);
        // Create a new placeholder div
        const placeholder = document.createElement('div');
        placeholder.className = 'meal-card-image-placeholder';
        placeholder.id = wrapper.id;
        placeholder.dataset.mealName = mealName;
        placeholder.onclick = () => showMealImageLarge(placeholder);
        placeholder.innerHTML = 'üçΩÔ∏è';
        placeholder.title = 'Image unavailable - click Generate Image to create one';
        // Replace the wrapper with the placeholder
        if (wrapper.parentNode) {
            wrapper.parentNode.replaceChild(placeholder, wrapper);
        }
    };

    // Create regenerate button (subtle, shows on hover)
    const regenBtn = document.createElement('button');
    regenBtn.className = 'regenerate-btn';
    regenBtn.innerHTML = 'üîÑ';
    regenBtn.title = 'Regenerate image with custom prompt';
    regenBtn.onclick = (e) => {
        e.stopPropagation();
        openImagePromptModal(wrapper, mealName);
    };

    wrapper.appendChild(img);
    wrapper.appendChild(regenBtn);
    container.replaceWith(wrapper);
}

// Store current image container for custom prompt modal
let currentImageContainer = null;
let currentMealName = null;

// Open custom image prompt modal
function openImagePromptModal(container, mealName) {
    currentImageContainer = container;
    currentMealName = mealName;

    document.getElementById('image-prompt-meal-name').textContent = mealName;
    document.getElementById('custom-image-prompt').value = '';
    document.getElementById('image-prompt-modal').classList.remove('hidden');
    document.getElementById('custom-image-prompt').focus();
}

// Close custom image prompt modal
function closeImagePromptModal() {
    document.getElementById('image-prompt-modal').classList.add('hidden');
    currentImageContainer = null;
    currentMealName = null;
}

// Submit custom image prompt
async function submitCustomImagePrompt() {
    const customPrompt = document.getElementById('custom-image-prompt').value.trim();
    const btn = document.getElementById('generate-custom-image-btn');

    if (!currentImageContainer || !currentMealName) {
        closeImagePromptModal();
        return;
    }

    btn.disabled = true;
    btn.textContent = '‚è≥ Generating...';

    try {
        await regenerateMealImage(currentImageContainer, currentMealName, customPrompt || null);
        closeImagePromptModal();
    } catch (error) {
        alert('Failed to generate image: ' + error.message);
    } finally {
        btn.disabled = false;
        btn.textContent = 'üé® Generate';
    }
}

// Regenerate meal image (delete old, generate new)
async function regenerateMealImage(container, mealName, customPrompt = null) {
    const regenBtn = container.querySelector('.regenerate-btn');
    const img = container.querySelector('img');

    if (regenBtn) {
        regenBtn.classList.add('loading');
        regenBtn.disabled = true;
    }

    try {
        // Call API with regenerate flag and optional custom prompt
        const response = await fetch('/.netlify/functions/meal-image', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                mealName,
                regenerate: true,
                customPrompt: customPrompt
            })
        });

        const data = await response.json();

        if (data.success && data.imageUrl) {
            // Update the image with new URL
            if (img) {
                img.src = data.imageUrl;
                img.onclick = () => showMealImageLarge({ src: data.imageUrl, alt: mealName });
            }
            console.log('‚úÖ Regenerated image for:', mealName);
        } else {
            throw new Error(data.error || 'Failed to regenerate image');
        }
    } catch (error) {
        console.error('Error regenerating image:', error);
        throw error;
    } finally {
        if (regenBtn) {
            regenBtn.classList.remove('loading');
            regenBtn.disabled = false;
        }
    }
}

// Show large image in modal
function showMealImageLarge(element) {
    const imageUrl = element.src || element.dataset?.imageUrl;
    const mealName = element.alt || element.dataset?.mealName || 'Meal';

    if (!imageUrl || imageUrl.includes('undefined')) {
        // No image yet, prompt to generate
        return;
    }

    const modal = document.createElement('div');
    modal.className = 'image-modal';
    modal.innerHTML = `<img src="${imageUrl}" alt="${mealName}">`;
    modal.onclick = () => modal.remove();

    document.body.appendChild(modal);
}

// Handle generate image button click
document.addEventListener('click', async (e) => {
    if (e.target.matches('[data-action="generate-meal-image"]')) {
        const button = e.target;
        const imageId = button.dataset.imageId;
        const mealName = button.dataset.mealName;

        // Disable button and show loading
        button.disabled = true;
        button.textContent = '‚è≥ Generating...';

        await fetchMealImage(mealName, imageId);

        // Re-enable button
        button.disabled = false;
        button.textContent = 'üì∑ Generate Image';
    }

    // Handle "Generate All Images" button
    if (e.target.matches('[data-action="generate-all-images"]')) {
        const button = e.target;
        button.disabled = true;

        // Get all meal image placeholders
        const placeholders = document.querySelectorAll('.meal-card-image-placeholder[data-meal-name]');
        const total = placeholders.length;
        let completed = 0;
        let generated = 0;
        let cached = 0;

        if (total === 0) {
            alert('All meal images have already been generated!');
            button.disabled = false;
            return;
        }

        button.textContent = `‚è≥ Processing 0/${total}...`;

        for (const placeholder of placeholders) {
            const mealName = placeholder.dataset.mealName;
            const imageId = placeholder.id;

            if (!mealName) continue;

            try {
                // First check if cached
                const checkResponse = await fetch(`${MEAL_IMAGE_ENDPOINT}?mealName=${encodeURIComponent(mealName)}`);
                const checkData = await checkResponse.json();

                if (checkData.exists && checkData.imageUrl) {
                    // Use cached image
                    mealImageCache[mealName] = checkData.imageUrl;
                    updateImageElement(placeholder, checkData.imageUrl, mealName);
                    cached++;
                } else {
                    // Generate new image
                    button.textContent = `‚è≥ Generating ${completed + 1}/${total}...`;

                    const generateResponse = await fetch(MEAL_IMAGE_ENDPOINT, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ mealName })
                    });

                    const generateData = await generateResponse.json();

                    if (generateData.success && generateData.imageUrl) {
                        mealImageCache[mealName] = generateData.imageUrl;
                        // Find the current element (might have moved in DOM)
                        const currentPlaceholder = document.getElementById(imageId);
                        if (currentPlaceholder) {
                            updateImageElement(currentPlaceholder, generateData.imageUrl, mealName);
                        }
                        generated++;
                    }
                }
            } catch (error) {
                console.error('Error generating image for:', mealName, error);
            }

            completed++;
            button.textContent = `‚è≥ Processing ${completed}/${total}...`;
        }

        button.disabled = false;
        button.textContent = 'üì∑ Generate All Images';
        alert(`Done! Generated ${generated} new images, loaded ${cached} cached images.`);
    }
});

// Auto-load cached images when displaying plan
async function loadCachedMealImages() {
    console.log('üñºÔ∏è Loading cached meal images...');
    const imageContainers = document.querySelectorAll('.meal-card-image-placeholder[data-meal-name]');
    console.log(`Found ${imageContainers.length} meals to check for cached images`);

    if (imageContainers.length === 0) return;

    // Load all images in parallel for faster loading
    const promises = Array.from(imageContainers).map(async (container) => {
        const mealName = container.dataset.mealName;
        if (!mealName) return;

        // Check if image exists (don't generate, just load cached)
        try {
            const response = await fetch(`${MEAL_IMAGE_ENDPOINT}?mealName=${encodeURIComponent(mealName)}`);
            const data = await response.json();

            if (data.exists && data.imageUrl) {
                console.log('‚úÖ Found cached image for:', mealName);
                mealImageCache[mealName] = data.imageUrl;
                // Re-find the container in case DOM changed
                const currentContainer = document.getElementById(container.id);
                if (currentContainer && currentContainer.classList.contains('meal-card-image-placeholder')) {
                    updateImageElement(currentContainer, data.imageUrl, mealName);
                }
            }
        } catch (error) {
            console.log('No cached image for:', mealName);
        }
    });

    await Promise.all(promises);
    console.log('üñºÔ∏è Finished loading cached images');
}

// Load cached images after plan is displayed
const originalDisplayDietPlan = displayDietPlan;
displayDietPlan = function(multiDayData) {
    originalDisplayDietPlan(multiDayData);
    // Delay to allow DOM to update, then load cached images
    setTimeout(() => {
        loadCachedMealImages();
    }, 800);
};
</script>

<!-- PWA Service Worker Registration -->
<script>
    if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
            navigator.serviceWorker.register('/sw.js')
                .then(reg => console.log('SW registered:', reg.scope))
                .catch(err => console.log('SW registration failed:', err));
        });
    }

    // Logout function
    async function logout() {
        const { error } = await supabaseClient.auth.signOut();
        if (error) {
            alert('Error logging out: ' + error.message);
        } else {
            window.location.href = 'login.html';
        }
    }

    // Mobile menu toggle
    document.getElementById('mobileMenuBtn').addEventListener('click', () => {
        document.querySelector('.sidebar').classList.toggle('open');
        document.getElementById('sidebarOverlay').classList.toggle('active');
    });

    document.getElementById('sidebarOverlay').addEventListener('click', () => {
        document.querySelector('.sidebar').classList.remove('open');
        document.getElementById('sidebarOverlay').classList.remove('active');
    });
</script>
    </main>
</body>
</html>
